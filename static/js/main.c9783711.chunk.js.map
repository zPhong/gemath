{"version":3,"sources":["serviceWorker.js","Model/AppData.js","core/definition/define.js","utils/values.js","core/math/Converter.js","core/math/Generation.js","utils/ErrorHandleService.js","vendor/euclid/calc.js","core/math/Math2D.js","utils/checker.js","core/definition/defineObjType.js","core/validation/validation.js","core/definition/index.js","core/definition/defineShapeType.js","core/definition/definePointType.js","core/math/GenerateGeometry.js","core/analysis/ReadPointsMap.js","core/analysis/ReadRelation.js","core/analysis/Analysis.js","Model/RelationInputModel.js","ViewModel/DataViewModel.js","View/components/InputItem/InputItem.js","View/components/Icon/Icon.js","View/components/Icon/Svg.js","View/components/SegmentSetting/SegmentSetting.js","vendor/euclid/model/geom.js","vendor/euclid/model/point.js","vendor/euclid/model/circle.js","vendor/euclid/model/line.js","vendor/euclid/model/segment.js","vendor/euclid/intersection.js","vendor/euclid/model/intersection.js","vendor/euclid/model/index.js","vendor/euclid/scene.js","vendor/euclid/render.js","View/components/DrawingPanel/DrawingPanel.js","View/MainView.js","index.js","utils/color.scss","View/components/InputItem/InputItem.scss"],"names":["Boolean","window","location","hostname","match","appData","AppData","Object","classCallCheck","this","additionSegment","relationsResult","pointsMap","pointsDirectionMap","executedRelations","executedNode","__pointDetails__","Map","clear","segment","push","newPointsMap","value","defineSentences","define","relation","shape","reversedDependentObjRelation","RankingObjectContain","objectWithPoint","validate","object","point","length","format","ray","line","angle","triangle","quadrilateral","trapezoid","parallelogram","rectangle","rhombus","square","circle","shapeType","shapeRules","right","isosceles","right_isosceles","equilateral","normal","mappingShapeType","vuông","cân","vuông cân","đều","nội tiếp","ngoại tiếp","bàng tiếp","circleType","TwoStaticPointRequireShape","ShapeAffectBySegmentChange","GConst","Number","freeze","MIN_RANDOM_NUMBER","MAX_RANDOM_NUMBER","MIN_RANDOM_GENERATION","MAX_RANDOM_GENERATION","NOT_FOUND","String","INFINITY","IMPOSSIBLE","TOO_SHORT","NOT_ENOUGH_SET","NOT_BE_IN_LINE","Regex","KEY","OTHER","Others","OPERATIONS","Errors","UNDEFINED_ERROR","WRONG_FORMAT","MAXIMUM_POINT_ERROR","InputStatus","SUCCESS","NORMAL","ERROR","TutorialString","STEP_ONE","convertLinearToEquation","l","a","b","c","d","e","convertEquationToLineType","convertLineTypeToEquation","MIN","MAX","getRandomValue","min","max","Math","floor","random","getRandomPointInEquation","equation","tempX","x","y","centerPoint","radius","sqrt","randomValueX","solvedValueY","calculateQuadraticEquation","secondRoot","firstRoot","generatePointAlignmentInside","firstPoint","secondPoint","getLineFromTwoPoints","generatePointAlignmentOutside","isRight","arguments","undefined","tempXRight","tempXLeft","ErrorCode","200","300","301","400","401","500","501","502","ErrorService","message","code","errorRelation","index","dataViewModel","inputData","filter","data","executedInputIndex","executingRelation","RelationsInput","status","alert","console","error","distance","p1","p2","distanceSquared","dx","dy","_makeRound","num","f","isNaN","myF","pow","round","calculateVector","isVectorSameDirection","firstVector","secondVector","abs","isVectorInSameLine","calculateMiddlePoint","calculateSymmetricalPoint","directionVector","normalVector","calculateDistanceTwoPoints","squareX","squareY","calculateDistanceFromPointToLine","numerator","denominator","calculateParallelLineByPointAndLine","lineEquation","parLine","result","calculatePerpendicularLineByPointAndLine","perpendicularLine","perLine","calculateIntersectionByLineAndLine","lineOne","lineTwo","calculateSetOfEquationTypeAndQuadraticEquation","calculateCircleEquationByCenterPoint","roundedRadius","calculateInternalBisectLineEquation","pointOne","pointTwo","results","_calculateBisectLineEquation","firstLine","secondLine","getAngleFromTwoLines","set","_getInternalBisectLineEquation","calculateExternalBisectLineEquation","internalLine","JSON","stringify","resultOne","resultTwo","coefficient","calculateIntersectionEquationTypeWithCircleEquation","q","A","B","delta","isIn","p","C","D","E","F","G","H","root","r1","r2","calculateIntersectionTwoCircleEquations","firstEquation","secondEquation","q1","q2","d1","d2","tempY","calculateSetOfEquationTypes","Z","_D","_E","_G","roots","calculateLinesByAnotherLineAndAngle","rootPoint","staticPoint","dynamicPoint","equations","cosine","cos","PI","_calculateLinesByAnotherLineAndAngle","map","newRootPoint","i","vectorOne","vectorTwo","staticVector","dynamicVector","acos","calculateIntegratedDirection","calculateVectorLength","parseInt","showError","vector","makeRoundCoordinate","a1","a2","b1","b2","getMiddlePointFromThreePointsInALine","p3","dis_p1_p2","dis_p2_p3","dis_p1_p3","calculateTangentEquation","tangentPoint","tangentEquation","isTwoEquationEqual","equationOne","equationTwo","isIsosceles","isNumber","isObjectLike","getTag","isQuadraticEquation","toString","call","checkFormatString","str","split","forEach","element","char","toLowerCase","defineObject","slice","includes","validateObject","validateValue","type","_validateName","validateType","validateGeometryType","key","validateAngle","checkObjectRelationship","obj1","obj2","check","toConsumableArray","Set","indexOf","string","item","array","validateInformation","info","outputType","keys","validateShapeFormat","validateShapeType","shapeFormatCheck","shapeTypeCheck","validateShape","j","indexOfRankingLevel","indexOfObjectCurrentLevel","indexOfObjectNextLevel","validateDataRelationship","defineInformation","splitter","shapeName","pop","otherData","replace","trim","join","log","defineShapeType","definePointType","reverse","sortString","toUpperCase","sort","Error","geometricObj","name","z","updateCoordinate","distance_From_A_To_B","linearEquation","coefficientX","constantTerm","p4","table","distanceX","p4X","readRelation","equationResults","operation","objectType","valueData","objectsIncludePoint","getNodeInPointsMapById","coordinate","staticValue","staticObject","angleName","angleValue","checkResult","shapeList","getData","shapes","shapeData","getShapeAffectList","concat","secondLineVector","modifiedAngleName","updatePoint","isChanged","reExecuteNode","checkAndModifiedAngle","changedPoint","calculatedEquation","intersectPoint","transitionVector","rootOne","rootTwo","replaceSetOfEquation","calculateLineEquationByAngleRelation","staticPointOne","staticPointTwo","isStaticNodeById","staticLineEquation","staticDistance","isAlign","coefficientY","ratio","calculatedPoint","betweenPoint","analyzeOperationType","segmentIncludePoint","segmentNotIncludePoint","relationType","getCircleEquation","otherStaticPoint","otherStaticNodeInSegment","points","getAdditionSegment","isValidCoordinate","generatePointMiddleTwoPoints","calculatedLineEquation","isInStaticLine","pushAdditionSegment","isExternal","analyzeRelationType","calculatedLineEquationOne","calculatedLineEquationTwo","analyzeIntersectRelation","otherPointInSegment","tangentPointCoordinate","circleEquation","exceptionPoint","center","calculateTangentIntersectPointsByPointOutsideCircle","filterRoots","isCoordinateDuplicated","filterTangentPoint","analyzeTangentRelation","count","limit","executeRelations","node","dependentNodes","temp","_makeUniqueNodeRelation","relationEquation","calculateInCircleEquation","calculateCircumCircleEquation","escribedPoint","otherPoints","calculateEscribedCirclesEquation","circlesData","ErrorMessage","isExecutedRelation","generateFunc","generateGeometry","pointCoordinate","rootCoordinate","getPointDirectionMap","isUp","makeCorrectShape","id","Array","isArray","executePointDetails","getExecutedRelations","isReCalculated","getExecutedNode","rules","executePoint","staticPointCountRequire","staticPoints","arrayRules","RegExp","executePointIndex","nodeSetEquations","rule","staticLine","nonStaticLine","getLinearEquationByParallelRule","getLinearEquationByPerpendicularRule","includeLine","nonIncludeLine","staticLines","shapePoints","staticPointIndex","pointIndex","calculatedCoordinate","otherPointInIncludeLine","nonStaticPointIndex","updateCoordinateBySpecialPerpendicularRule","otherPoint","getLinearEquationsByEqualRule","RelationPointsMap","analyzeResult","validatedResult","objectPointsMap","sortPriority","getPointsMap","shouldStaticPoint","angles","getRelationsResult","relations","shapePointCount","minCountPoint","getFirstStaticPointInShape","createNode","updateMap","createPointsMapByShape","lastObjectPoints","objectName","createDependentNodeOfObject","nodeOne","nodeTwo","index1","findIndexByNodeId","index2","lastNode","nodeIndex","isStatic","getDependentObject","currentNode","objectSpread","createDependentNodeOfRelation","createPointsMapByRelation","setPointsMap","unique","createPointDetails","isPointsMapStatic","executingNode","getNextExecuteNode","getPointDetails","has","get","isNeedRandomCoordinate","nodeDirectionInfo","staticPointCoordinate","coordinateMatch","directionInfo","matchCount","updateStaticNode","readPointsMap","segments","getShapeSegments","getArraySegments","el1","el2","exception","_dependentNodes","oldNode","RelationInputModel","initializerDefineProperty","_descriptor","_descriptor2","observable","DataViewModel","_this","DataViewModel_descriptor","DataViewModel_descriptor2","_descriptor3","_descriptor4","pointId","nodeId","getIndexOfNodeInPointsMapById","_coordinate","isStaticNode","arrayPoint","dependence","keepExecutedRelations","updatePointsMap","clonePointsMap","sortNodeByPriority","staticNodeOneCount","getDependentStaticNodeCount","nodeOneData","static","nonStatic","minRelationIndex","getMinIndexOfDependentNodeInRelationsList","getIndexOfNodeInPointsMap","staticNodeTwoCount","nodeTwoData","rankOne","rankTwo","indexArray","getIndexOfRelationInRelationsList","apply","list","_calculateSet","relationsInput","input","newRelationInput","resetInputsStatus","splice","_this2","_updatePointDetails","setOfEquation","exceptedCoordinates","searchEquation","replaceEquation","pointDetail","isReplaceComplete","pointDetails","sum","isFirst","newSetOfEquation","currentRoots","finalRoots","_this3","_string","isMatching","preProgress","sentence","getBasicInformation","_defineSentence","others","params","start","end","param","lastParam","getLength","dictionary","centerId","_this4","stringifyCoordinate","_this5","getInformation","setRelationsResult","computed","action","KEYCODE","BACKSPACE","ENTER","InputItem","props","possibleConstructorReturn","getPrototypeOf","inputRef","React","state","shouldRemove","isEmpty","current","focus","currentTarget","onValueChange","setState","_this$props","onBackspace","onSubmit","keyCode","_this$props2","react","className","Icon_Icon","width","height","color","ref","onChange","onKeyUp","aria-describedby","autobind","iconList","inputSuccess","svg","react_default","createElement","fill","viewBox","inputError","inputNormal","icInformation","icRemove","icEdit","icAdd","fillRule","clipRule","Icon","icon","SegmentSetting","visible","isEditMode","isCreateMode","isMouseHoverEdition","isMouseHoverDeletion","_this$state","onDone","onDelete","onVisibleChange","dropdownIndex","filterValue","filterValueIndex","_this$state2","newStartValue","getIndexInData","_this$state3","onSelect","DropdownButton","title","Dropdown","Item","eventKey","_this$state4","renderDropdown","onStartPointSelect","onEndPointSelect","Button","onClick","onChangeContentState","variant","disabled","_this$props$value","dist_default","onstyle","offstyle","handleClassName","off","on","active","onMouseLeave","mouseLeaveEdition","onMouseOver","mouseHoverEdition","onMouseDown","mouseHoverDeletion","mouseLeaveDeletion","renderEditContent","renderShowContent","style","_this$state5","renderContent","Geom","Point","free","esm_get","prototype","Circle","_fromCenterAndBoundaryPoint","_fromCenterAndRadius","defineProperties","radiussq","boundaryPoint","w","h","Line","_p","_clip","assertThisInitialized","theta","atan2","m","left","top","bottom","P","Segment","lengthsq","bounds","_line$_p","slicedToArray","t","clipped","parent","comparePoints","sq","between","intersect","o1","o2","c1","c2","dsq","dd","cx","cy","nx","ny","uniq","intersectCircleCircle","intersectCircleLine","intersectLineLine","constructor","s1","s2","clip","_s1$_p","_s1$_p$","x1","y1","_s1$_p$2","_s2$_p","_s2$_p$","x3","y3","_s2$_p$2","s","_s$_p","_s$_p$","_s$_p$2","x2","y2","_c$center","x0","y0","Dsq","lensq","disc","Intersection","_len","objects","_key","shift","which","test","_result","verbose","pstr","o","addClass","obj","klass","classes","d3","add","Scene","threshold","_last","_objects","equal","every","values","secondObj","id1","id2","tag","_currentTag","existing","prop","find","freeName","update","label","time","Date","klasses","init","renderGeometry","scene","svgElement","circles","selectAll","circleGroup","enter","append","attr","exit","remove","lines","lineGroup","endpoint","coord","DrawingPanel","drawingData","document","getElementById","firstChild","pointElements","baseVal","arrX","arrY","disparityX","disparityY","anchorX","anchorY","_groups","__data__","appendChild","createTextNode","renderPoints","MainView","observer","inputRefs","focusIndex","drawingSegments","scrollView","createRef","trimDrawingData","setTimeout","scrollIntoView","pointData","segmentsData","removeSegments","uniqueSegmentData","segmentData","replaceIndex","addNewInput","removeInput","analyzeInput","model","components_InputItem_InputItem","isAddSegment","onDeleteSegmentSetting","scrollToBottom","prevState","_this6","components_SegmentSetting_SegmentSetting","onDoneSegmentSetting","onChangeSegmentSetting","marginTop","data-toggle","data-target","aria-expanded","aria-controls","OverlayTrigger","container","placement","overlay","Tooltip","aria-labelledby","data-parent","renderRelationInput","onClickDrawing","isInputEmpty","renderSegmentSettings","addNewSegmentSetting","components_DrawingPanel_DrawingPanel","Component","ReactDOM","render","View_MainView","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.c9783711.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","// @flow\r\n\r\nclass AppData {\r\n  constructor() {\r\n    this.additionSegment = [];\r\n    this.relationsResult = {};\r\n    this.pointsMap = [];\r\n    this.pointsDirectionMap = {};\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__ = new Map();\r\n  }\r\n\r\n  clear() {\r\n    this.relationsResult = [];\r\n    this.pointsMap = [];\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__.clear();\r\n  }\r\n\r\n  set setRelationsResult(value) {\r\n    this.relationsResult = value;\r\n  }\r\n\r\n  pushAdditionSegment(segment: string) {\r\n    this.additionSegment.push(segment);\r\n  }\r\n\r\n  get getAdditionSegment() {\r\n    return this.additionSegment;\r\n  }\r\n\r\n  get getRelationsResult() {\r\n    return this.relationsResult;\r\n  }\r\n\r\n  get getPointsMap() {\r\n    return this.pointsMap;\r\n  }\r\n\r\n  setPointsMap(newPointsMap) {\r\n    this.pointsMap = newPointsMap;\r\n  }\r\n\r\n  get getPointDirectionMap() {\r\n    return this.pointsDirectionMap;\r\n  }\r\n\r\n  get getExecutedRelations() {\r\n    return this.executedRelations;\r\n  }\r\n\r\n  get getExecutedNode() {\r\n    return this.executedNode;\r\n  }\r\n\r\n  get getPointDetails() {\r\n    return this.__pointDetails__;\r\n  }\r\n}\r\n\r\nconst appData = new AppData();\r\n\r\nexport default appData;\r\n","const defineSentences = {\r\n  define: [\r\n    '{object} + {object} = {object}',\r\n    '{object} - {object} = {object}',\r\n    '{object} = {value} * {object}',\r\n    '{object} = {object}',\r\n    '{object} > {object}',\r\n    '{object} < {object}'\r\n  ],\r\n  relation: [\r\n    '{object} song song {object}',\r\n    '{object} vuông góc {object}',\r\n    '{object} cắt {object} tại {arrayPoints}',\r\n    '{object} phân giác ngoài {angle}',\r\n    '{object} phân giác trong {angle}',\r\n    '{object} phân giác {angle}',\r\n    '{arrayPoints} thẳng hàng',\r\n    '{point} trung điểm {segment}',\r\n    '{point} không thuộc {object}',\r\n    '{point} thuộc {object}',\r\n    'trung tuyến {segment} của {triangle}',\r\n    'đường cao {segment} của {triangle}',\r\n    '{segment} tiếp tuyến {circle}'\r\n  ],\r\n  shape: [\r\n    'tam giác {type triangle}',\r\n    'tứ giác {quadrilateral}',\r\n    'hình thang {type trapezoid}',\r\n    'hình bình hành {parallelogram}',\r\n    'hình chữ nhật {rectangle}',\r\n    'hình thoi {rhombus}',\r\n    'hình vuông {square}',\r\n    '{object type triangle} tại {escribedPoint}',\r\n    '{object type triangle}'\r\n  ]\r\n};\r\n\r\nconst shapeList = ['triangle', 'quadrilateral', 'trapezoid', 'parallelogram', 'rectangle', 'rhombus', 'square'];\r\n\r\nconst reversedDependentObjRelation = ['vuông góc', 'cắt'];\r\n\r\nconst RankingObjectContain = [['point'], ['segment', 'ray'], ['angle']];\r\n\r\nconst objectWithPoint = ['angle', 'segment', 'ray', 'point', 'circle'];\r\n\r\nconst validate = {\r\n  object: {\r\n    define: ['angle', 'segment'],\r\n    relation: ['ray', 'line', 'segment', 'circle']\r\n  },\r\n  point: { length: 1, format: '1' },\r\n  segment: { length: 2, format: '11' },\r\n  ray: { length: 2, format: '10' },\r\n  line: { length: 1, format: '0' },\r\n  angle: { length: 3 },\r\n  shape: {\r\n    triangle: { length: 3, format: '111' },\r\n    quadrilateral: { length: 4, format: '1111' },\r\n    trapezoid: { length: 4, format: '1111' },\r\n    parallelogram: { length: 4, format: '1111' },\r\n    rectangle: { length: 4, format: '1111' },\r\n    rhombus: { length: 4, format: '1111' },\r\n    square: { length: 4, format: '1111' },\r\n    circle: { length: 1, format: '1' }\r\n  },\r\n  shapeType: {\r\n    triangle: ['', 'vuông', 'cân', 'vuông cân', 'đều', 'nội tiếp', 'ngoại tiếp', 'bàng tiếp'],\r\n    trapezoid: ['', 'vuông', 'cân']\r\n  }\r\n};\r\n\r\n/*\r\n    | song song,\r\n    ^ vuông góc,\r\n    = cân\r\n */\r\nconst shapeRules = {\r\n  triangle: {\r\n    right: '01^02', // Ex: AB vuong goc AC\r\n    isosceles: '01=02',\r\n    right_isosceles: '01^02&01=02',\r\n    equilateral: '01=02&01=12&02=12'\r\n  },\r\n  trapezoid: {\r\n    normal: '01|23',\r\n    right: '01|23&01^03',\r\n    isosceles: '01|23&03=12'\r\n  },\r\n  parallelogram: {\r\n    normal: '01|23&03|12'\r\n  },\r\n  rectangle: {\r\n    normal: '01^12&12^23&23^30&30^01'\r\n  },\r\n  rhombus: {\r\n    normal: '02^13'\r\n  },\r\n  square: {\r\n    normal: '01|23&03|12&01^12&12^23&23^03&01=03&&01=12&12=23&&23=03'\r\n  }\r\n};\r\n\r\nconst mappingShapeType = {\r\n  vuông: 'right',\r\n  cân: 'isosceles',\r\n  'vuông cân': 'right_isosceles',\r\n  đều: 'equilateral',\r\n  'nội tiếp': 'nội tiếp',\r\n  'ngoại tiếp': 'ngoại tiếp',\r\n  'bàng tiếp': 'bàng tiếp'\r\n};\r\n\r\nconst circleType = ['nội tiếp', 'ngoại tiếp', 'bàng tiếp'];\r\n\r\nconst TwoStaticPointRequireShape = ['triangle', 'trapezoid', 'rectangle', 'square'];\r\n\r\nconst ShapeAffectBySegmentChange = ['rhombus', 'trapezoid', 'parallelogram'];\r\n\r\nexport {\r\n  validate,\r\n  TwoStaticPointRequireShape,\r\n  defineSentences,\r\n  RankingObjectContain,\r\n  objectWithPoint,\r\n  shapeList,\r\n  reversedDependentObjRelation,\r\n  shapeRules,\r\n  mappingShapeType,\r\n  circleType,\r\n  ShapeAffectBySegmentChange\r\n};\r\n","const Number = Object.freeze({\r\n  MIN_RANDOM_NUMBER: -10,\r\n  MAX_RANDOM_NUMBER: 10,\r\n  MIN_RANDOM_GENERATION: 5,\r\n  MAX_RANDOM_GENERATION: 15,\r\n  NOT_FOUND: 99\r\n});\r\n\r\nconst String = Object.freeze({\r\n  INFINITY: 'vô cực',\r\n  IMPOSSIBLE: 'vô nghiệm',\r\n  TOO_SHORT: 'quá ngắn',\r\n  NOT_ENOUGH_SET: 'không đủ phương trình tạo thành hệ',\r\n  NOT_BE_IN_LINE: 'điểm không thuộc đường'\r\n});\r\n\r\nconst Regex = Object.freeze({\r\n  KEY: '[^{\\\\}]+(?=})',\r\n  OTHER: '(^([^{]+(?={)))|((?<=})([^{]+)(?={))|(((?<=})[^}]+)$)'\r\n});\r\n\r\nconst Others = Object.freeze({\r\n  OPERATIONS: ['+', '-', '*', '<', '>', '=']\r\n});\r\n\r\nconst Errors = Object.freeze({\r\n  UNDEFINED_ERROR: 'Lỗi không xác dịnh',\r\n  WRONG_FORMAT: 'Sai định dạng',\r\n  MAXIMUM_POINT_ERROR: 'Tối đa 3 điểm thẳng háng'\r\n});\r\n\r\nconst InputStatus = Object.freeze({\r\n  SUCCESS: 'Success',\r\n  NORMAL: `Normal`,\r\n  ERROR: 'Error'\r\n});\r\nconst TutorialString = {\r\n  STEP_ONE: `\r\n  Danh sách các mẫu câu dặc trưng:\r\n    \\n__ = __\r\n    \\n__ song song/vuông góc __\r\n    \\n__ cắt __ tại __\r\n    \\n__ phân giác __\r\n    \\n__ thẳng hàng\r\n    \\n__ trung điểm __\r\n    \\n__ thuộc/không thuộc __\r\n    \\n__ tiếp tuyến (__)\r\n    \\ntam giác {loại} __\r\n    \\ntứ giác __\r\n    \\nđường tròn tâm __ ngoại tiếp/nội tiếp __\r\n\\nLưu ý:\r\n  \\n Đường tròn trong cái mối quan hệ khác sẽ nằm trong ()\r\n  \\n  Vd: AB tiếp tuyến (O)\r\n  `\r\n};\r\nconst GConst = {\r\n  Number,\r\n  String,\r\n  Regex,\r\n  Others,\r\n  Errors,\r\n  InputStatus,\r\n  TutorialString\r\n};\r\n\r\nexport default GConst;\r\n","import type { EquationType, LineType } from '../../utils/types';\r\n\r\nexport function convertLinearToEquation(l: EquationType): EquationType {\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: l.c,\r\n    d: l.d,\r\n    e: l.e\r\n  };\r\n}\r\n\r\nexport function convertEquationToLineType(line: EquationType): LineType {\r\n  return {\r\n    a: -line.c / (line.d === 0 ? 1 : line.d),\r\n    b: -line.e / (line.d === 0 ? 1 : line.d)\r\n  };\r\n}\r\n\r\nexport function convertLineTypeToEquation(line: LineType): EquationType {\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: -line.a,\r\n    d: 1,\r\n    e: -line.b\r\n  };\r\n}\r\n\r\n","// @flow\r\n\r\nimport GConst from '../../utils/values';\r\nimport type { CoordinateType, EquationType } from '../../utils/types';\r\nimport { calculateQuadraticEquation, getLineFromTwoPoints, calculatePerpendicularLineByPointAndLine } from './Math2D';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\n\r\nexport function getStartPoint(): CoordinateType {\r\n  return { x: 0, y: 0, z: 0 };\r\n}\r\n\r\nexport function getRandomValue(min: number, max: number): number {\r\n  if (max < min) {\r\n    return min;\r\n  }\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function getRandomPointInEquation(equation: EquationType): CoordinateType {\r\n  if (!equation.a) {\r\n    equation.a = 0;\r\n  }\r\n  if (!equation.b) {\r\n    equation.b = 0;\r\n  }\r\n  if (equation.a === 0 && equation.b === 0) {\r\n    if (equation.d !== 0) {\r\n      const tempX = getRandomValue(MIN, MAX);\r\n      return {\r\n        x: tempX,\r\n        y: (-equation.e - equation.c * tempX) / equation.d\r\n      };\r\n    } else {\r\n      return {\r\n        x: -equation.e / equation.c,\r\n        y: getRandomValue(MIN, MAX)\r\n      };\r\n    }\r\n  } else if (equation.a === 1 && equation.b === 1) {\r\n    const centerPoint = {\r\n      a: equation.c / -2,\r\n      b: equation.d / -2\r\n    };\r\n\r\n    const radius = Math.sqrt(centerPoint.a * centerPoint.a + centerPoint.b * centerPoint.b - equation.e);\r\n\r\n    const randomValueX = getRandomValue(centerPoint.a - radius, centerPoint.a + radius);\r\n\r\n    const solvedValueY = calculateQuadraticEquation(\r\n      equation.b,\r\n      equation.d,\r\n      randomValueX * randomValueX + equation.c * randomValueX + equation.e\r\n    );\r\n\r\n    if (typeof solvedValueY === 'number') {\r\n      return { x: randomValueX, y: solvedValueY };\r\n    } else if (typeof solvedValueY === 'object') {\r\n      return { x: randomValueX, y: solvedValueY.secondRoot || solvedValueY.firstRoot };\r\n    }\r\n  }\r\n}\r\n\r\nexport function generatePointAlignmentInside(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  const tempX = (firstPoint.x + secondPoint.x) / getRandomValue(2, 5);\r\n  return {\r\n    x: tempX,\r\n    y: (line.c * tempX + line.e) / -line.d\r\n  };\r\n}\r\n\r\nexport function generatePointAlignmentOutside(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true\r\n): CoordinateType {\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  const tempXRight = getRandomValue(secondPoint.x, MAX);\r\n  const tempXLeft = getRandomValue(MIN, firstPoint.x);\r\n  return isRight\r\n    ? {\r\n        x: tempXRight,\r\n        y: (line.c * tempXRight + line.e) / -line.d\r\n      }\r\n    : {\r\n        x: tempXLeft,\r\n        y: (line.c * tempXLeft + line.e) / -line.d\r\n      };\r\n}\r\n\r\nexport function generatePointNotAlignment(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  let resultPoint: CoordinateType = {};\r\n  resultPoint.x = getRandomValue(MIN, MAX);\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  do {\r\n    resultPoint.y = getRandomValue(MIN, MAX);\r\n  } while (resultPoint.y === line.c * resultPoint.x + line.e);\r\n  return resultPoint;\r\n}\r\n\r\nexport function generatePointMiddleTwoPoints(p1: CoordinateType, p2: CoordinateType) {\r\n  const line = getLineFromTwoPoints(p1, p2);\r\n  const randomPoint = generatePointAlignmentInside(p1, p2);\r\n\r\n  const randomLine = calculatePerpendicularLineByPointAndLine(randomPoint, line);\r\n  return getRandomPointInEquation(randomLine);\r\n}\r\n","// @flow\r\n\r\nimport GConst from './values';\r\nimport dataViewModel from '../ViewModel/DataViewModel';\r\n\r\nconst ErrorCode = {\r\n  200: GConst.Errors.UNDEFINED_ERROR,\r\n  300: GConst.Errors.WRONG_FORMAT,\r\n  301: GConst.Errors.MAXIMUM_POINT_ERROR,\r\n  400: GConst.String.IMPOSSIBLE,\r\n  401: GConst.String.INFINITY,\r\n  500: GConst.String.NOT_BE_IN_LINE,\r\n  501: GConst.String.NOT_ENOUGH_SET,\r\n  502: GConst.String.TOO_SHORT\r\n};\r\n\r\nclass ErrorHandleService {\r\n  message: string = '';\r\n\r\n  get ErrorMessage() {\r\n    return this.message;\r\n  }\r\n\r\n  showError(code: string, errorRelation?: mixed) {\r\n    let index;\r\n    if (errorRelation) {\r\n      index = dataViewModel.inputData.filter((data: mixed): boolean => data === errorRelation)[0];\r\n    } else {\r\n      switch (code) {\r\n        case 300:\r\n        case 301:\r\n          index = dataViewModel.executedInputIndex;\r\n          break;\r\n        default:\r\n          index = dataViewModel.inputData.filter((data: mixed): boolean => data === dataViewModel.executingRelation)[0];\r\n      }\r\n    }\r\n    if (index >= 0) {\r\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\r\n    }\r\n\r\n    alert(ErrorCode[code]);\r\n    throw console.error('error', ErrorCode[code]);\r\n  }\r\n}\r\n\r\nconst ErrorService = new ErrorHandleService();\r\n\r\nexport default ErrorService;\r\n","export { distance, distanceSquared };\r\n\r\n/* returns the Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distance(p1, p2) {\r\n  return Math.sqrt(distanceSquared(p1, p2));\r\n}\r\n\r\n/* returns the squared Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distanceSquared(p1, p2) {\r\n  let dx = p1.x - p2.x,\r\n    dy = p1.y - p2.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n","import GConst from '../../utils/values';\r\nimport type {\r\n  CircleType,\r\n  CoordinateType,\r\n  EquationType,\r\n  LineType,\r\n} from '../../utils/types';\r\nimport {\r\n  convertEquationToLineType,\r\n  convertLinearToEquation,\r\n  convertLineTypeToEquation,\r\n} from './Converter';\r\nimport { getRandomPointInEquation } from './Generation';\r\nimport ErrorService from '../../utils/ErrorHandleService';\r\nimport { distance } from '../../vendor/euclid/calc';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\nconst INFINITY = GConst.String.INFINITY;\r\nconst IMPOSSIBLE = GConst.String.IMPOSSIBLE;\r\nconst NOT_BE_IN_LINE = GConst.String.NOT_BE_IN_LINE;\r\n\r\nfunction _makeRound(num: number, f: number = 3): number {\r\n  if (isNaN(num)) {\r\n    throw console.error('error', num);\r\n  }\r\n  const myF = Math.pow(10, f);\r\n  return Math.round(num * myF) / myF;\r\n}\r\n\r\nexport function calculateVector(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isMakeRound? = true,\r\n): CoordinateType {\r\n  if (isMakeRound) {\r\n    return {\r\n      x: _makeRound(secondPoint.x - firstPoint.x),\r\n      y: _makeRound(secondPoint.y - firstPoint.y),\r\n    };\r\n  }\r\n  return {\r\n    x: secondPoint.x - firstPoint.x,\r\n    y: secondPoint.y - firstPoint.y,\r\n  };\r\n}\r\n\r\nexport function isVectorSameDirection(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (firstVector.x === 0) {\r\n    return (\r\n      secondVector.x === 0 && firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y)\r\n    );\r\n  }\r\n\r\n  if (firstVector.y === 0) {\r\n    return (\r\n      secondVector.y === 0 && firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x)\r\n    );\r\n  }\r\n\r\n  if (secondVector.x === 0) {\r\n    return firstVector.x === 0 && firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y);\r\n  }\r\n\r\n  if (secondVector.y === 0) {\r\n    return firstVector.y === 0 && firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x);\r\n  }\r\n\r\n  return (\r\n    firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x) &&\r\n    firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y) &&\r\n    _makeRound(firstVector.x * secondVector.y) === _makeRound(firstVector.y * secondVector.x)\r\n  );\r\n}\r\n\r\nexport function isVectorInSameLine(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (firstVector.x === 0) {\r\n    return secondVector.x === 0;\r\n  }\r\n\r\n  if (firstVector.y === 0) {\r\n    return secondVector.y === 0;\r\n  }\r\n\r\n  if (secondVector.x === 0) {\r\n    return firstVector.x === 0;\r\n  }\r\n\r\n  if (secondVector.y === 0) {\r\n    return firstVector.y === 0;\r\n  }\r\n\r\n  return _makeRound(firstVector.x * secondVector.y) === _makeRound(firstVector.y * secondVector.x);\r\n}\r\n\r\nexport function calculateMiddlePoint(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  return {\r\n    x: (firstPoint.x + secondPoint.x) / 2,\r\n    y: (firstPoint.y + secondPoint.y) / 2,\r\n  };\r\n}\r\n\r\nexport function calculateSymmetricalPoint(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true,\r\n): CoordinateType {\r\n  return isRight\r\n    ?\r\n    {\r\n      x: 2 * secondPoint.x - firstPoint.x,\r\n      y: 2 * secondPoint.y - firstPoint.y,\r\n    }\r\n    :\r\n    {\r\n      x: 2 * firstPoint.x - secondPoint.x,\r\n      y: 2 * firstPoint.y - secondPoint.y,\r\n    };\r\n}\r\n\r\nexport function getLineFromTwoPoints(p1: CoordinateType, p2: CoordinateType): EquationType {\r\n  const directionVector = {\r\n    a: p2.x - p1.x,\r\n    b: p2.y - p1.y,\r\n  };\r\n  const normalVector = {\r\n    a: -directionVector.b,\r\n    b: directionVector.a,\r\n  };\r\n\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: normalVector.a,\r\n    d: normalVector.b,\r\n    e: -normalVector.a * p1.x - normalVector.b * p1.y,\r\n  };\r\n}\r\n\r\nexport function calculateParallelEquation(equation: EquationType): EquationType {\r\n  // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n  const e = Math.floor(Math.random() * 100) - MAX;\r\n\r\n  let parallelEquation: EquationType = {coefficientZ: 0};\r\n  parallelEquation.c = equation.c;\r\n  parallelEquation.d = equation.d;\r\n  parallelEquation.e = e;\r\n\r\n  return parallelEquation;\r\n}\r\n\r\nexport function calculatePerpendicularEquation(equation: EquationType): EquationType {\r\n  // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n  const e = Math.floor(Math.random() * 100) - MIN;\r\n\r\n  let perpendicularEquation: EquationType = {coefficientZ: 0};\r\n  perpendicularEquation.c = -equation.c;\r\n  perpendicularEquation.d = equation.d;\r\n  perpendicularEquation.e = e;\r\n\r\n  return perpendicularEquation;\r\n}\r\n\r\nexport function calculateDistanceTwoPoints(firstPoint: CoordinateType, secondPoint: CoordinateType): number {\r\n  const squareX = (secondPoint.x - firstPoint.x) * (secondPoint.x - firstPoint.x);\r\n  const squareY = (secondPoint.y - firstPoint.y) * (secondPoint.y - firstPoint.y);\r\n\r\n  return Math.sqrt(squareX + squareY);\r\n}\r\n\r\nexport function calculateDistanceFromPointToLine(point: CoordinateType, line: EquationType): number {\r\n  let numerator = Math.abs(line.c * point.x + line.d * point.y + line.e);\r\n  let denominator = Math.sqrt(line.c * line.c + line.d * line.d);\r\n\r\n  if (denominator === 0) {\r\n    return INFINITY;\r\n  }\r\n  return numerator / denominator;\r\n}\r\n\r\nexport function calculateParallelLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  // parallel line has `a` coefficient equals the other line.\r\n  // parallel line's e = -ax - y with (x,y) is coordinate of the point\r\n  const lineEquation = convertEquationToLineType(line);\r\n  const parLine: LineType = {};\r\n  parLine.a = lineEquation.a;\r\n  parLine.b = point.y - lineEquation.a * point.x;\r\n\r\n  let result = convertLineTypeToEquation(parLine);\r\n  if (line.d === 0) {\r\n    result.d = line.d;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function calculatePerpendicularLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  let perpendicularLine: EquationType = {};\r\n\r\n  // perpendicular line has the direction vector is opposite pairs with the other line.\r\n  // perpendicular line's e = -ax - y with (x,y) is coordinate of the point\r\n  if (line.c === 0) {\r\n    perpendicularLine.c = -1 / line.d;\r\n    perpendicularLine.d = 0;\r\n    perpendicularLine.e = -perpendicularLine.c * point.x;\r\n  }\r\n  else if (line.d === 0) {\r\n    perpendicularLine.c = 0;\r\n    perpendicularLine.d = -1 / line.c;\r\n    perpendicularLine.e = -perpendicularLine.d * point.y;\r\n  }\r\n  else {\r\n    const lineEquation = convertEquationToLineType(line);\r\n    const perLine: LineType = {};\r\n    perLine.a = -1 / lineEquation.a;\r\n    perLine.b = point.y + point.x / lineEquation.a;\r\n\r\n    perpendicularLine = convertLineTypeToEquation(perLine);\r\n  }\r\n\r\n  return perpendicularLine;\r\n}\r\n\r\nexport function calculateIntersectionByLineAndLine(lineOne: EquationType, lineTwo: EquationType): CoordinateType {\r\n  return calculateSetOfEquationTypeAndQuadraticEquation(\r\n    {\r\n      c: lineOne.c,\r\n      d: lineOne.d,\r\n      e: lineOne.e,\r\n    },\r\n    {\r\n      a: 0,\r\n      b: 0,\r\n      c: lineTwo.c,\r\n      d: lineTwo.d,\r\n      e: lineTwo.e,\r\n    },\r\n  )[0];\r\n}\r\n\r\nexport function calculateCircleEquationByCenterPoint(\r\n  centerPoint: CoordinateType,\r\n  radius: number,\r\n): TwoVariableQuadraticEquation {\r\n  const roundedRadius = _makeRound(radius, 6);\r\n  return {\r\n    a: 1,\r\n    b: 1,\r\n    c: -2 * centerPoint.x,\r\n    d: -2 * centerPoint.y,\r\n    e: centerPoint.x * centerPoint.x + centerPoint.y * centerPoint.y - roundedRadius * roundedRadius,\r\n  };\r\n}\r\n\r\nexport function calculateInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType,\r\n): EquationType {\r\n  const results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n  const firstLine: EquationType = results[0];\r\n  const secondLine: EquationType = results[1];\r\n\r\n  // const pointInFirstLine: CoordinateType = getRandomPointInLine(lineOne);\r\n  // let pointInSecondLine: CoordinateType = { x: pointInFirstLine.x, y: undefined };\r\n  // if (lineTwo.d !== 0) {\r\n  //   pointInSecondLine.y = (-lineTwo.e - lineTwo.c * pointInSecondLine.x) / lineTwo.d;\r\n  // } else {\r\n  //   pointInSecondLine.y = getRandomValue(MIN_RANDOM_NUMBER, MAX_RANDOM_NUMBER);\r\n  // }\r\n\r\n  if (getAngleFromTwoLines(lineOne, lineTwo) === 0) {\r\n    throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n  }\r\n\r\n  return _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n}\r\n\r\nexport function calculateExternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType,\r\n): EquationType {\r\n  let results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n  const firstLine: EquationType = results[0];\r\n  const secondLine: EquationType = results[1];\r\n\r\n  if (getAngleFromTwoLines(lineOne, lineTwo) === 0) {\r\n    throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n  }\r\n\r\n  const internalLine = _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n\r\n  results = results.filter((line: EquationType): boolean => JSON.stringify(line) !== JSON.stringify(internalLine));\r\n  return results[0];\r\n}\r\n\r\nfunction _calculateBisectLineEquation(lineOne: EquationType, lineTwo: EquationType): [EquationType, EquationType] {\r\n  let resultOne: EquationType = {};\r\n  let resultTwo: EquationType = {};\r\n\r\n  // ax + by + c = +/- [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')] * (a'x + b'y + c)\r\n\r\n  // check if denominator equals 0\r\n  if (lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d === 0) {\r\n    return;\r\n  }\r\n\r\n  // Represent for [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')]\r\n  let coefficient =\r\n    Math.sqrt(lineOne.c * lineOne.c + lineOne.d * lineOne.d) / Math.sqrt(lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d);\r\n\r\n  /*\r\n   * Two results:\r\n   *    (a - coefficient*a')x + (b - coefficient*b')y + c - coefficient*c' = 0\r\n   *    (a + coefficient*a')x + (b + coefficient*b')y + c + coefficient*c' = 0\r\n   */\r\n  resultOne.c = lineOne.c - coefficient * lineTwo.c;\r\n  resultOne.d = lineOne.d - coefficient * lineTwo.d;\r\n  resultOne.e = lineOne.e - coefficient * lineTwo.e;\r\n\r\n  resultTwo.c = lineOne.c + coefficient * lineTwo.c;\r\n  resultTwo.d = lineOne.d + coefficient * lineTwo.d;\r\n  resultTwo.e = lineOne.e + coefficient * lineTwo.e;\r\n\r\n  return [\r\n    resultOne,\r\n    resultTwo,\r\n  ];\r\n}\r\n\r\n/*\r\n *   Line one and line two is 2 lines are the result of _calculateBisectLineEquation function\r\n *   Point one and point two are 2 points that each point located in each line\r\n *             which is equivalent each argument in _calculateBisectLineEquation function\r\n */\r\nfunction _getInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType,\r\n): EquationType {\r\n  let firstEquation = pointOne.x * lineOne.c + pointOne.y * lineOne.d + lineOne.e;\r\n  let secondEquation = pointTwo.x * lineOne.c + pointTwo.y * lineOne.d + lineOne.e;\r\n  return firstEquation * secondEquation <= 0 ?\r\n    lineOne :\r\n    lineTwo;\r\n}\r\n\r\n// TODO: Uncheck\r\nexport function calculateSetOfEquationTypes(d1: EquationType, d2: EquationType) {\r\n  if (\r\n    (d1.c === 0 && d2.c === 0) ||\r\n    (d1.d === 0 && d2.d === 0) ||\r\n    (d1.c === 0 && d1.d === 0) ||\r\n    (d2.c === 0 && d2.d === 0)\r\n  ) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  if (d1.c === 0 && d2.d === 0) {\r\n    return {\r\n      x: -d2.e / d2.c,\r\n      y: -d1.e / d1.d,\r\n    };\r\n  }\r\n  if (d2.c === 0 && d1.d === 0) {\r\n    return {\r\n      x: -d1.e / d1.c,\r\n      y: -d2.e / d2.d,\r\n    };\r\n  }\r\n  if (d1.e === 0 && d2.e === 0) {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n    };\r\n  }\r\n\r\n  if (d1.c === 0) {\r\n    const tempY = -d1.e / d1.d;\r\n    return {\r\n      x: (-d2.e - tempY * d2.d) / d2.c,\r\n      y: tempY,\r\n    };\r\n  }\r\n\r\n  if (d1.d === 0) {\r\n    const tempX = -d1.e / d1.c;\r\n    return {\r\n      x: tempX,\r\n      y: (-d2.e - tempX * d2.c) / d2.d,\r\n    };\r\n  }\r\n\r\n  if (d2.c === 0) {\r\n    const tempY = -d2.e / d2.d;\r\n    return {\r\n      x: (-d1.e - tempY * d1.d) / d1.c,\r\n      y: tempY,\r\n    };\r\n  }\r\n\r\n  if (d2.d === 0) {\r\n    const tempX = -d2.e / d2.c;\r\n    return {\r\n      x: tempX,\r\n      y: (-d1.e - tempX * d1.c) / d1.d,\r\n    };\r\n  }\r\n  const tempY = (d1.e * d2.c - d1.c * d2.e) / (d1.d * d2.c - d1.c * d2.d);\r\n  return {\r\n    x: (-d1.e - d1.d * tempY) / d1.c,\r\n    y: tempY,\r\n  };\r\n}\r\n\r\n/*\r\n *  Find point(s) of intersection between a linear equation and a circle equation.\r\n *  @params:\r\n *        + d (EquationType): a line.\r\n *        + c (CircleEquation): a circle.\r\n *  @return:\r\n *        + IMPOSSIBLE: if distance from center point of the circle to the line is greater than the radius.\r\n *        + (Array<Object>): if the line intersects the circle.\r\n *          + length = 1;\r\n *          + length = 2;\r\n */\r\nexport function calculateIntersectionEquationTypeWithCircleEquation(d: EquationType, q: EquationType): Array<Object> {\r\n  const A = -q.c / 2;\r\n  const B = -q.d / 2;\r\n  const centerPoint: CoordinateType = {\r\n    x: A,\r\n    y: B,\r\n  };\r\n  const distanceFromCenterPointToLine = calculateDistanceFromPointToLine(centerPoint, d);\r\n\r\n  if (distanceFromCenterPointToLine > Math.sqrt(A * A + B * B - q.e)) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  else {\r\n    return calculateSetOfEquationTypeAndQuadraticEquation(d, q);\r\n  }\r\n}\r\n\r\n/*\r\n * Solves a quadratic equation. This equation is defined: Ax2 + Bx + C = 0.\r\n *\r\n *  @params:\r\n *        + a (number): represents x's coefficient.\r\n *        + b (number): represents y's coefficient.\r\n *        + c (number): represents constant term.\r\n * @return:\r\n *        + IMPOSSIBLE (string): if the equation is no root.\r\n *        + (number): if the equation has only ONE root.\r\n *        + x1, x2 (Object): if the equation has TWO root.\r\n */\r\nexport function calculateQuadraticEquation(a: number, b: number, c: number) {\r\n  const delta = b * b - 4 * a * c;\r\n\r\n  let firstRoot,\r\n    secondRoot: number = undefined;\r\n\r\n  if (a === 0) {\r\n    if (b === 0) {\r\n      return INFINITY;\r\n    }\r\n    return -c / b;\r\n  }\r\n  else if (delta < 0) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  else if (delta === 0) {\r\n    return -b / (2 * a);\r\n  }\r\n  else {\r\n    firstRoot = (-b + Math.sqrt(delta)) / (2 * a);\r\n    secondRoot = (-b - Math.sqrt(delta)) / (2 * a);\r\n    return {\r\n      firstRoot,\r\n      secondRoot,\r\n    };\r\n  }\r\n}\r\n\r\n// Ax2 + By2 + Cx + Dy + E = 0\r\nexport function isIn(p: CoordinateType, e: EquationType): boolean {\r\n  if (p.x === undefined || p.y === undefined) {\r\n    return false;\r\n  }\r\n  if (e.a === undefined) {\r\n    e = convertLinearToEquation(e);\r\n  }\r\n  const temp = e.a * p.x * p.x + e.b * p.y * p.y + e.c * p.x + e.d * p.y + e.e;\r\n  return _makeRound(temp) === 0;\r\n}\r\n\r\n/*\r\n *  Solves a set of a linear equation and quadratic equation.\r\n *  Linear equation is defined:     Ax + By + C = 0.\r\n *  Quadratic equation is defined:  Ax2 + By2 + Cx + Dy + E = 0.\r\n *\r\n *  @params:\r\n *        + l (EquationType): represents a linear equation.\r\n *        + q (QuadraticEquation): represents a quadratic equation.\r\n *  @return:\r\n *        + IMPOSSIBLE (string): if the set is no root.\r\n *        + (number): if the set has only ONE root.\r\n *        + x1, x2 (Object): if the set has TWO root.\r\n */\r\nexport function calculateSetOfEquationTypeAndQuadraticEquation(l: EquationType, q: EquationType): Array<Object> {\r\n  let results: Array<Object> = [];\r\n  let u, v, w;\r\n\r\n  const A = l.c;\r\n  const B = l.d;\r\n  const C = l.e;\r\n  const D = q.a;\r\n  const E = q.b;\r\n  const F = q.c;\r\n  const G = q.d;\r\n  const H = q.e;\r\n  if (A !== 0) {\r\n    u = A * A * E + D * B * B;\r\n    v = 2 * B * C * D - A * B * F + A * A * G;\r\n    w = D * C * C - A * C * F + A * A * H;\r\n\r\n    // solves x. Unneeded check IMPOSSIBLE.\r\n    const root = calculateQuadraticEquation(u, v, w);\r\n    if (typeof root === 'number') {\r\n      results.push({\r\n        x: (-C - B * root) / A,\r\n        y: root,\r\n      });\r\n    }\r\n    else if (root === IMPOSSIBLE) {\r\n      return root;\r\n    }\r\n    else {\r\n      const r1 = root.firstRoot;\r\n      const r2 = root.secondRoot;\r\n      results.push({\r\n        x: (-C - B * root.firstRoot) / A,\r\n        y: r1,\r\n      }, {\r\n        x: (-C - B * root.secondRoot) / A,\r\n        y: r2,\r\n      });\r\n    }\r\n  }\r\n  else {\r\n    u = q.a * l.d * l.d;\r\n    v = q.c * l.d * l.d;\r\n    w = q.b * l.e * l.e - q.d * l.d * l.e + q.e * l.d * l.d;\r\n\r\n    // solves x. Unneeded check IMPOSSIBLE.\r\n    const root = calculateQuadraticEquation(u, v, w);\r\n\r\n    if (typeof root === 'number') {\r\n      results.push({\r\n        x: root,\r\n        y: -l.e / l.d,\r\n      });\r\n    }\r\n    else if (root === IMPOSSIBLE) {\r\n      return root;\r\n    }\r\n    else {\r\n      results.push({\r\n        x: root.firstRoot,\r\n        y: -l.e / l.d,\r\n      }, {\r\n        x: root.secondRoot,\r\n        y: -l.e / l.d,\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function calculateIntersectionTwoCircleEquations(firstEquation: EquationType, secondEquation: EquationType) {\r\n  let results: Array<Object> = [];\r\n  if (!firstEquation || !secondEquation) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  let q1, q2;\r\n  firstEquation.a === undefined ?\r\n    (q1 = convertLinearToEquation(firstEquation)) :\r\n    (q1 = firstEquation);\r\n  secondEquation.a === undefined ?\r\n    (q2 = convertLinearToEquation(secondEquation)) :\r\n    (q2 = secondEquation);\r\n\r\n  if (q1.a !== q2.a && q1.b !== q2.b) {\r\n    if (q1.a === 0 && q1.b === 0) {\r\n      // q2 is a quadratic equation\r\n      return calculateIntersectionEquationTypeWithCircleEquation(q1, q2);\r\n    }\r\n    else {\r\n      // q1 is a quadratic equation\r\n      return calculateIntersectionEquationTypeWithCircleEquation(q2, q1);\r\n    }\r\n  }\r\n  else if (q1.a === 0 && q1.b === 0 && q2.a === 0 && q2.b === 0) {\r\n    results.push(calculateSetOfEquationTypes(q1, q2));\r\n  }\r\n  else {\r\n    // a x2 + b y2 + Ax + By + C = 0\r\n    // a'x2 + b'y2 + Dx + Ey + G = 0\r\n    const D = q2.c;\r\n    const E = q2.d;\r\n    const G = q2.e;\r\n\r\n    // Z = a - a'\r\n    const Z = q1.a - q2.a > 0 ?\r\n      q1.a :\r\n      q2.a;\r\n    const _D = Z === q1.a ?\r\n      q1.c :\r\n      D;\r\n    const _E = Z === q1.a ?\r\n      q1.d :\r\n      E;\r\n    const _G = Z === q1.a ?\r\n      q1.e :\r\n      G;\r\n\r\n    const a = Z === q1.a ?\r\n      q1.c - D :\r\n      D - q1.c;\r\n    const b = Z === q1.a ?\r\n      q1.d - E :\r\n      E - q1.d;\r\n    const c = Z === q1.a ?\r\n      q1.e - G :\r\n      G - q1.e;\r\n\r\n    if (a === 0 || b === 0) {\r\n      return IMPOSSIBLE;\r\n    }\r\n    else {\r\n      const u = Z * (b * b + a * a);\r\n      const v = 2 * b * c * Z - _D * a * b + _E * a * a;\r\n      const w = Z * c * c - _D * a * c + _G * a * a;\r\n\r\n      const roots = calculateQuadraticEquation(u, v, w);\r\n      if (roots === IMPOSSIBLE) {\r\n        return roots;\r\n      }\r\n      else if (typeof roots === 'number') {\r\n        results.push({\r\n          x: (-c - b * roots) / a,\r\n          y: roots,\r\n        });\r\n      }\r\n      else {\r\n        const r1 = roots.firstRoot;\r\n        const r2 = roots.secondRoot;\r\n        results.push({\r\n          x: (-c - b * roots.firstRoot) / a,\r\n          y: r1,\r\n        }, {\r\n          x: (-c - b * roots.secondRoot) / a,\r\n          y: r2,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return results;\r\n}\r\n\r\nexport function calculateLinesByAnotherLineAndAngle(\r\n  rootPoint: CoordinateType,\r\n  staticPoint: CoordinateType,\r\n  dynamicPoint: CoordinateType,\r\n  angle: number,\r\n): EquationType {\r\n  const equations = _calculateLinesByAnotherLineAndAngle(\r\n    getLineFromTwoPoints(rootPoint, staticPoint),\r\n    dynamicPoint,\r\n    angle,\r\n  );\r\n  let index = 0;\r\n  const newRootPoints = equations\r\n    .map((equation: EquationType): CoordinateType => {\r\n      return calculateIntersectionByLineAndLine(getLineFromTwoPoints(rootPoint, staticPoint), equation);\r\n    })\r\n    .filter((newRootPoint: CoordinateType, i): boolean => {\r\n      const staticVector = calculateVector(rootPoint, staticPoint, false);\r\n      const dynamicVector = calculateVector(newRootPoint, dynamicPoint, false);\r\n      const result = calculateAngleTwoVector(staticVector, dynamicVector) === parseInt(angle);\r\n      if (result) {\r\n        index = i;\r\n      }\r\n      return result;\r\n    });\r\n  if (newRootPoints[0]) {\r\n    return equations[index];\r\n  }\r\n\r\n  ErrorService.showError('500');\r\n  return null;\r\n}\r\n\r\nfunction calculateIntegratedDirection(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  return vectorOne.x * vectorTwo.x + vectorOne.y * vectorTwo.y;\r\n}\r\n\r\nfunction calculateVectorLength(vector: CoordinateType): number {\r\n  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\r\n}\r\n\r\nexport function calculateAngleTwoVector(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  return _makeRound(\r\n    (Math.acos(\r\n      calculateIntegratedDirection(vectorOne, vectorTwo) /\r\n      (calculateVectorLength(vectorOne) * calculateVectorLength(vectorTwo)),\r\n      ) *\r\n      180) /\r\n    Math.PI,\r\n    1,\r\n  );\r\n}\r\n\r\nexport function _calculateLinesByAnotherLineAndAngle(d: EquationType, p: CoordinateType, angle: number) {\r\n  let results: Array<EquationType> = [];\r\n\r\n  const cosine = Math.cos((angle * Math.PI) / 180);\r\n  const A = d.c * d.c - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n  const B = 2 * d.c * d.d;\r\n  const C = d.d * d.d - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n  const root = calculateQuadraticEquation(A, B, C);\r\n\r\n  if (typeof root === 'number') {\r\n    results.push({\r\n      c: root,\r\n      d: 1,\r\n      e: -root * p.x - p.y,\r\n    });\r\n  }\r\n  else if (root === IMPOSSIBLE) {\r\n    return root;\r\n  }\r\n  else {\r\n    results.push(\r\n      {\r\n        c: root.firstRoot,\r\n        d: 1,\r\n        e: -root.firstRoot * p.x - p.y,\r\n      },\r\n      {\r\n        c: root.secondRoot,\r\n        d: 1,\r\n        e: -root.secondRoot * p.x - p.y,\r\n      },\r\n    );\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function makeRoundCoordinate(point: CoordinateType, f: number = 3) {\r\n  if (typeof point === 'string') {\r\n    return point;\r\n  }\r\n  return {\r\n    x: _makeRound(point.x, f),\r\n    y: _makeRound(point.y, f),\r\n  };\r\n}\r\n\r\nexport function getAngleFromTwoLines(d1: EquationType, d2: EquationType): number {\r\n  if (\r\n    d1.a ||\r\n    d1.b ||\r\n    d2.a ||\r\n    d2.b ||\r\n    (d1.c === 0 && d1.d === 0 && d1.e === 0) ||\r\n    (d2.c === 0 && d2.d === 0 && d2.e === 0)\r\n  ) {\r\n    return -9999;\r\n  }\r\n\r\n\r\n  const a1 = d1.c;\r\n  const a2 = d2.c;\r\n  const b1 = d1.d;\r\n  const b2 = d2.d;\r\n\r\n  const result =\r\n    (Math.acos(Math.abs(a1 * a2 + b1 * b2) / Math.sqrt((a1 * a1 + b1 * b1) * (a2 * a2 + b2 * b2))) * 180) / Math.PI;\r\n\r\n  // round result\r\n  return _makeRound(result, 1);\r\n}\r\n\r\nexport function getMiddlePointFromThreePointsInALine(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType,\r\n): CoordinateType {\r\n  const line = getLineFromTwoPoints(p1, p2);\r\n  if (!isIn(p3, {\r\n    a: 0,\r\n    b: 0,\r\n    c: line.c,\r\n    d: line.d,\r\n    e: line.e,\r\n  })) {\r\n    return NOT_BE_IN_LINE;\r\n  }\r\n\r\n  // another way: check vector =)))~\r\n  const dis_p1_p2 = calculateDistanceTwoPoints(p1, p2);\r\n  const dis_p2_p3 = calculateDistanceTwoPoints(p2, p3);\r\n  const dis_p1_p3 = calculateDistanceTwoPoints(p1, p3);\r\n\r\n  const max = Math.max(dis_p1_p2, dis_p2_p3, dis_p1_p3);\r\n  if (dis_p1_p2 === max) {\r\n    return p3;\r\n  }\r\n  else if (dis_p1_p3 === max) {\r\n    return p2;\r\n  }\r\n  else {\r\n    return p1;\r\n  }\r\n}\r\n\r\nexport function calculateCircumCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  const midperpendicularsLineOne = calculatePerpendicularLineByPointAndLine(\r\n    calculateMiddlePoint(p1, p2),\r\n    getLineFromTwoPoints(p1, p2),\r\n  );\r\n\r\n  const midperpendicularsLineTwo = calculatePerpendicularLineByPointAndLine(\r\n    calculateMiddlePoint(p1, p3),\r\n    getLineFromTwoPoints(p1, p3),\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(midperpendicularsLineOne, midperpendicularsLineTwo);\r\n  const radius = calculateDistanceTwoPoints(center, p1);\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n\r\n  return {\r\n    center,\r\n    radius,\r\n    equation,\r\n  };\r\n}\r\n\r\nexport function calculateInCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  const bisectorLineOne = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(p1, p3),\r\n    getLineFromTwoPoints(p1, p2),\r\n    p2,\r\n    p3,\r\n  );\r\n\r\n  const bisectorLineTwo = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(p2, p3),\r\n    getLineFromTwoPoints(p1, p2),\r\n    p1,\r\n    p3,\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n  const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(p1, p3));\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n  return {\r\n    center,\r\n    radius,\r\n    equation,\r\n  };\r\n}\r\n\r\nexport function calculateEscribedCirclesEquation(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType,\r\n  escribedPoint: CoordinateType,\r\n): CircleType {\r\n  const otherPoints = [\r\n    p1,\r\n    p2,\r\n    p3,\r\n  ].filter(\r\n    (point: CoordinateType): boolean => JSON.stringify(point) !== JSON.stringify(escribedPoint),\r\n  );\r\n\r\n  if (otherPoints.length !== 2) {\r\n    ErrorService.showError('300');\r\n    return;\r\n  }\r\n\r\n  const bisectorLineOne = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(escribedPoint, otherPoints[0]),\r\n    getLineFromTwoPoints(escribedPoint, otherPoints[1]),\r\n    otherPoints[0],\r\n    otherPoints[1],\r\n  );\r\n\r\n  const bisectorLineTwo = calculateExternalBisectLineEquation(\r\n    getLineFromTwoPoints(escribedPoint, otherPoints[0]),\r\n    getLineFromTwoPoints(otherPoints[1], otherPoints[0]),\r\n    escribedPoint,\r\n    otherPoints[1],\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n  const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(otherPoints[1], otherPoints[0]));\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n  return {\r\n    center,\r\n    radius,\r\n    equation,\r\n  };\r\n}\r\n\r\nexport function calculateTangentEquation(circle: EquationType, point?: CoordinateType = null): EquationType {\r\n  const tangentPoint: CoordinateType = point || getRandomPointInEquation(circle);\r\n\r\n  const tangentEquation: EquationType = {};\r\n\r\n  tangentEquation.a = 0;\r\n  tangentEquation.b = 0;\r\n  tangentEquation.c = tangentPoint.x + circle.c / 2;\r\n  tangentEquation.d = tangentPoint.y + circle.d / 2;\r\n  tangentEquation.e = circle.e + (circle.c * tangentPoint.x) / 2 + (circle.d * tangentPoint.y) / 2;\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nexport function calculateTangentIntersectPointsByPointOutsideCircle(\r\n  circle: EquationType,\r\n  point?: CoordinateType = null,\r\n  exceptionPoint?: CoordinateType = null,\r\n): EquationType {\r\n  const center: CoordinateType = {\r\n    x: -circle.c / 2,\r\n    y: -circle.d / 2,\r\n  };\r\n\r\n  const tempCircleCenter = calculateMiddlePoint(center, point);\r\n  const tempCircleRadius = calculateDistanceTwoPoints(center, point) / 2;\r\n\r\n  const tempCircleEquation = calculateCircleEquationByCenterPoint(tempCircleCenter, tempCircleRadius);\r\n\r\n  let roots = calculateIntersectionTwoCircleEquations(circle, tempCircleEquation);\r\n\r\n  if (exceptionPoint) {\r\n    roots = roots.filter((root: CoordinateType): boolean => JSON.stringify(root) !== JSON.stringify(exceptionPoint));\r\n  }\r\n\r\n  return roots;\r\n}\r\n\r\nexport function isTwoEquationEqual(equationOne: EquationType, equationTwo: EquationType): boolean {\r\n  return getAngleFromTwoLines(equationOne, equationTwo, 1) === 0;\r\n}\r\n\r\nexport function isIsosceles(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): boolean {\r\n  let result = false;\r\n  if (distance(p1, p2) === distance(p1, p3)) {\r\n    result = true;\r\n  }\r\n  else if (distance(p2, p1) === distance(p2, p3)) {\r\n    result = true;\r\n  }\r\n  else if (distance(p3, p2) === distance(p3, p1)) {\r\n    result = true;\r\n  }\r\n  return result;\r\n}\r\n","export function isLowerCaseChar(char) {\r\n  if (char === char.toLowerCase()) return '0';\r\n  return '1';\r\n}\r\n\r\nexport function isNumber(value) {\r\n  return !isNaN(value) || typeof value === 'number' || (isObjectLike(value) && getTag(value) === '[object Number]');\r\n}\r\n\r\nexport function isObject(value) {\r\n  const type = typeof value;\r\n  return value !== null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport function isQuadraticEquation(equation): boolean {\r\n  if (!equation) return false;\r\n  return equation.a === 1 && equation.b === 1;\r\n}\r\n\r\nexport function isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n  const tag = getTag(value);\r\n  return (\r\n    tag === '[object Function]' ||\r\n    tag === '[object AsyncFunction]' ||\r\n    tag === '[object GeneratorFunction]' ||\r\n    tag === '[object Proxy]'\r\n  );\r\n}\r\n\r\n/* ====================================================================\r\n                          INTERNAL METHODS\r\n   ==================================================================*/\r\nfunction isObjectLike(value) {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nfunction getTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? '[object Undefined]' : '[object Null]';\r\n  }\r\n  return toString.call(value);\r\n}\r\n","import { isLowerCaseChar, isNumber } from '../../utils/checker';\r\n\r\nexport function checkFormatString(str) {\r\n  let result = '';\r\n  str.split('').forEach((element) => {\r\n    result += isLowerCaseChar(element);\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction validateObject(str) {\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (isNumber(str[i])) return false;\r\n    if (i > 0) if (str.slice(0, i - 1).includes(str[i])) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function defineObject(value) {\r\n  if (isNumber(value)) {\r\n    return 'value';\r\n  }\r\n\r\n  if (!validateObject(value)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (value.length === 3) {\r\n    if (value.includes('(') && value.includes(')')) {\r\n      return 'circle';\r\n    }\r\n    return 'angle';\r\n  }\r\n\r\n  const formatObj = checkFormatString(value);\r\n  switch (formatObj) {\r\n    case '0':\r\n      return 'line';\r\n    case '1':\r\n      return 'point';\r\n    case '10':\r\n      return 'ray';\r\n    case '11':\r\n      return 'segment';\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import { RankingObjectContain, validate } from '../definition/define.js';\r\nimport { checkFormatString } from '../definition/defineObjType';\r\nimport ErrorService from '../../utils/ErrorHandleService.js';\r\n\r\nexport function validateValue(value, type) {\r\n  if (!_validateName(value.value)) return false;\r\n\r\n  const validateGeometryType = validate.object[type];\r\n  let validateType;\r\n\r\n  if (value.key === 'value' || value.key === 'relation' || value.key === 'undefined' || value.key === 'circle')\r\n    return true;\r\n  if (value.key === 'angle') if (!validateAngle(value.value)) return false;\r\n\r\n  if (validateGeometryType.includes(value.key) || value.key !== 'object') {\r\n    const format = checkFormatString(value.value);\r\n    validateType = validate[value.key];\r\n    if (validateType && format)\r\n      if (validateType.format) {\r\n        if (format === validateType.format && value.value.length === validateType.length) return true;\r\n      } else if (value.value.length === validateType.length) {\r\n        return true;\r\n      }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction validateAngle(value) {\r\n  const format = checkFormatString(value);\r\n  return format[1] === '1';\r\n}\r\n\r\nfunction validateShape(shape) {\r\n  const keys = Object.keys(shape);\r\n  const validateShapeFormat = validate.shape[keys[0]];\r\n  const validateShapeType = validate.shapeType[keys[0]] || [''];\r\n  //check format of shape value\r\n  const value = shape[keys[0]];\r\n  const format = checkFormatString(shape[keys[0]]);\r\n  const shapeFormatCheck = format === validateShapeFormat.format && value.length === validateShapeFormat.length;\r\n\r\n  //check type of shape\r\n  const type = shape.type || '';\r\n  const shapeTypeCheck = validateShapeType.includes(type);\r\n\r\n  return shapeFormatCheck && shapeTypeCheck && _validateName(shape[keys[0]]);\r\n}\r\n\r\nfunction validateDataRelationship(data) {\r\n  const keys = Object.keys(data);\r\n\r\n  for (let indexOfRankingLevel = 0; indexOfRankingLevel < RankingObjectContain.length - 1; indexOfRankingLevel++) {\r\n    for (\r\n      let indexOfObjectCurrentLevel = 0;\r\n      indexOfObjectCurrentLevel < RankingObjectContain[indexOfRankingLevel].length;\r\n      indexOfObjectCurrentLevel++\r\n    ) {\r\n      for (\r\n        let indexOfObjectNextLevel = 0;\r\n        indexOfObjectNextLevel < RankingObjectContain[indexOfRankingLevel + 1].length;\r\n        indexOfObjectNextLevel++\r\n      )\r\n        if (keys.includes(RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel])) {\r\n          if (data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]])\r\n            return checkObjectRelationship(\r\n              data[RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel]][0],\r\n              data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]][0]\r\n            );\r\n        }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction checkObjectRelationship(obj1, obj2) {\r\n  let check = obj2.split('').map((char) => {\r\n    return obj1.includes(char);\r\n  });\r\n  const result = [...new Set(check)];\r\n\r\n  if (result.length === 1) {\r\n    return !result[0];\r\n  }\r\n  if (obj2.length === 2) return check.indexOf(true) === -1;\r\n  if (obj2.length === 3) {\r\n    return !(check.indexOf(true) === 0 || check.indexOf(true) === 2);\r\n  }\r\n}\r\n\r\n// check validate name not duplicate Ex: ABB\r\nfunction _validateName(string) {\r\n  return (\r\n    string.split('').length === string.split('').filter((item, index, array) => array.indexOf(item) === index).length\r\n  );\r\n}\r\n\r\nexport function validateInformation(info) {\r\n  const type = info.outputType;\r\n\r\n  if (type === 'shape') {\r\n    return validateShape(info);\r\n  } else {\r\n    delete info.outputType;\r\n    let keys = Object.keys(info);\r\n    if (keys.includes('undefined')) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < keys.length; i++) {\r\n      let array = info[keys[i]];\r\n      let key = keys[i];\r\n      for (let j = 0; j < array.length; j++) {\r\n        let value = array[j];\r\n        const check = validateValue({ key, value }, type);\r\n\r\n        if (!check) return check;\r\n      }\r\n    }\r\n  }\r\n  const keys = Object.keys(info);\r\n  info.outputType = type;\r\n\r\n  if (type === 'define') {\r\n    if (keys.includes('value')) {\r\n      return keys.length === 2;\r\n    } else {\r\n      return keys.length === 1;\r\n    }\r\n  }\r\n\r\n  if (type === 'relation') {\r\n    return validateDataRelationship(info);\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { defineObject } from './defineObjType';\r\nimport { validateInformation } from '../validation/validation';\r\nimport { definePointType } from './definePointType';\r\nimport { defineShapeType } from './defineShapeType';\r\nimport { reversedDependentObjRelation } from './define';\r\n\r\nfunction defineInformation(data) {\r\n  let result;\r\n  switch (data.outputType) {\r\n    case 'shape': {\r\n      result = defineShapeType(data);\r\n      break;\r\n    }\r\n\r\n    case 'relation': {\r\n      result = definePointType(data);\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      result = data;\r\n    }\r\n  }\r\n\r\n  if (reversedDependentObjRelation.includes(result.relation)) {\r\n    result.object = result.object.reverse();\r\n  }\r\n\r\n  Object.keys(result).forEach((key) => {\r\n    if (key === 'object') {\r\n      result[key].forEach((value) => {\r\n        const type = defineObject(value);\r\n        if (!result[type]) result[type] = [];\r\n        if (type === 'segment') {\r\n          value = sortString(value);\r\n        }\r\n        if (type === 'circle') {\r\n          value = value[1].toUpperCase();\r\n        }\r\n\r\n        if (type === 'angle') {\r\n          value = [value[0], value[2]].sort().join(value[1]);\r\n        }\r\n        result[type].push(value);\r\n      });\r\n    }\r\n    if (key === 'circle') {\r\n      result[key].forEach((value: string, index: number) => {\r\n        result[key][index] = result[key][index][1];\r\n      });\r\n    }\r\n  });\r\n\r\n  if (data.outputType === 'shape') {\r\n    const shapeName = Object.keys(result).filter((key) => key !== 'type')[0];\r\n    if (shapeName !== 'triangle') {\r\n      result[shapeName] = sortString(result[shapeName]);\r\n    }\r\n  }\r\n\r\n  delete result.object;\r\n  const validate = validateInformation(result);\r\n\r\n  if (validate) {\r\n    return result;\r\n  } else {\r\n    return { Error: result };\r\n  }\r\n}\r\n\r\nfunction sortString(str) {\r\n  const arr = str.split('');\r\n  const sorted = arr.sort();\r\n  return sorted.join('');\r\n}\r\n\r\nexport { defineInformation };\r\n","export function defineShapeType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key.includes('type')) {\r\n      const splitter = data[key].toString().split(' ');\r\n      const shape = splitter[splitter.length - 1];\r\n      const splitKey = key.split(' ');\r\n      const shapeName = splitKey.pop();\r\n      const otherData = data[key]\r\n        .toString()\r\n        .replace(shape, '')\r\n        .trim()\r\n        .split(' ');\r\n      result[shapeName] = shape;\r\n      let point = '';\r\n      if (otherData[0].length === 3 && otherData[0].includes('(') && otherData[0].includes(')')) {\r\n        result['point'] = otherData[0][1];\r\n        point = otherData[0];\r\n      }\r\n      result['type'] = otherData\r\n        .join(' ')\r\n        .replace(point, '')\r\n        .trim();\r\n    } else {\r\n      result[key] = data[key].toString();\r\n    }\r\n  });\r\n\r\n  console.log(result);\r\n\r\n  return result;\r\n}\r\n","export function definePointType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key === 'arrayPoints') {\r\n      result['point'] = data[key].toString().split(',');\r\n    } else {\r\n      result[key] = data[key];\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n","import dataViewModel from '../../ViewModel/DataViewModel';\r\nimport type { CoordinateType } from '../../utils/types';\r\nimport {\r\n  calculateDistanceTwoPoints,\r\n  getLineFromTwoPoints,\r\n  isIn,\r\n  isIsosceles,\r\n} from './Math2D';\r\nimport { getRandomValue } from './Generation.js';\r\nimport GConst from '../../utils/values';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_GENERATION;\r\nconst MAX = GConst.Number.MAX_RANDOM_GENERATION;\r\n\r\nconst geometricObj = {\r\n  triangle: generateTriangle,\r\n  quadrilateral: generateQuadrilateral,\r\n  trapezoid: generateTrapezoid,\r\n  parallelogram: generateParallelogram,\r\n  rectangle: generateRectangle,\r\n  rhombus: generateRhombus,\r\n  square: generateSquare,\r\n  circle: generateCircle,\r\n};\r\n\r\nexport function generateGeometry(name: string, shape: string, type?: string) {\r\n  const generateFunc = geometricObj[shape];\r\n  if (generateFunc) {\r\n    generateFunc(name, type);\r\n  }\r\n}\r\n\r\nfunction generateTriangle(name: string, type: string) {\r\n  if (name.length === 3) {\r\n    let p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    let p2: CoordinateType = {};\r\n    let p3: CoordinateType = {};\r\n\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n    switch (type) {\r\n      case '': {\r\n        p3.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n        p3.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n        p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        while (isIn(p2, getLineFromTwoPoints(p1, p3)) || isIsosceles(p1, p2, p3)) {\r\n          p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n          p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        }\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        p2.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n        p2.x = p1.x;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        p3.x = getRandomValue(p1.x + 1, p1.x + 50);\r\n        p3.y = p1.y;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        /*\r\n         *            [A]\r\n         *          *    *\r\n         *        *        *\r\n         *      *            *\r\n         *    *                *\r\n         *  B  * * * * * * * *  C\r\n         */\r\n        const distance_From_A_To_B = getRandomValue(3, 6);\r\n\r\n        p3.y = getRandomValue(p1.y + 5, p1.y + 10);\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông cân': {\r\n        const distance_From_A_To_B = getRandomValue(5, 10);\r\n        p3.y = p1.y + distance_From_A_To_B;\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'đều': {\r\n        /*\r\n         *       [A]\r\n         *      *   *\r\n         *    *       *\r\n         * [B] * * * * [C]\r\n         */\r\n        p2.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n        p2.y = Math.sqrt(3) * p2.x;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        const distance_From_A_To_B = calculateDistanceTwoPoints(p1, p2);\r\n        p3.y = p2.y;\r\n        p3.x = -distance_From_A_To_B + p2.x;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Tu giac\r\nfunction generateQuadrilateral(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.y - MAX, p1.y + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {};\r\n    // prevent point C is on AB line\r\n    const linearEquation = getLineFromTwoPoints(p1, p2);\r\n    do {\r\n      p3.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n      p3.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n    }\r\n    while (p3.y === linearEquation.coefficientX * p3.x + linearEquation.constantTerm);\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: getRandomValue(p1.x - MAX, p3.x),\r\n      y: undefined,\r\n    };\r\n\r\n    // prevents p1, p2, p4 are straight\r\n    const line = getLineFromTwoPoints(p1, p2);\r\n    do {\r\n      p4.y = getRandomValue(p1.x, p1.x + MAX);\r\n    }\r\n    while (p4.y === line.coefficientX * p4.x + line.constantTerm);\r\n\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thang\r\nfunction generateTrapezoid(name: string, type: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    switch (type) {\r\n      case '': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + Math.floor(MAX / 2), p1.x + MAX),\r\n          y: p1.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: (getRandomValue(p2.x + Math.floor(MAX / 2), p2.x + MAX)),\r\n          y: getRandomValue(p2.y + Math.floor(MAX / 2), p1.y + MAX),\r\n        };\r\n        dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: getRandomValue(p1.x - Math.floor(MAX / 2), p1.x - MAX),\r\n          y: p3.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[3], p4);\r\n        console.table({\r\n          p1,\r\n          p2,\r\n          p3,\r\n          p4,\r\n        });\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n          y: p1.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: getRandomValue(p2.x + MIN, p2.x + MAX),\r\n          y: getRandomValue(p1.y + MIN, p1.y + MAX),\r\n        };\r\n        dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n        const distanceX = Math.abs(p3.x - p2.x);\r\n        const p4X = getRandomValue(0, 2) === 1 ?\r\n          p1.x + distanceX :\r\n          p1.x - distanceX;\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: p4X,\r\n          y: p3.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[3], p4);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        // TODO: vuong tai dau?\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// hinh binh hanh\r\nfunction generateParallelogram(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    let p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    let p4: CoordinateType = {\r\n      x: p3.x - p2.x - p1.x,\r\n      y: p3.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateRectangle(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: getRandomValue(p2.y + MIN, p2.y + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thoi\r\nfunction generateRhombus(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: -getRandomValue(p1.y + MIN, p1.y + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: 2 * Math.abs(p2.x - p1.x),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p2.x,\r\n      y: Math.abs(-p2.y - p1.y),\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateSquare(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: p2.y + calculateDistanceTwoPoints(p1, p2),\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateCircle(name: string) {\r\n}\r\n","import type { CoordinateType, EquationType, NodeRelationType, NodeType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionTwoCircleEquations,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  getLineFromTwoPoints,\r\n  calculateInCircleEquation,\r\n  calculateCircumCircleEquation,\r\n  getAngleFromTwoLines,\r\n  calculateMiddlePoint,\r\n  calculateSymmetricalPoint,\r\n  calculateEscribedCirclesEquation\r\n} from '../math/Math2D';\r\nimport { getRandomValue } from '../math/Generation';\r\nimport { mappingShapeType, shapeRules, TwoStaticPointRequireShape, circleType } from '../definition/define';\r\nimport { generateGeometry } from '../math/GenerateGeometry';\r\nimport { readRelation } from './ReadRelation';\r\nimport ErrorService from '../../utils/ErrorHandleService.js';\r\nimport appData from '../../Model/AppData.js';\r\n\r\nlet shape, shapeName, shapeType;\r\n\r\nexport function readPointsMap(): Array | {} {\r\n  dataViewModel.createPointDetails();\r\n  console.table(dataViewModel.getData.getPointsMap);\r\n\r\n  while (!dataViewModel.isPointsMapStatic()) {\r\n    //get node to calculate\r\n    const executingNode = dataViewModel.getNextExecuteNode();\r\n    if (!executingNode) break;\r\n    console.log(executingNode.id);\r\n\r\n    executeRelations(executingNode);\r\n\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(executingNode.id)) {\r\n      const roots = dataViewModel.getData.getPointDetails.get(executingNode.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(executingNode.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[executingNode.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(executingNode.id, coordinate);\r\n      }\r\n    }\r\n\r\n    //update static Node\r\n    dataViewModel.updateStaticNode();\r\n\r\n    if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n      makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], executingNode.id);\r\n    }\r\n  }\r\n\r\n  dataViewModel.getData.getPointsMap.forEach((node: NodeType) => {\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(node.id)) {\r\n      console.log(dataViewModel.getData.getPointDetails.get(node.id));\r\n      const roots = dataViewModel.getData.getPointDetails.get(node.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(node.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[node.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n        dataViewModel.updateCoordinate(node.id, coordinate);\r\n      }\r\n    }\r\n  });\r\n\r\n  return dataViewModel.getData.getPointsMap.map((node) => ({\r\n    id: node.id,\r\n    coordinate: node.coordinate\r\n  }));\r\n}\r\n\r\nfunction executeRelations(node: NodeType) {\r\n  const executingNodeRelations = _makeUniqueNodeRelation(node.dependentNodes);\r\n\r\n  executingNodeRelations.forEach((relation) => {\r\n    let relationEquation;\r\n    if (relation.outputType === 'shape') {\r\n      shapeName = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n      shapeType = mappingShapeType[relation.type] || 'normal';\r\n      shape = relation[shapeName];\r\n      if (circleType.includes(shapeType)) {\r\n        let data = null;\r\n        switch (shapeType) {\r\n          case 'nội tiếp':\r\n            data = calculateInCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'ngoại tiếp':\r\n            data = calculateCircumCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'bàng tiếp':\r\n            data = calculateEscribedCirclesEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(relation.escribedPoint[0]).coordinate\r\n            );\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        if (data) {\r\n          dataViewModel.circlesData[relation.point[0]] = data;\r\n          dataViewModel.updateCoordinate(relation.point[0], data.center);\r\n        } else {\r\n          ErrorService.ErrorMessage('400');\r\n        }\r\n      } else if (!dataViewModel.isExecutedRelation(relation)) {\r\n        generateGeometry(relation[shapeName], shapeName, relation.type);\r\n        setPointsDirection(relation[shapeName]);\r\n      }\r\n      if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n        makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], node.id);\r\n      }\r\n    }\r\n\r\n    if (!dataViewModel.isExecutedRelation(relation)) {\r\n      relationEquation = readRelation(relation, node.id);\r\n      if (relationEquation) {\r\n        if (Array.isArray(relationEquation)) {\r\n          relationEquation = relationEquation[getRandomValue(0, relationEquation.length)];\r\n        }\r\n        dataViewModel.executePointDetails(node.id, relationEquation);\r\n      }\r\n      dataViewModel.getData.getExecutedRelations.push(relation);\r\n    }\r\n  });\r\n  if (dataViewModel.isReCalculated) {\r\n    dataViewModel.isReCalculated = false;\r\n    return;\r\n  }\r\n  dataViewModel.getData.getExecutedNode.push(node.id);\r\n}\r\n\r\nfunction setPointsDirection(shape: string) {\r\n  shape.split('').forEach((point, index) => {\r\n    if (index > 0) {\r\n      const pointCoordinate = dataViewModel.getNodeInPointsMapById(point).coordinate;\r\n      const rootCoordinate = dataViewModel.getNodeInPointsMapById(shape[index - 1]).coordinate;\r\n\r\n      dataViewModel.getData.getPointDirectionMap[point] = {\r\n        root: shape[index - 1],\r\n        isRight: pointCoordinate.x > rootCoordinate.x,\r\n        isUp: pointCoordinate.y < rootCoordinate.y\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\nexport function _makeUniqueNodeRelation(dependentNodes: Array<NodeRelationType>): Array<any> {\r\n  let result: Array<NodeRelationType> = [];\r\n\r\n  for (let index = 0; index < dependentNodes.length; index++) {\r\n    let temp = true;\r\n\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (dependentNodes[index].relation === result[i]) {\r\n        temp = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (temp) result.push(dependentNodes[index].relation);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction makeCorrectShape(shape: string, shapeName: string, rules: string, executePoint: string) {\r\n  const staticPointCountRequire = TwoStaticPointRequireShape.includes(shapeName) ? 2 : 1;\r\n  let staticPoints = shape.replace(executePoint, '').split('');\r\n  // check other points are static\r\n  let count = 0;\r\n  for (let i = 0; i < staticPoints.length; i++) {\r\n    if (dataViewModel.isStaticNodeById(staticPoints[i])) {\r\n      count++;\r\n    }\r\n  }\r\n\r\n  if (count < staticPointCountRequire) {\r\n    return;\r\n  }\r\n\r\n  // get node information\r\n  let arrayRules = rules.split(new RegExp('&', 'g'));\r\n\r\n  const executePointIndex = shape.indexOf(executePoint);\r\n  let nodeSetEquations = [];\r\n  if (arrayRules.length > 0) {\r\n    arrayRules.forEach((rule) => {\r\n      const relationType = rule[2];\r\n      if (rule.includes(executePointIndex)) {\r\n        let equation;\r\n        // eslint-disable-next-line default-case\r\n        switch (relationType) {\r\n          case '|':\r\n            equation = getLinearEquationByParallelRule(rule, shape, executePointIndex);\r\n            break;\r\n          case '^':\r\n            if (rule[1] === rule[3]) {\r\n              equation = getLinearEquationByPerpendicularRule(rule, shape, executePointIndex);\r\n            } else {\r\n              updateCoordinateBySpecialPerpendicularRule(rule, shape, executePointIndex);\r\n            }\r\n            break;\r\n          case '=':\r\n            equation = getLinearEquationsByEqualRule(rule, shape, executePointIndex);\r\n            break;\r\n        }\r\n        if (equation) {\r\n          nodeSetEquations = nodeSetEquations.concat(equation);\r\n        }\r\n      }\r\n    });\r\n    if (executePoint === 'C') console.log(nodeSetEquations);\r\n    nodeSetEquations.forEach((equation) => {\r\n      dataViewModel.executePointDetails(executePoint, equation);\r\n    });\r\n  }\r\n}\r\n\r\nfunction updateCoordinateBySpecialPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  let includeLine, nonIncludeLine;\r\n\r\n  const staticLines = rule\r\n    .split('^')\r\n    .filter(\r\n      (line: string): boolean =>\r\n        dataViewModel.isStaticNodeById(shape[line[0]]) && dataViewModel.isStaticNodeById(shape[line[1]])\r\n    );\r\n\r\n  rule.split('^').forEach((line: string) => {\r\n    if (line.includes(executePointIndex)) {\r\n      includeLine = line;\r\n    } else {\r\n      nonIncludeLine = line;\r\n    }\r\n  });\r\n\r\n  const shapePoints = shape\r\n    .split('')\r\n    .map((point: string): CoordinateType => dataViewModel.getNodeInPointsMapById(point).coordinate);\r\n\r\n  if (staticLines.length === 1) {\r\n    const intersectPoint = calculateMiddlePoint(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]]);\r\n    const nonStaticLine = staticLines[0] === nonIncludeLine ? includeLine : nonIncludeLine;\r\n\r\n    const staticPointIndex = nonStaticLine.split('').filter((pointIndex: string): boolean => {\r\n      return dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n    if (staticPointIndex === undefined) {\r\n      const coordinate = calculateIntersectionByLineAndLine(\r\n        calculatePerpendicularLineByPointAndLine(\r\n          intersectPoint,\r\n          getLineFromTwoPoints(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]])\r\n        ),\r\n        getLineFromTwoPoints(shapePoints[staticLines[0][0]], shapePoints[nonStaticLine[0]])\r\n      );\r\n\r\n      dataViewModel.updateCoordinate(shape[nonStaticLine[0]], coordinate);\r\n    } else if (shape[nonStaticLine.replace(staticPointIndex, '')]) {\r\n      const calculatedCoordinate = calculateSymmetricalPoint(shapePoints[staticPointIndex], intersectPoint);\r\n\r\n      dataViewModel.updateCoordinate(shape[nonStaticLine.replace(staticPointIndex, '')], calculatedCoordinate);\r\n    }\r\n  } else if (staticLines.length === 0) {\r\n    //line perpendicular with line include 1 static point\r\n    const intersectPoint = calculateIntersectionByLineAndLine(\r\n      calculatePerpendicularLineByPointAndLine(\r\n        shapePoints[executePointIndex],\r\n        getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n      ),\r\n      getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n    );\r\n    let calculatedCoordinate;\r\n    //update coordinate\r\n    const otherPointInIncludeLine = includeLine.replace(executePointIndex, '');\r\n    if (!dataViewModel.isStaticNodeById(shape[otherPointInIncludeLine])) {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[executePointIndex], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[otherPointInIncludeLine], calculatedCoordinate);\r\n    } else {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[otherPointInIncludeLine], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[executePointIndex], calculatedCoordinate);\r\n    }\r\n    const nonStaticPointIndex = nonIncludeLine.split('').filter((pointIndex: string): boolean => {\r\n      return !dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n\r\n    calculatedCoordinate = calculateSymmetricalPoint(\r\n      shapePoints[nonIncludeLine.replace(nonStaticPointIndex, '')],\r\n      intersectPoint\r\n    );\r\n\r\n    dataViewModel.updateCoordinate(shape[nonStaticPointIndex], calculatedCoordinate);\r\n  }\r\n}\r\n\r\nfunction getLinearEquationsByEqualRule(rule: string, shape: string, executePointIndex: number): Array<EquationType> {\r\n  const lines = rule.split('=');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  console.log(staticLine, nonStaticLine);\r\n  if (staticLine) {\r\n    const count = staticLine.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n\r\n    if (count < 2) {\r\n      return [];\r\n    }\r\n\r\n    const otherPoint = shape[nonStaticLine.replace(executePointIndex, '')];\r\n\r\n    const radius = calculateDistanceTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n    );\r\n\r\n    //point is outside static line\r\n    if (staticLine.includes(nonStaticLine.replace(executePointIndex, ''))) {\r\n      return [\r\n        calculateCircleEquationByCenterPoint(dataViewModel.getNodeInPointsMapById(otherPoint).coordinate, radius)\r\n      ];\r\n    }\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByParallelRule(rule: string, shape: string, executePointIndex: number): EquationType {\r\n  const lines = rule.split('|');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  if (\r\n    staticLine &&\r\n    nonStaticLine.includes(executePointIndex) &&\r\n    dataViewModel.isStaticNodeById(shape[nonStaticLine.replace(executePointIndex, '')])\r\n  ) {\r\n    return [\r\n      calculateParallelLineByPointAndLine(\r\n        //point\r\n        dataViewModel.getNodeInPointsMapById(shape[nonStaticLine.replace(executePointIndex, '')]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  const lines = rule.split('^');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n\r\n  if (staticLine && nonStaticLine.includes(executePointIndex) && !staticLine.includes(executePointIndex)) {\r\n    return [\r\n      calculatePerpendicularLineByPointAndLine(\r\n        //Common point\r\n        dataViewModel.getNodeInPointsMapById(shape[rule[1]]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n","import type { CoordinateType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateInternalBisectLineEquation,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionEquationTypeWithCircleEquation,\r\n  calculateLinesByAnotherLineAndAngle,\r\n  calculateMiddlePoint,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  calculateSymmetricalPoint,\r\n  getAngleFromTwoLines,\r\n  getLineFromTwoPoints,\r\n  getMiddlePointFromThreePointsInALine,\r\n  isIn,\r\n  calculateIntersectionTwoCircleEquations,\r\n  isVectorInSameLine,\r\n  isVectorSameDirection,\r\n  calculateExternalBisectLineEquation,\r\n  calculateVector,\r\n  calculateTangentEquation,\r\n  calculateTangentIntersectPointsByPointOutsideCircle\r\n} from '../math/Math2D';\r\nimport {\r\n  generatePointAlignmentInside,\r\n  generatePointAlignmentOutside,\r\n  generatePointMiddleTwoPoints,\r\n  getRandomPointInEquation,\r\n  getRandomValue\r\n} from '../math/Generation.js';\r\nimport ErrorService from '../../utils/ErrorHandleService';\r\nimport { ShapeAffectBySegmentChange, TwoStaticPointRequireShape } from '../definition/define';\r\n\r\nexport function readRelation(relation: mixed, point: string) {\r\n  let equationResults;\r\n\r\n  dataViewModel.executingRelation = relation;\r\n  if (relation.operation) {\r\n    equationResults = analyzeOperationType(relation, point);\r\n  } else if (relation.relation) {\r\n    const relationType = relation.relation;\r\n    switch (relationType) {\r\n      case 'trung điểm':\r\n      case 'thuộc':\r\n      case 'không thuộc':\r\n      case 'song song':\r\n      case 'vuông góc':\r\n      case 'phân giác':\r\n      case 'phân giác ngoài':\r\n      case 'phân giác trong':\r\n      case 'thẳng hàng':\r\n        equationResults = analyzeRelationType(relation, point);\r\n        break;\r\n      case 'cắt':\r\n        equationResults = analyzeIntersectRelation(relation, point);\r\n        break;\r\n      case 'tiếp tuyến':\r\n        equationResults = analyzeTangentRelation(relation, point);\r\n        break;\r\n      default:\r\n        equationResults = null;\r\n    }\r\n  } else if (relation.outputType === 'shape') {\r\n    const shapeType = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n    switch (shapeType) {\r\n      case 'triangle':\r\n        equationResults = getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate\r\n        );\r\n        break;\r\n      case 'quadrilateral':\r\n      case 'rectangle':\r\n      case 'square':\r\n      case 'rhombus':\r\n      case 'trapezoid':\r\n      case 'parallelogram':\r\n        if (shapeType !== 'quadrilateral') {\r\n          let count = 0;\r\n          relation[shapeType].split('').forEach((point) => {\r\n            if (dataViewModel.isStaticNodeById(point)) {\r\n              count++;\r\n            }\r\n          });\r\n          const limit = TwoStaticPointRequireShape.includes(shapeType) ? 1 : 2;\r\n          if (count > limit) {\r\n            return;\r\n          }\r\n        }\r\n        let index = relation[shapeType].indexOf(point);\r\n        if (index === relation[shapeType].length - 1) {\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate\r\n          );\r\n        } else {\r\n          index = index === 0 ? relation[shapeType].length - 1 : index - 1;\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(point).coordinate\r\n          );\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  //TODO\r\n  if (equationResults) {\r\n    if (equationResults.coefficientX !== undefined) {\r\n      // equationResults is linear\r\n      return {\r\n        a: 0,\r\n        b: 0,\r\n        c: equationResults.coefficientX,\r\n        d: equationResults.coefficientY,\r\n        e: equationResults.constantTerm\r\n      };\r\n    } else {\r\n      // equationResults is circle\r\n      return equationResults;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction analyzeRelationType(relation: mixed, point: string): LinearEquation {\r\n  let segmentIncludePoint, segmentNotIncludePoint;\r\n  if (relation.segment) {\r\n    relation.segment.forEach((segment: string) => {\r\n      if (segment.includes(point)) {\r\n        segmentIncludePoint = segment;\r\n      } else {\r\n        segmentNotIncludePoint = segment;\r\n      }\r\n    });\r\n  }\r\n\r\n  //points = [...new Set(points)].filter((point: string): boolean => !nonStaticPoints.includes(point));\r\n  const relationType = relation.relation;\r\n\r\n  if (\r\n    relationType === 'trung điểm' ||\r\n    relationType === 'thuộc' ||\r\n    relationType === 'không thuộc' ||\r\n    relationType === 'thẳng hàng'\r\n  ) {\r\n    let calculatedPoint;\r\n    if (relation.circle) {\r\n      calculatedPoint = getRandomPointInEquation(dataViewModel.getCircleEquation(relation.circle[0]));\r\n      dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n      return dataViewModel.getCircleEquation(relation.circle[0]);\r\n    }\r\n    if (segmentIncludePoint) {\r\n      const otherStaticPoint = relation.point[0];\r\n      const otherStaticNodeInSegment = dataViewModel.getNodeInPointsMapById(segmentIncludePoint.replace(point, ''));\r\n\r\n      if (!otherStaticNodeInSegment.coordinate.x && !otherStaticNodeInSegment.coordinate.y) {\r\n        return null;\r\n      }\r\n\r\n      if (relationType === 'trung điểm') {\r\n        calculatedPoint = calculateSymmetricalPoint(\r\n          otherStaticNodeInSegment.coordinate,\r\n          dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n          segmentIncludePoint.indexOf(point) === 1\r\n        );\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n    } else if (segmentNotIncludePoint) {\r\n      switch (relationType) {\r\n        case 'trung điểm':\r\n          calculatedPoint = calculateMiddlePoint(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'thuộc':\r\n          calculatedPoint = generatePointAlignmentInside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'không thuộc':\r\n          calculatedPoint = generatePointAlignmentOutside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate,\r\n            getRandomValue(0, 2) === 1\r\n          );\r\n\r\n          dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else {\r\n      const points = relation.point;\r\n      const index = points.indexOf(point);\r\n      if (index === 1) {\r\n        calculatedPoint = generatePointAlignmentInside(\r\n          dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[2]).coordinate\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedPoint = generatePointAlignmentOutside(\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 0 : 1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 1 : 2]).coordinate,\r\n          index === 2\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(points[1]).coordinate\r\n      );\r\n    }\r\n\r\n    return getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n  } else if (relationType === 'song song' || relationType === 'vuông góc') {\r\n    if (!segmentNotIncludePoint) {\r\n      return;\r\n    }\r\n    const otherStaticPoint = segmentIncludePoint.replace(point, '');\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint) && !dataViewModel.isValidCoordinate(point)) {\r\n      const point = generatePointMiddleTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n      );\r\n      if (point) {\r\n        dataViewModel.updateCoordinate(otherStaticPoint, point);\r\n      }\r\n    }\r\n    //undefined point\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(segmentNotIncludePoint[i])) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const staticLineEquation = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n    );\r\n\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint)) {\r\n      return;\r\n    }\r\n\r\n    let calculatedLineEquation;\r\n    if (relationType === 'vuông góc') {\r\n      calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const isInStaticLine = isIn(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n      const calculatedPoint = isInStaticLine\r\n        ? getRandomPointInEquation(calculatedLineEquation)\r\n        : calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n\r\n      if (!isInStaticLine) {\r\n        dataViewModel.getData.pushAdditionSegment(`${point}${segmentNotIncludePoint[1]}`);\r\n        dataViewModel.getData.pushAdditionSegment(`${point}${segmentNotIncludePoint[0]}`);\r\n      }\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    if (relationType === 'song song') {\r\n      calculatedLineEquation = calculateParallelLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    return calculatedLineEquation;\r\n  } else if (relationType.includes('phân giác')) {\r\n    const isExternal = relationType === 'phân giác ngoài';\r\n\r\n    if (relation.angle) {\r\n      const angle = relation.angle[0];\r\n      if (angle.includes(point)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n      );\r\n      let calculatedLineEquation;\r\n      if (isExternal) {\r\n        calculatedLineEquation = calculateExternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedLineEquation = calculateInternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return calculatedLineEquation;\r\n    }\r\n  }\r\n}\r\n\r\nfunction analyzeIntersectRelation(relation: mixed, point: string): CoordinateType {\r\n  for (let index in relation.segment) {\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(relation.segment[index][i])) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if (relation.segment && relation.segment.length === 2) {\r\n    const calculatedLineEquationOne = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n    const calculatedLineEquationTwo = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][1]).coordinate\r\n    );\r\n\r\n    relation.segment.forEach((segment: string) => {\r\n      dataViewModel.getData.pushAdditionSegment(`${relation.point[0]}${segment[0]}`);\r\n      dataViewModel.getData.pushAdditionSegment(`${relation.point[0]}${segment[1]}`);\r\n    });\r\n\r\n    const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquationOne, calculatedLineEquationTwo);\r\n\r\n    dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n  } else if (relation.circle && relation.circle.length === 2) {\r\n    const roots = calculateIntersectionTwoCircleEquations(\r\n      dataViewModel.getCircleEquation(relation.circle[0]),\r\n      dataViewModel.getCircleEquation(relation.circle[1])\r\n    );\r\n\r\n    roots.forEach((root: CoordinateType, index: number) => {\r\n      if (relation.point[index]) {\r\n        dataViewModel.updateCoordinate(relation.point[index], root);\r\n      }\r\n    });\r\n  } else {\r\n    const pointOne = dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate;\r\n    const pointTwo = dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate;\r\n    let roots = calculateIntersectionTwoCircleEquations(\r\n      getLineFromTwoPoints(pointOne, pointTwo),\r\n      dataViewModel.getCircleEquation(relation.circle[0])\r\n    );\r\n\r\n    roots = roots.filter(\r\n      (root: CoordinateType): boolean =>\r\n        JSON.stringify(root) !== JSON.stringify(pointOne) && JSON.stringify(root) !== JSON.stringify(pointTwo)\r\n    );\r\n    if (relation.point.length === 2) {\r\n      roots.forEach((root: CoordinateType, index: number) => {\r\n        if (!relation.point[index]) {\r\n          ErrorService.showError('200');\r\n        } else {\r\n          dataViewModel.updateCoordinate(relation.point[index], root);\r\n        }\r\n      });\r\n    } else {\r\n      dataViewModel.updateCoordinate(relation.point[0], roots[getRandomValue(0, roots.length - 1)]);\r\n    }\r\n  }\r\n}\r\n\r\n//chỉ xử lý : = , *\r\nfunction analyzeOperationType(relation: mixed, point: string): any {\r\n  const objectType = relation.segment ? 'segment' : 'angle';\r\n  const valueData = {};\r\n\r\n  const objectsIncludePoint = [];\r\n\r\n  for (let index in relation[objectType]) {\r\n    const object = relation[objectType][index];\r\n    if (object.includes(point)) {\r\n      objectsIncludePoint.push(object);\r\n    }\r\n\r\n    valueData[object] =\r\n      objectType === 'segment'\r\n        ? calculateDistanceTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n          )\r\n        : getAngleFromTwoLines(\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n            ),\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[2]).coordinate\r\n            )\r\n          );\r\n  }\r\n\r\n  //điểm cần tính phụ thuộc 1 điểm duy nhất\r\n  if (objectsIncludePoint.length === 1) {\r\n    const index = relation[objectType].indexOf(objectsIncludePoint[0]);\r\n    const staticObject = relation[objectType][index === 0 ? 1 : 0];\r\n    let staticValue;\r\n    if (relation[objectType].length > 1) {\r\n      staticValue = index === 0 ? relation.value * valueData[staticObject] : valueData[staticObject] / relation.value;\r\n    } else {\r\n      staticValue = relation.value[0];\r\n    }\r\n\r\n    if (objectType === 'segment') {\r\n      return calculateCircleEquationByCenterPoint(\r\n        dataViewModel.getNodeInPointsMapById(objectsIncludePoint[0].replace(point, '')).coordinate,\r\n        staticValue\r\n      );\r\n    }\r\n\r\n    return calculateLineEquationByAngleRelation(objectsIncludePoint[0], staticValue);\r\n  }\r\n  if (objectsIncludePoint.length === 2) {\r\n    if (objectType === 'segment') {\r\n      const staticPointOne = objectsIncludePoint[0].replace(point, '');\r\n      const staticPointTwo = objectsIncludePoint[1].replace(point, '');\r\n      //cần check thêm loại shape\r\n      if (!dataViewModel.isStaticNodeById(staticPointOne) || !dataViewModel.isStaticNodeById(staticPointTwo)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const staticDistance = calculateDistanceTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const isAlign = isIn(dataViewModel.getNodeInPointsMapById(point).coordinate, {\r\n        a: 0,\r\n        b: 0,\r\n        c: staticLineEquation.coefficientX,\r\n        d: staticLineEquation.coefficientY,\r\n        e: staticLineEquation.constantTerm\r\n      });\r\n\r\n      const ratio = +relation.value[0];\r\n      if (isAlign) {\r\n        let calculatedPoint;\r\n        const betweenPoint = getMiddlePointFromThreePointsInALine(\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n        );\r\n\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(point).coordinate) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio + 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === p) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate && ratio < 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (1 - ratio)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate && ratio > 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio - 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n\r\n        return staticLineEquation;\r\n      } else {\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateLineEquationByAngleRelation(angleName: string, angleValue: number): EquationType {\r\n  const checkResult = checkAndModifiedAngle(angleName);\r\n  const modifiedAngleName = checkResult.angle;\r\n  const staticPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[0]).coordinate;\r\n  const rootPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[1]).coordinate;\r\n  const changedPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[2]).coordinate;\r\n  const calculatedEquation = calculateLinesByAnotherLineAndAngle(rootPoint, staticPoint, changedPoint, angleValue);\r\n\r\n  const intersectPoint = calculateIntersectionByLineAndLine(\r\n    calculatedEquation,\r\n    getLineFromTwoPoints(staticPoint, rootPoint)\r\n  );\r\n  const newRootPoint = calculateIntersectionTwoCircleEquations(\r\n    calculatedEquation,\r\n    calculateCircleEquationByCenterPoint(changedPoint, calculateDistanceTwoPoints(changedPoint, rootPoint))\r\n  ).sort((rootOne: CoordinateType, rootTwo: CoordinateType): number => {\r\n    return calculateDistanceTwoPoints(intersectPoint, rootOne) - calculateDistanceTwoPoints(intersectPoint, rootTwo);\r\n  })[0];\r\n\r\n  //move newRoot to oldRoot\r\n  const transitionVector = calculateVector(newRootPoint, rootPoint, false);\r\n  if (checkResult.isChanged === false) {\r\n    dataViewModel.updateCoordinate(modifiedAngleName[2], {\r\n      x: changedPoint.x + transitionVector.x,\r\n      y: changedPoint.y + transitionVector.y\r\n    });\r\n\r\n    dataViewModel.replaceSetOfEquation(\r\n      modifiedAngleName[2],\r\n      getLineFromTwoPoints(rootPoint, changedPoint),\r\n      calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  dataViewModel.updateCoordinate(modifiedAngleName[0], {\r\n    x: staticPoint.x - transitionVector.x,\r\n    y: staticPoint.y - transitionVector.y\r\n  });\r\n\r\n  dataViewModel.replaceSetOfEquation(\r\n    modifiedAngleName[1],\r\n    getLineFromTwoPoints(rootPoint, changedPoint),\r\n    calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n  );\r\n\r\n  return null;\r\n}\r\n\r\nfunction reExecuteNode(array: Array<string>) {\r\n  console.log(`----------------`)\r\n  dataViewModel.reExecuteNode(array);\r\n}\r\n\r\nfunction getShapeAffectList(): Array<string> {\r\n  const shapeList = [];\r\n\r\n  //get list of shape name\r\n  dataViewModel.getData.relationsResult.shapes.forEach((shapeData: Object): boolean => {\r\n    const shapeType = Object.keys(shapeData).filter((key: string): boolean => key !== 'outputType')[0];\r\n    if (ShapeAffectBySegmentChange.includes(shapeType)) {\r\n      shapeList.push(shapeData[shapeType]);\r\n    }\r\n  });\r\n\r\n  return shapeList;\r\n}\r\n\r\nfunction checkAndModifiedAngle(angle: string): { angle: string, isChanged: boolean } {\r\n  const shapeList = getShapeAffectList();\r\n\r\n  const secondLine = `${angle[1]}${angle[2]}`;\r\n\r\n  for (let i = 0; i < shapeList.length; i++) {\r\n    const shape = shapeList[i];\r\n    const secondLineVector = calculateVector(\r\n      dataViewModel.getNodeInPointsMapById(secondLine[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(secondLine[1]).coordinate\r\n    );\r\n\r\n    let modifiedAngleName = angle;\r\n    let updatePoint = modifiedAngleName[2];\r\n\r\n    if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\r\n        ),\r\n        secondLineVector\r\n      ) ||\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      modifiedAngleName = angle\r\n        .split('')\r\n        .reverse()\r\n        .join('');\r\n    }\r\n\r\n    let isChanged = modifiedAngleName !== angle;\r\n\r\n    if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      if (angle[1] === shape[0]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[2];\r\n          isChanged = false;\r\n        }\r\n      } else if (angle[1] === shape[2]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[0];\r\n          isChanged = false;\r\n\r\n        }\r\n      }\r\n    } else if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[3]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      if (angle[1] === shape[1]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[3]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[3];\r\n          isChanged = false;\r\n\r\n        }\r\n      } else if (angle[1] === shape[3]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[3]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[1];\r\n          isChanged = false;\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n    reExecuteNode([modifiedAngleName[1], updatePoint]);\r\n    const result = modifiedAngleName.replace(modifiedAngleName[2], updatePoint);\r\n\r\n    return { angle: result, isChanged };\r\n  }\r\n  return { angle, isChanged: false };\r\n}\r\n\r\nfunction analyzeTangentRelation(relation: mixed, point: string): any {\r\n  const otherPointInSegment = relation.segment[0].replace(point, '');\r\n  if (!dataViewModel.isStaticNodeById(otherPointInSegment)) {\r\n    return;\r\n  }\r\n\r\n  const tangentPointCoordinate = dataViewModel.getNodeInPointsMapById(otherPointInSegment).coordinate;\r\n  const circleEquation = dataViewModel.getCircleEquation(relation.circle[0]);\r\n  let tangentEquation;\r\n  if (isIn(tangentPointCoordinate, circleEquation)) {\r\n    tangentEquation = calculateTangentEquation(circleEquation, tangentPointCoordinate);\r\n    dataViewModel.updateCoordinate(point, getRandomPointInEquation(tangentEquation));\r\n  } else {\r\n    const roots = calculateTangentIntersectPointsByPointOutsideCircle(circleEquation, tangentPointCoordinate);\r\n    const result = filterTangentPoint(roots, circleEquation);\r\n    tangentEquation = result.tangentEquation;\r\n    dataViewModel.updateCoordinate(point, result.point);\r\n  }\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nfunction filterTangentPoint(\r\n  roots: Array<CoordinateType>,\r\n  circleEquation: EquationType\r\n): { equation: EquationType, point: CoordinateType } {\r\n  const filterRoots = roots.filter((root: CoordinateType): boolean => !dataViewModel.isCoordinateDuplicated(root));\r\n\r\n  return filterRoots.map((root: CoordinateType): { equation: EquationType, point: CoordinateType } => {\r\n    return {\r\n      equation: calculateTangentEquation(circleEquation, root),\r\n      point: root\r\n    };\r\n  })[getRandomValue(0, filterRoots.length - 1)];\r\n}\r\n","// @flow\r\n\r\nimport { objectWithPoint } from '../definition/define.js';\r\nimport type { DrawingDataType, NodeRelationType, NodeType } from '../../utils/types.js';\r\nimport dataViewModel from '../../ViewModel/DataViewModel';\r\nimport { readPointsMap } from './ReadPointsMap';\r\nimport { makeRoundCoordinate } from '../math/Math2D.js';\r\n\r\nlet RelationPointsMap: Array<NodeType> = [];\r\n\r\nexport function analyzeResult(validatedResult): DrawingDataType {\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    createPointsMapByShape(shape);\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n  relations.forEach((relation) => {\r\n    createPointsMapByRelation(relation).forEach((node) => {\r\n      updateMap(node, dataViewModel.getData.getPointsMap);\r\n    });\r\n  });\r\n\r\n  trimPointsMap();\r\n\r\n  let result = {};\r\n\r\n  readPointsMap();\r\n  result.points = dataViewModel.getData.getPointsMap.map((node: NodeType) => ({\r\n    id: node.id,\r\n    coordinate: makeRoundCoordinate(node.coordinate, 3)\r\n  }));\r\n\r\n  result.segments = [...getArraySegments(validatedResult), ...dataViewModel.getData.getAdditionSegment];\r\n  return result;\r\n}\r\n\r\nfunction getArraySegments(validatedResult): Array<string> {\r\n  let result: Array<string> = [];\r\n\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    result = result.concat(getShapeSegments(shape));\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n\r\n  relations.forEach((relation) => {\r\n    if (relation.segment) {\r\n      result = result.concat(relation.segment);\r\n    }\r\n  });\r\n\r\n  return result.filter((item, index, array) => array.indexOf(item) === index);\r\n}\r\n\r\nfunction getShapeSegments(shape: any): Array<string> {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  const result = [];\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    if (i === points.length - 1) {\r\n      result.push(points[0] + points[i]);\r\n    } else {\r\n      result.push(points[i] + points[i + 1]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction trimPointsMap() {\r\n  dataViewModel.getData.setPointsMap = dataViewModel.getData.getPointsMap.map((node: NodeType): NodeType => ({\r\n    ...node,\r\n    dependentNodes: unique(node.dependentNodes)\r\n  }));\r\n}\r\n\r\nfunction unique(dependentNodes: Array<NodeRelationType>): Array<NodeRelationType> {\r\n  let result = [];\r\n\r\n  dependentNodes.forEach((node) => {\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (JSON.stringify(node) === JSON.stringify(result[i])) return;\r\n    }\r\n    result.push(node);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction sortPriority(points) {\r\n  return points.sort((el1: string, el2: string): number => {\r\n    const index1 = findIndexByNodeId(el1, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(el2, dataViewModel.getData.getPointsMap);\r\n\r\n    if (index1 === -1 && index2 === -1) {\r\n      return 1;\r\n    }\r\n    if (index1 >= 0 && index2 >= 0) return 1;\r\n    return index2 - index1;\r\n  });\r\n}\r\n\r\nfunction createPointsMapByShape(shape: any) {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  points = sortPriority([...points]);\r\n\r\n  if (dataViewModel.getData.getPointsMap.length === 0) {\r\n    const shouldStaticPoint = getFirstStaticPointInShape(shape[shapeName]);\r\n    points = [shouldStaticPoint].concat(points.filter((point) => point !== shouldStaticPoint));\r\n  }\r\n\r\n  let objectPointsMap;\r\n  // đường tròn ngoại tiếp, nội tiếp\r\n  if (shape.point) {\r\n    objectPointsMap = points.map((point: string) => {\r\n      return createNode(shape.point[0], [{ id: point, relation: shape }]);\r\n    });\r\n  } else {\r\n    objectPointsMap = points.map((point: string, index: number) => {\r\n      return createNode(point, [{ id: points[0], relation: shape }]);\r\n    });\r\n  }\r\n  objectPointsMap.forEach((node: NodeType) => {\r\n    updateMap(node, dataViewModel.getData.getPointsMap);\r\n  });\r\n}\r\n\r\nfunction getFirstStaticPointInShape(shape: string): string {\r\n  const angles = [];\r\n  if (dataViewModel.getData.getRelationsResult.relations) {\r\n    dataViewModel.getData.getRelationsResult.relations.forEach((relation) => {\r\n      if (!relation.angle || relation.outputType !== 'define') {\r\n        return;\r\n      }\r\n      angles.push(relation.angle[0]);\r\n    });\r\n\r\n    const shapePointCount = {};\r\n\r\n    angles.forEach((angle: string): void => {\r\n      angle.split('').forEach((point, index) => {\r\n        //don't check middle point\r\n        if (index !== 1) {\r\n          if (shapePointCount[point]) {\r\n            shapePointCount[point] += 1;\r\n          } else {\r\n            shapePointCount[point] = 1;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    let minCountPoint = shape[0];\r\n    Object.keys(shapePointCount).forEach((point) => {\r\n      if (shapePointCount[point] < shapePointCount[minCountPoint]) {\r\n        minCountPoint = point;\r\n      }\r\n    });\r\n\r\n    return minCountPoint;\r\n  }\r\n  return shape[0];\r\n}\r\n\r\nfunction createPointsMapByRelation(relation: any) {\r\n  RelationPointsMap = [];\r\n  objectWithPoint.forEach((objectType: string) => {\r\n    if (relation[objectType]) {\r\n      relation[objectType].forEach((object) => {\r\n        let points = object.split('').filter((point) => point === point.toUpperCase());\r\n\r\n        points = sortPriority([...points]);\r\n\r\n        const objectPointsMap = points.map((point: string, index: number) => {\r\n          return index === points.length - 1\r\n            ? createNode(point, createDependentNodeOfObject(objectType, object, points))\r\n            : createNode(point);\r\n        });\r\n\r\n        objectPointsMap.forEach((node: NodeType) => {\r\n          updateMap(node, RelationPointsMap);\r\n        });\r\n      });\r\n    }\r\n  });\r\n\r\n  RelationPointsMap = [...RelationPointsMap].sort((nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const index1 = findIndexByNodeId(nodeOne.id, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(nodeTwo.id, dataViewModel.getData.getPointsMap);\r\n    if (index1 === -1 && index2 === -1) return 1;\r\n    if (index1 >= 0 && index2 >= 0) return index1 - index2;\r\n    return index2 - index1;\r\n  });\r\n\r\n  let lastObjectPoints;\r\n\r\n  if (relation.angle && relation.outputType === 'define' && !!relation.value) {\r\n    const index1 = findIndexByNodeId(relation.angle[0][0], dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(relation.angle[0][2], dataViewModel.getData.getPointsMap);\r\n    lastObjectPoints = [index1 > index2 ? relation.angle[0][0] : relation.angle[0][2]];\r\n  } else {\r\n    lastObjectPoints = getDependentObject();\r\n  }\r\n  if (lastObjectPoints.length === RelationPointsMap.length) {\r\n    lastObjectPoints = [lastObjectPoints[0]];\r\n  }\r\n  if (relation.relation === 'song song' || relation.relation === 'vuông góc' || relation.relation === 'phân giác') {\r\n    lastObjectPoints = lastObjectPoints.filter(\r\n      (point: string): boolean => !dataViewModel.getNodeInPointsMapById(point)\r\n    );\r\n  }\r\n  lastObjectPoints.forEach((point) => {\r\n    const index = findIndexByNodeId(point, RelationPointsMap);\r\n    const currentNode = RelationPointsMap[index];\r\n    RelationPointsMap.forEach((node) => {\r\n      if (node.id !== point) {\r\n        RelationPointsMap[index] = {\r\n          ...currentNode,\r\n          dependentNodes: [\r\n            ...currentNode.dependentNodes,\r\n            ...createDependentNodeOfRelation(node.id, relation, lastObjectPoints)\r\n          ]\r\n        };\r\n      }\r\n    });\r\n  });\r\n\r\n  return RelationPointsMap;\r\n}\r\n\r\nfunction getDependentObject(): Array<string> {\r\n  let result: Array = [];\r\n  const lastNode = RelationPointsMap[RelationPointsMap.length - 1];\r\n  if (lastNode) {\r\n    result.push(lastNode.id);\r\n\r\n    lastNode.dependentNodes.forEach((node) => {\r\n      const nodeIndex = findIndexByNodeId(node.id, dataViewModel.getData.getPointsMap);\r\n      if (!result.includes(node.id) && nodeIndex !== -1 && !dataViewModel.getData.getPointsMap[nodeIndex].isStatic)\r\n        result.push(node.id);\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction findIndexByNodeId(id: string, map: Array<NodeType | NodeRelationType>): number {\r\n  for (let i = 0; i < map.length; i++) {\r\n    if (map[i].id === id) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction createDependentNodeOfRelation(\r\n  point: string,\r\n  relation: any,\r\n  exception: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  RelationPointsMap.forEach((node: NodeType) => {\r\n    if (exception.includes(node.id)) return;\r\n    result.push({ id: node.id, relation });\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction createDependentNodeOfObject(\r\n  objectType: string,\r\n  objectName: string,\r\n  points: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  let relation = null;\r\n\r\n  points.forEach((point: string, index: number) => {\r\n    if (index === points.length - 1 || !relation) return;\r\n    result.push({ id: point, relation });\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction createNode(id: string, dependentNodes?: Array<NodeRelationType>): any {\r\n  const node = { id, coordinate: { x: undefined, y: undefined, z: 0 }, isStatic: false };\r\n  const _dependentNodes = dependentNodes ? { dependentNodes } : { dependentNodes: [] };\r\n\r\n  return { ...node, ..._dependentNodes };\r\n}\r\n\r\nfunction updateMap(node: NodeType, map: Array<NodeType>) {\r\n  const index = findIndexByNodeId(node.id, map);\r\n  if (index !== -1) {\r\n    //merge dependentNodes\r\n    const oldNode = map[index];\r\n    map[index] = {\r\n      ...oldNode,\r\n      dependentNodes: [...oldNode.dependentNodes, ...node.dependentNodes]\r\n    };\r\n  } else {\r\n    map.push(node);\r\n    if (dataViewModel.getData.getPointsMap.length === 1) map[0].isStatic = true;\r\n  }\r\n}\r\n","// @flow\r\nimport { observable } from 'mobx';\r\nimport GConst from '../utils/values';\r\n\r\nexport default class RelationInputModel {\r\n  @observable\r\n  value: string = '';\r\n\r\n  @observable\r\n  status: string = GConst.InputStatus.NORMAL;\r\n\r\n  constructor(value: string) {\r\n    this.value = value;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport appData from '../Model/AppData';\r\nimport type { EquationType, PointDetailsType } from '../utils/types';\r\nimport { NodeType } from '../utils/types';\r\nimport GConst from '../utils/values.js';\r\nimport { calculateIntersectionTwoCircleEquations, isIn, makeRoundCoordinate } from '../core/math/Math2D.js';\r\nimport { isQuadraticEquation } from '../utils/checker.js';\r\nimport { defineSentences } from '../core/definition/define';\r\nimport { defineInformation } from '../core/definition';\r\nimport { analyzeResult } from '../core/analysis/Analysis';\r\nimport RelationInputModel from '../Model/RelationInputModel';\r\nimport { observable, action, computed } from 'mobx';\r\nimport ErrorService from '../utils/ErrorHandleService';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { isTwoEquationEqual } from '../core/math/Math2D';\r\nimport { getRandomValue } from '../core/math/Generation';\r\n\r\nconst NOT_FOUND = GConst.Number.NOT_FOUND;\r\nconst NOT_ENOUGH_SET = GConst.String.NOT_ENOUGH_SET;\r\n\r\nclass DataViewModel {\r\n  @observable\r\n  isReCalculated = false;\r\n\r\n  @observable\r\n  circlesData = {};\r\n\r\n  @observable\r\n  relationsInput: Array<RelationInputModel>;\r\n\r\n  inputData: Array<mixed> = [];\r\n\r\n  executedInputIndex: number;\r\n\r\n  @observable\r\n  executingRelation: mixed;\r\n\r\n  constructor(appData) {\r\n    this.data = appData;\r\n    this.relationsInput = [\r\n      new RelationInputModel()\r\n    ];\r\n  }\r\n\r\n  @computed\r\n  get RelationsInput() {\r\n    return this.relationsInput;\r\n  }\r\n\r\n  @computed\r\n  get isInputEmpty(): boolean {\r\n    if (this.relationsInput.length === 1 && !this.relationsInput[0].value) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @action\r\n  resetInputsStatus() {\r\n    this.relationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.NORMAL;\r\n    });\r\n  }\r\n\r\n  @action\r\n  onInputChange(value: string, index: number) {\r\n    const newRelationInput = { ...this.relationsInput[index] };\r\n    newRelationInput.value = value;\r\n    this.relationsInput[index] = newRelationInput;\r\n    this.resetInputsStatus();\r\n  }\r\n\r\n  @action\r\n  addNewInput() {\r\n    this.relationsInput.push(new RelationInputModel(''));\r\n  }\r\n\r\n  @action\r\n  removeInput(index: number) {\r\n    this.relationsInput.splice(index, 1);\r\n  }\r\n\r\n  clear() {\r\n    this.data.clear();\r\n  }\r\n\r\n  get getData() {\r\n    return this.data;\r\n  }\r\n\r\n  createPointDetails() {\r\n    this.data.getPointsMap.forEach((node) => {\r\n      const roots = this.isValidCoordinate(node.coordinate) ? [node.coordinate] : [];\r\n      this._updatePointDetails(node.id, {\r\n        setOfEquation: [],\r\n        roots: roots,\r\n        exceptedCoordinates: []\r\n      });\r\n    });\r\n  }\r\n\r\n  isNeedRandomCoordinate = (pointId: string): boolean => {\r\n    const roots = this.data.getPointDetails.get(pointId).roots;\r\n    if (roots) {\r\n      for (let i = 0; i < roots.length; i++) {\r\n        if (\r\n          this.data.getPointDirectionMap[pointId] ||\r\n          JSON.stringify(makeRoundCoordinate(roots[i])) ===\r\n            JSON.stringify(makeRoundCoordinate(this.getNodeInPointsMapById(pointId).coordinate))\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  updateCoordinate = (nodeId: string, coordinate: CoordinateType, f: number = 3): void => {\r\n    const index = this.getIndexOfNodeInPointsMapById(nodeId);\r\n    if (!coordinate) {\r\n      ErrorService.showError('200');\r\n    }\r\n\r\n    const _coordinate = {};\r\n    Object.keys(coordinate)\r\n      .sort()\r\n      .forEach((key: string) => {\r\n        _coordinate[key] = coordinate[key];\r\n      });\r\n    if (index !== NOT_FOUND) {\r\n      this.data.getPointsMap[index].coordinate = makeRoundCoordinate(_coordinate, f);\r\n    }\r\n  };\r\n\r\n  isStaticNode = (node: NodeType): boolean => {\r\n    if (node.isStatic) return true;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (!this.isExecutedRelation(node.dependentNodes[i].relation)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return this.data.getExecutedNode.includes(node.id);\r\n  };\r\n\r\n  reExecuteNode = (arrayPoint: Array<string>) => {\r\n    this.isReCalculated = true;\r\n    this.getData.pointsMap.forEach((node: NodeType, index: number) => {\r\n      if (arrayPoint.includes(node.id)) {\r\n        return;\r\n      }\r\n      this.getData.pointsMap[index].dependentNodes.forEach((dependence: NodeRelationType, index: number) => {\r\n        if (dependence.relation.outputType === 'shape' && arrayPoint.length > 0) {\r\n          this.getData.pointsMap[index].dependentNodes[index] = { ...dependence, id: arrayPoint[0] };\r\n        }\r\n      });\r\n      this.getData.pointsMap[index].isStatic = false;\r\n    });\r\n    this.getData.__pointDetails__.clear();\r\n\r\n    this.getData.executedNode = arrayPoint;\r\n    const keepExecutedRelations = this.getData.executedRelations.filter(\r\n      (relation: mixed): boolean => relation.outputType === 'shape'\r\n    );\r\n    this.getData.executedRelations = keepExecutedRelations;\r\n  };\r\n\r\n  isExecutedRelation = (relation: any): boolean => {\r\n    for (let i = 0; i < this.data.getExecutedRelations.length; i++) {\r\n      if (JSON.stringify(relation) === JSON.stringify(this.data.getExecutedRelations[i])) return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  updateStaticNode = () => {\r\n    const pointsMap = this.data.getPointsMap.map((node: NodeType): NodeType => {\r\n      node.isStatic = this.isStaticNode(node);\r\n      return node;\r\n    });\r\n    this.data.setPointsMap = pointsMap;\r\n  };\r\n\r\n  updatePointsMap = (node: NodeType) => {\r\n    let index = this.getIndexOfNodeInPointsMapById(node.id);\r\n    this.data.getPointsMap[index] = node;\r\n  };\r\n\r\n  isPointsMapStatic = (): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (!this.data.getPointsMap[i].isStatic) return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  isValidCoordinate = (nodeId: string) => {\r\n    if (nodeId) {\r\n      const node = this.getNodeInPointsMapById(nodeId);\r\n      if (node) {\r\n        return node.coordinate.x !== undefined && node.coordinate.y !== undefined;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  getNextExecuteNode = (): NodeType => {\r\n    const clonePointsMap = this.data.pointsMap\r\n      .filter((node) => !this.data.executedNode.includes(node.id) && !this.isStaticNode(node))\r\n      .sort(this.sortNodeByPriority);\r\n\r\n    if (clonePointsMap.length > 0) return clonePointsMap[0];\r\n    return null;\r\n  };\r\n\r\n  sortNodeByPriority = (nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const staticNodeOneCount = this.getDependentStaticNodeCount(nodeOne);\r\n    const nodeOneData = {\r\n      static: staticNodeOneCount,\r\n      nonStatic: nodeOne.dependentNodes.length - staticNodeOneCount,\r\n      dependence: nodeOne.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeOne),\r\n      index: this.getIndexOfNodeInPointsMap(nodeOne)\r\n    };\r\n\r\n    const staticNodeTwoCount = this.getDependentStaticNodeCount(nodeTwo);\r\n    const nodeTwoData = {\r\n      static: staticNodeTwoCount,\r\n      nonStatic: nodeTwo.dependentNodes.length - staticNodeTwoCount,\r\n      dependence: nodeTwo.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeTwo),\r\n      index: this.getIndexOfNodeInPointsMap(nodeTwo)\r\n    };\r\n\r\n    //get Max\r\n    const rankingOrderDesc = ['static', 'dependence'];\r\n\r\n    //get Min\r\n    const rankingOrderAsc = ['nonStatic', 'minRelationIndex', 'index'];\r\n\r\n    let rankOne = nodeOneData.static === nodeOneData.dependence ? '1' : '0';\r\n    let rankTwo = nodeTwoData.static === nodeTwoData.dependence ? '1' : '0';\r\n\r\n    rankingOrderDesc.forEach((key) => {\r\n      if (nodeOneData[key] > nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    rankingOrderAsc.forEach((key) => {\r\n      if (nodeOneData[key] < nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    return parseInt(rankTwo) - parseInt(rankOne);\r\n  };\r\n\r\n  getMinIndexOfDependentNodeInRelationsList = (node: NodeType) => {\r\n    const indexArray = [];\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      indexArray.push(this.getIndexOfRelationInRelationsList(node.dependentNodes[i]));\r\n    }\r\n\r\n    return Math.min(...indexArray);\r\n  };\r\n\r\n  getIndexOfRelationInRelationsList = (relation: any): number => {\r\n    const list = this.data.getRelationsResult.shapes.concat(this.data.getRelationsResult.relations);\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (relation === list[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getDependentStaticNodeCount = (node: NodeType): number => {\r\n    let count = 0;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (this.isStaticNodeById(node.dependentNodes[i].id)) count++;\r\n    }\r\n\r\n    return count;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMap = (node): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (node === this.data.getPointsMap[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMapById = (id: string): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getNodeInPointsMapById = (id: string): NodeType | null => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return this.data.getPointsMap[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  isStaticNodeById = (id: string): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) {\r\n        return this.isStaticNode(this.data.getPointsMap[i]);\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  _calculateSet = (equations: Array<EquationType>) => {\r\n    if (equations.length === 2) {\r\n      return calculateIntersectionTwoCircleEquations(equations[0], equations[1]);\r\n    } else return NOT_ENOUGH_SET;\r\n  };\r\n\r\n  replaceSetOfEquation(pointId: string, searchEquation: EquationType, replaceEquation: EquationType) {\r\n    if (!this.data.getPointDetails.has(pointId)) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [],\r\n        roots: [],\r\n        exceptedCoordinates: []\r\n      });\r\n    }\r\n    const pointDetail = this.data.getPointDetails.get(pointId);\r\n    const setOfEquation = pointDetail.setOfEquation;\r\n    let isReplaceComplete = false;\r\n    setOfEquation.forEach((equation: EquationType, index: number) => {\r\n      if (isTwoEquationEqual(equation, searchEquation)) {\r\n        setOfEquation[index] = replaceEquation;\r\n        isReplaceComplete = true;\r\n      }\r\n    });\r\n\r\n    if (!isReplaceComplete) {\r\n      setOfEquation.push(replaceEquation);\r\n    }\r\n    if (setOfEquation.length === 1) {\r\n      return;\r\n    }\r\n    const roots = this._calculateSet(setOfEquation);\r\n\r\n    this.data.getPointDetails.set(pointId, {\r\n      ...pointDetail,\r\n      setOfEquation,\r\n      roots\r\n    });\r\n\r\n    if (roots.length > 0) {\r\n      let coordinate;\r\n      if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n        coordinate = roots[getRandomValue(0, roots.length)];\r\n      } else {\r\n        const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n        const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n        if (roots.length > 1 && typeof roots !== 'string') {\r\n          const rootsDirection = roots.map((root) => ({\r\n            coordinate: root,\r\n            isRight: root.x > staticPointCoordinate.x,\r\n            isUp: root.y < staticPointCoordinate.y\r\n          }));\r\n\r\n          const coordinateMatch = rootsDirection\r\n            .map((directionInfo) => {\r\n              let matchCount = 0;\r\n              if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                matchCount++;\r\n              }\r\n              if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                matchCount++;\r\n              }\r\n              return {\r\n                coordinate: directionInfo.coordinate,\r\n                matchCount\r\n              };\r\n            })\r\n            .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n          coordinate = coordinateMatch.coordinate;\r\n        } else {\r\n          if (typeof roots === 'string') {\r\n            return;\r\n          }\r\n          coordinate = roots[0];\r\n        }\r\n      }\r\n      dataViewModel.updateCoordinate(pointId, coordinate);\r\n    }\r\n  }\r\n\r\n  _updatePointDetails(pointId: string, pointDetails: PointDetailsType) {\r\n    this.data.getPointDetails.set(pointId, {\r\n      setOfEquation: pointDetails.setOfEquation,\r\n      roots: pointDetails.roots,\r\n      exceptedCoordinates: pointDetails.exceptedCoordinates\r\n    });\r\n  }\r\n\r\n  uniqueSetOfEquation(equations: any[]): any[] {\r\n    let result = [];\r\n\r\n    equations.forEach((equation) => {\r\n      for (let i = 0; i < result.length; i++) {\r\n        if (JSON.stringify(equation) === JSON.stringify(result[i])) return;\r\n      }\r\n      result.push(equation);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  executePointDetails(pointId: string, equation: EquationType) {\r\n    let sum = 0;\r\n    Object.keys(equation)\r\n      .map((key: string): number => equation[key])\r\n      .forEach((value: number) => {\r\n        sum += Math.abs(value);\r\n      });\r\n    if (sum === 0) {\r\n      return;\r\n    }\r\n\r\n    let isFirst = false;\r\n    if (!this.data.getPointDetails.has(pointId)) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [],\r\n        roots: [],\r\n        exceptedCoordinates: []\r\n      });\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length <= 1) {\r\n      let newSetOfEquation = [...this.data.getPointDetails.get(pointId).setOfEquation, equation];\r\n      if (newSetOfEquation.length === 2) {\r\n        if (isTwoEquationEqual(newSetOfEquation[0], newSetOfEquation[1])) {\r\n          newSetOfEquation = newSetOfEquation[0];\r\n        }\r\n      }\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: newSetOfEquation,\r\n        roots: this.data.getPointDetails.get(pointId).roots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n      isFirst = true;\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length === 2) {\r\n      if (isQuadraticEquation(equation) && !isFirst) {\r\n        for (let i = 0; i < 2; i++) {\r\n          if (!isQuadraticEquation(this.data.getPointDetails.get(pointId).setOfEquation[i])) {\r\n            this.data.getPointDetails.get(pointId).setOfEquation[i] = equation;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const roots = this._calculateSet(this.data.getPointDetails.get(pointId).setOfEquation);\r\n      const currentRoots = this.data.getPointDetails.get(pointId).roots;\r\n\r\n      const finalRoots = typeof roots === 'string' ? currentRoots : currentRoots.concat(roots);\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: finalRoots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n    }\r\n\r\n    let temp = this.data.getPointDetails.get(pointId).roots;\r\n\r\n    if (typeof temp === 'string') {\r\n      ErrorService.showError('500');\r\n      return;\r\n    }\r\n\r\n    temp = temp.filter((root) => {\r\n      return isIn(root, equation);\r\n    });\r\n\r\n    if (temp.length > 0) {\r\n      // TODO: Add exception\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: temp,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n\r\n      if (temp.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n          coordinate = temp[getRandomValue(0, temp.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (temp.length > 1) {\r\n            const rootsDirection = temp.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = temp[0];\r\n          }\r\n        }\r\n        dataViewModel.updateCoordinate(pointId, coordinate);\r\n      }\r\n    }\r\n  }\r\n\r\n  getInformation(string: string): mixed {\r\n    const _string = '_ '.concat(string.concat(' _'));\r\n    let isMatching = false;\r\n    let preProgress = [];\r\n    Object.keys(defineSentences).forEach((key) => {\r\n      defineSentences[key].forEach((sentence) => {\r\n        sentence = '_ '.concat(sentence.concat(' _'));\r\n\r\n        if (isMatching) return;\r\n        const value = this.getBasicInformation(_string, sentence, key);\r\n        if (Object.keys(value).length > 0) {\r\n          isMatching = true;\r\n          preProgress = value;\r\n          preProgress['outputType'] = key;\r\n        }\r\n      });\r\n    });\r\n    const type = preProgress.outputType;\r\n\r\n    const result = defineInformation(preProgress);\r\n    if (result.Error || !result.outputType) {\r\n      ErrorService.showError('300');\r\n      return;\r\n    }\r\n    if (result.point && result.point.length > 3) {\r\n      ErrorService.showError('301');\r\n      return;\r\n    }\r\n\r\n    // add operation for define type\r\n    if (type === 'define') {\r\n      GConst.Others.OPERATIONS.forEach((operation) => {\r\n        if (result.operation) return;\r\n        if (string.includes(operation)) {\r\n          result.operation = operation;\r\n          if (operation === '=' && !result.value) {\r\n            result.value = '1';\r\n            result.operation = '*';\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getBasicInformation(string, _defineSentence, type) {\r\n    let others = _defineSentence.match(new RegExp(GConst.Regex.OTHER, 'g'));\r\n    let params = _defineSentence.match(new RegExp(GConst.Regex.KEY, 'g'));\r\n\r\n    let result = {};\r\n\r\n    params.forEach((key) => {\r\n      result[key] = [];\r\n    });\r\n\r\n    for (let i = 0; i < params.length; i++) {\r\n      let start =\r\n        others[i]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n      let end =\r\n        others[i + 1]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n\r\n      let param = string.match(new RegExp(start + '(.*)' + end));\r\n\r\n      if (param) result[params[i]].push(param[1]);\r\n\r\n      if (i === others.length - 1) {\r\n        let lastParam = string.match(new RegExp(end + '(.*)'));\r\n        if (lastParam) result[params[i + 1]].push(lastParam[1]);\r\n      }\r\n    }\r\n\r\n    if (this.getLength(result) === params.length) {\r\n      if (type === 'relation') result[type] = others[1].replace('_', '').trim();\r\n      return result;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  getLength(dictionary) {\r\n    let count = 0;\r\n    Object.keys(dictionary).forEach((key) => {\r\n      count += dictionary[key].length;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  getCircleEquation(centerId: string): EquationType {\r\n    return this.circlesData[centerId].equation;\r\n  }\r\n\r\n  getCircleCenterCoordinate(centerId: string): CoordinateType {\r\n    return this.circlesData[centerId].coordinate;\r\n  }\r\n\r\n  isCoordinateDuplicated(coordinate: CoordinateType): boolean {\r\n    const stringifyCoordinate = JSON.stringify(coordinate);\r\n    let result = false;\r\n    this.getData.pointsMap.forEach((node: NodeType) => {\r\n      const key = node.id;\r\n      if (result) {\r\n        return;\r\n      }\r\n      if (JSON.stringify(stringifyCoordinate) === JSON.stringify(this.getNodeInPointsMapById(key).coordinate)) {\r\n        result = true;\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  analyzeInput() {\r\n    this.circlesData = {};\r\n    const data = this.RelationsInput.map((relationsInput: RelationInputModel): string => relationsInput.value)\r\n      // eslint-disable-next-line no-control-getBasicInformation\r\n      .filter((sentence) => !!sentence)\r\n      .map((sentence: string, index: number) => {\r\n        this.executedInputIndex = index;\r\n        const result = this.getInformation(sentence);\r\n        this.relationsInput[index].status = GConst.InputStatus.SUCCESS;\r\n        this.inputData.push(result);\r\n        return result;\r\n      });\r\n\r\n    let result = {\r\n      shapes: [],\r\n      relations: []\r\n    };\r\n    for (let i = 0; i < data.length; i++) {\r\n      let item = data[i];\r\n\r\n      if (item.outputType === 'shape') {\r\n        result.shapes.push(item);\r\n      } else {\r\n        result.relations.push(item);\r\n      }\r\n    }\r\n\r\n    this.data.setRelationsResult = result;\r\n\r\n    this.RelationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.SUCCESS;\r\n    });\r\n    return analyzeResult(result);\r\n  }\r\n}\r\n\r\nconst dataViewModel = new DataViewModel(appData);\r\n\r\nexport default dataViewModel;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport './InputItem.scss';\r\nimport { Icon } from '../index';\r\nimport color from '../../../utils/color.scss';\r\nimport autobind from 'autobind-decorator';\r\ntype PropsType = {\r\n  value: string,\r\n  status: string,\r\n  onValueChange: void,\r\n  onSubmit: void,\r\n  onBackspace: void\r\n};\r\n\r\ntype StateType = {\r\n  shouldRemove: boolean\r\n};\r\n\r\nconst KEYCODE = Object.freeze({\r\n  BACKSPACE: 8,\r\n  ENTER: 13\r\n});\r\n\r\nclass InputItem extends React.Component<PropsType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    this.state = {\r\n      shouldRemove: true,\r\n      isEmpty: true\r\n    };\r\n  }\r\n  inputRef: ReactRefs = React.createRef();\r\n\r\n  focus() {\r\n    if (this.inputRef.current) {\r\n      this.inputRef.current.focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onChange(e: React.FormEvent<HTMLInputElement>) {\r\n    const value = e.currentTarget.value;\r\n    const { onValueChange } = this.props;\r\n\r\n    if (value.length === 0) {\r\n      if (!this.state.isEmpty) {\r\n        this.setState({ isEmpty: true });\r\n      }\r\n    } else {\r\n      this.setState({\r\n        isEmpty: false,\r\n        shouldRemove: false\r\n      });\r\n    }\r\n    if (onValueChange) {\r\n      onValueChange(value);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onKeyUp(e: React.KeyboardEvent<FormControl>) {\r\n    const { onBackspace, onSubmit, value } = this.props;\r\n\r\n    if (e.keyCode === KEYCODE.ENTER) {\r\n      if (onSubmit) {\r\n        onSubmit();\r\n      }\r\n    } else if (e.keyCode === KEYCODE.BACKSPACE) {\r\n      if (this.state.isEmpty && !this.state.shouldRemove) {\r\n        this.setState({\r\n          shouldRemove: true\r\n        });\r\n        return;\r\n      }\r\n      if (onBackspace) {\r\n        onBackspace();\r\n      }\r\n    }\r\n  }\r\n\r\n  render(): React.Node {\r\n    const { status, value } = this.props;\r\n    return (\r\n      <div className=\"input-item\">\r\n        <div className=\"input-group input-container\">\r\n          <div className=\"input-group-prepend input-status\">\r\n            <span className={`input-group-text ${status.toLowerCase()}`} id=\"basic-addon1\">\r\n              <Icon width={15} height={15} name={`input${status}`} color={color[`input${status}`]} />\r\n            </span>\r\n          </div>\r\n          <input\r\n            type=\"text\"\r\n            ref={this.inputRef}\r\n            onChange={this.onChange}\r\n            onKeyUp={this.onKeyUp}\r\n            value={value}\r\n            className={`form-control ${status.toLowerCase()}`}\r\n            aria-describedby=\"basic-addon1\"\r\n          />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default InputItem;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport { inputSuccess, inputError, inputNormal, icInformation, icRemove, icEdit, icAdd } from './Svg';\r\n\r\ntype PropsType = {\r\n  name: string,\r\n  color: string,\r\n  width: number,\r\n  height: number\r\n};\r\n\r\nconst iconList = {\r\n  inputSuccess,\r\n  inputError,\r\n  inputNormal,\r\n  icInformation,\r\n  icRemove,\r\n  icEdit,\r\n  icAdd\r\n};\r\n\r\nexport default class Icon extends React.Component<PropsType> {\r\n  render(): React.Node {\r\n    const { name, width, height, color } = this.props;\r\n    const icon = iconList[name];\r\n    return (\r\n      <svg width={width} height={height} viewBox={icon.viewBox}>\r\n        {icon.svg({ color })}\r\n      </svg>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\n\r\nexport const inputSuccess = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M337.222 22.952c-15.912-8.568-33.66 7.956-44.064 17.748-23.867 23.256-44.063 50.184-66.708 74.664-25.092 26.928-48.348 53.856-74.052 80.173-14.688 14.688-30.6 30.6-40.392 48.96-22.032-21.421-41.004-44.677-65.484-63.648C28.774 167.385-.602 157.593.01 190.029c1.224 42.229 38.556 87.517 66.096 116.28 11.628 12.24 26.928 25.092 44.676 25.704 21.42 1.224 43.452-24.48 56.304-38.556 22.645-24.48 41.005-52.021 61.812-77.112 26.928-33.048 54.468-65.485 80.784-99.145 16.524-20.808 68.544-72.217 27.54-94.248zM26.937 187.581c-.612 0-1.224 0-2.448.611-2.448-.611-4.284-1.224-6.732-2.448 1.836-1.224 4.896-.612 9.18 1.837z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const inputError = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M285.368 234.691L459.36 60.697c13.895-13.88 13.895-36.395 0-50.275-13.881-13.895-36.38-13.895-50.275 0L235.091 184.416 61.082 10.421c-13.866-13.895-36.395-13.895-50.275 0-13.88 13.881-13.88 36.395 0 50.275l174.01 173.995L10.421 409.085c-13.895 13.895-13.895 36.395 0 50.275 6.94 6.955 16.043 10.425 25.145 10.425 9.088 0 18.19-3.47 25.132-10.425L235.09 284.967l173.995 173.995c6.955 6.94 16.043 10.425 25.145 10.425 9.088 0 18.19-3.485 25.131-10.425 13.895-13.88 13.895-36.38 0-50.275L285.367 234.691z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 469.785 469.785'\r\n};\r\n\r\nexport const inputNormal = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M370.59 250.973c-5.524 0-10 4.476-10 10v88.789c-.02 16.562-13.438 29.984-30 30H50c-16.563-.016-29.98-13.438-30-30V89.172c.02-16.559 13.438-29.98 30-30h88.79c5.523 0 10-4.477 10-10 0-5.52-4.477-10-10-10H50c-27.602.031-49.969 22.398-50 50v260.594c.031 27.601 22.398 49.968 50 50h280.59c27.601-.032 49.969-22.399 50-50v-88.793c0-5.524-4.477-10-10-10zm0 0\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M376.629 13.441c-17.574-17.574-46.067-17.574-63.64 0L134.581 191.848a9.997 9.997 0 0 0-2.566 4.402l-23.461 84.7a9.997 9.997 0 0 0 12.304 12.308l84.7-23.465a9.997 9.997 0 0 0 4.402-2.566l178.402-178.41c17.547-17.587 17.547-46.055 0-63.641zM156.37 198.348L302.383 52.332l47.09 47.09-146.016 146.016zm-9.406 18.875l37.62 37.625-52.038 14.418zM374.223 74.676L363.617 85.28l-47.094-47.094 10.61-10.605c9.762-9.762 25.59-9.762 35.351 0l11.739 11.734c9.746 9.774 9.746 25.59 0 35.36zm0 0\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const icInformation = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M194 142.8c.8 1.6 1.6 3.2 2.4 4.4.8 1.2 2 2.4 2.8 3.6 1.2 1.2 2.4 2.4 4 3.6 1.2.8 2.8 2 4.8 2.4 1.6.8 3.2 1.2 5.2 1.6 2 .4 3.6.4 5.2.4s3.6 0 5.2-.4 3.2-.8 4.4-1.6h.4c1.6-.8 3.2-1.6 4.8-2.8 1.2-.8 2.4-2 3.6-3.2l.4-.4c1.2-1.2 2-2.4 2.8-3.6s1.6-2.4 2-4c0-.4 0-.4.4-.8.8-1.6 1.2-3.6 1.6-5.2.4-1.6.4-3.6.4-5.2s0-3.6-.4-5.2-.8-3.2-1.6-5.2c-1.2-2.8-2.8-5.2-4.8-7.2l-.8-.8c-1.2-1.2-2.4-2-4-3.2-1.6-.8-2.8-1.6-4.4-2.4-1.6-.8-3.2-1.2-4.8-1.6-2-.4-3.6-.4-5.2-.4s-3.6 0-5.2.4-3.2.8-4.8 1.6h-.4c-1.6.8-3.2 1.6-4.4 2.4-1.6 1.2-2.8 2-4 3.2-1.2 1.2-2.4 2.4-3.2 3.6-.8 1.2-1.6 2.8-2.4 4.4-.8 1.6-1.2 3.2-1.6 4.8-.4 2-.4 3.6-.4 5.2s0 3.6.4 5.2c.4 3.2 1.2 4.8 1.6 6.4zM249.6 289.2h-9.2v-98c0-5.6-4.4-10.4-10.4-10.4h-42c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h8.4v66.4H188c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h61.6c5.6 0 10.4-4.4 10.4-10.4V300c0-6-4.8-10.8-10.4-10.8z\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M218.8 0C98 0 0 98 0 218.8s98 218.8 218.8 218.8 218.8-98 218.8-218.8S339.6 0 218.8 0zm0 408.8c-104.8 0-190-85.2-190-190s85.2-190 190-190 190 85.2 190 190-85.2 190-190 190z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 437.6 427.6'\r\n};\r\n\r\nexport const icEdit = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M328.883 89.125l107.59 107.589-272.34 272.34L56.604 361.465l272.279-272.34zm189.23-25.948l-47.981-47.981c-18.543-18.543-48.653-18.543-67.259 0l-45.961 45.961 107.59 107.59 53.611-53.611c14.382-14.383 14.382-37.577 0-51.959zM.3 512.69c-1.958 8.812 5.998 16.708 14.811 14.565l119.891-29.069L27.473 390.597.3 512.69z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 528.899 528.899'\r\n};\r\n\r\nexport const icRemove = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M465.167 211.613H26.69c-8.424 0-26.69 11.439-26.69 34.316s18.267 34.316 26.69 34.316H465.169c8.421 0 26.689-11.439 26.689-34.316s-18.268-34.316-26.691-34.316z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 491.858 491.858'\r\n};\r\n\r\nexport const icAdd = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fillRule=\"evenodd\"\r\n        clipRule=\"evenodd\"\r\n        d=\"M34.525 19.11l.398.038a17.705 17.705 0 000-3.296l-.398.037-.398.038a16.903 16.903 0 010 3.146l.398.038zm-.333-5.342l.39-.087a17.364 17.364 0 00-1.017-3.133l-.367.16-.367.158c.413.954.74 1.953.97 2.989l.39-.087zm-1.97-4.974l.343-.203a17.556 17.556 0 00-1.938-2.664l-.3.265-.3.264a16.76 16.76 0 011.85 2.542l.344-.204zm-3.414-4.121l.265-.3a17.551 17.551 0 00-2.663-1.938l-.204.344-.204.344a16.755 16.755 0 012.542 1.85l.264-.3zm-4.515-2.87l.159-.368c-1-.433-2.047-.775-3.133-1.017l-.087.39-.087.39c1.036.231 2.035.558 2.989.971l.159-.367zM19.11.474l.037-.398a17.718 17.718 0 00-3.296 0l.037.398.038.398a16.919 16.919 0 013.146 0l.038-.398zm-5.343.333l-.087-.39a17.365 17.365 0 00-3.133 1.017l.16.367.158.367c.954-.413 1.953-.74 2.989-.97l-.087-.39zm-4.974 1.97l-.203-.343c-.95.562-1.841 1.212-2.664 1.938l.265.3.264.3a16.756 16.756 0 012.542-1.85l-.204-.344zM4.673 6.193l-.3-.265a17.556 17.556 0 00-1.938 2.664l.344.203.344.204a16.756 16.756 0 011.85-2.542l-.3-.264zm-2.87 4.515l-.368-.159c-.433 1-.775 2.047-1.017 3.133l.39.087.39.087c.231-1.036.558-2.036.971-2.989l-.367-.159zM0 17.5c0-.556.026-1.105.077-1.648l.398.037.398.038a16.919 16.919 0 000 3.146l-.398.038-.398.037A17.718 17.718 0 010 17.5zm.808 3.732l-.39.087a17.365 17.365 0 001.017 3.133l.367-.16.367-.158a16.565 16.565 0 01-.97-2.989l-.39.087zm1.97 4.974l-.343.204a17.55 17.55 0 001.938 2.663l.3-.265.3-.264a16.755 16.755 0 01-1.85-2.542l-.344.204zm3.414 4.121l-.265.3a17.556 17.556 0 002.664 1.938l.203-.344.204-.344a16.76 16.76 0 01-2.542-1.85l-.264.3zm4.515 2.87l-.159.368c1 .433 2.047.775 3.133 1.017l.087-.39.087-.39a16.563 16.563 0 01-2.989-.971l-.159.367zm5.182 1.328l-.037.398a17.705 17.705 0 003.296 0l-.037-.398-.038-.398a16.903 16.903 0 01-3.146 0l-.038.398zm5.343-.333l.087.39a17.364 17.364 0 003.133-1.017l-.16-.367-.158-.367c-.954.413-1.953.74-2.989.97l.087.39zm4.974-1.97l.204.343c.949-.562 1.84-1.212 2.663-1.938l-.265-.3-.264-.3a16.76 16.76 0 01-2.542 1.85l.204.344zm4.121-3.414l.3.265a17.552 17.552 0 001.938-2.663l-.344-.204-.344-.204a16.76 16.76 0 01-1.85 2.542l.3.264zm2.87-4.515l.368.159c.433-1 .775-2.047 1.017-3.133l-.39-.087-.39-.087a16.563 16.563 0 01-.971 2.989l.367.159zM17.7 9.723a.5.5 0 01.5.5V17h7a.5.5 0 010 1h-7v6.778a.5.5 0 01-1 0V18h-7a.5.5 0 010-1h7v-6.778a.5.5 0 01.5-.5z\"\r\n        fill={props.color || '#dcdcdc'}\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 35 35'\r\n};\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport Toggle from 'react-bootstrap-toggle';\r\nimport { Button, Dropdown, DropdownButton } from 'react-bootstrap';\r\nimport autobind from 'autobind-decorator';\r\nimport { Icon } from '../index';\r\nimport type { DrawingSegmentType } from '../../../utils/types';\r\nimport './SegmentSetting.scss';\r\n\r\ntype PropsType = {\r\n  value?: DrawingSegmentType,\r\n  data: Array<string>,\r\n  onDone: void,\r\n  onDelete: void,\r\n  onVisibleChange: void\r\n};\r\n\r\ntype StateType = {\r\n  start: string,\r\n  end: string,\r\n  visible: boolean,\r\n  isEditMode: boolean,\r\n  isCreateMode: boolean,\r\n  isMouseHoverEdition: boolean,\r\n  isMouseHoverDeletion: boolean,\r\n};\r\n\r\nclass SegmentSetting extends React.Component<PropsType, StateType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    const start = props.value ? props.value.name[0] : '';\r\n    const end = props.value ? props.value.name[1] : '';\r\n    this.state = {\r\n      start,\r\n      end,\r\n      visible: true,\r\n      isEditMode: !props.value,\r\n      isCreateMode: !props.value,\r\n      isMouseHoverEdition: false,\r\n      isMouseHoverDeletion: false,\r\n    };\r\n  }\r\n\r\n  @autobind\r\n  onDone() {\r\n    const {start, end} = this.state;\r\n    const {onDone} = this.props;\r\n\r\n    if (onDone) {\r\n      onDone({name: [start, end].sort().join(''), visible: true});\r\n    }\r\n    this.setState({isEditMode: false});\r\n  }\r\n\r\n  @autobind\r\n  onDelete() {\r\n    const {onDelete} = this.props;\r\n    if (onDelete) {\r\n      onDelete();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onVisibleChange(visible: boolean) {\r\n    const {onVisibleChange, value} = this.props;\r\n    if (onVisibleChange) {\r\n      onVisibleChange({name: value.name, visible: !value.visible});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  getIndexInData(dropdownIndex: string, filterValue: string): number {\r\n    const {data} = this.props;\r\n    const filterValueIndex = data.indexOf(filterValue);\r\n    if (filterValueIndex < 0) {\r\n      return dropdownIndex;\r\n    }\r\n    return filterValueIndex > dropdownIndex ? dropdownIndex : parseInt(dropdownIndex) + 1;\r\n  }\r\n\r\n  @autobind\r\n  onStartPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    const {start, end} = this.state;\r\n    const newStartValue = data[index];\r\n    if (newStartValue === end) {\r\n      this.setState({start: newStartValue, end: start});\r\n    } else {\r\n      this.setState({start: newStartValue});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onEndPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    this.setState({end: data[this.getIndexInData(index, this.state.start)]});\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverEdition() {\r\n    this.setState({isMouseHoverEdition: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveEdition() {\r\n    this.setState({isMouseHoverEdition: false})\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverDeletion() {\r\n    this.setState({isMouseHoverDeletion: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveDeletion() {\r\n    this.setState({isMouseHoverDeletion: false})\r\n  }\r\n\r\n  @autobind\r\n  onChangeContentState() {\r\n    const {isEditMode, start, end} = this.state;\r\n    if (!start || !end) {\r\n      return;\r\n    }\r\n    this.setState({isEditMode: !isEditMode});\r\n  }\r\n\r\n  @autobind\r\n  renderDropdown(value: string, data: Array<string>, onSelect: void): React.Node {\r\n    return (\r\n      <DropdownButton title={value || 'Chọn điểm'} id={`segment-dropdown`} onSelect={onSelect}>\r\n        {data.map((item: string, index: number): React.Node => (\r\n          <Dropdown.Item key={`Drop-item-${index}`} eventKey={`${index}`}>\r\n            {item}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderEditContent(): React.Node {\r\n    const {data} = this.props;\r\n    const {start, end, isCreateMode} = this.state;\r\n    return (\r\n      <div className=\"content-edit\">\r\n        <div className=\"drop-down-container\">\r\n          <div className={\"col-6 p-0\"}>\r\n            {this.renderDropdown(start, data, this.onStartPointSelect)}\r\n          </div>\r\n          <div className=\"col-6 p-0 right-drop-down\">\r\n            {this.renderDropdown(end, data.filter((item) => item !== this.state.start), this.onEndPointSelect)}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"button-container mt-1\">\r\n          <div className={\"col-6 p-0 d-flex justify-content-between\"}>\r\n            <Button className={\"btn-cancel\"} onClick={isCreateMode ? this.onDelete : this.onChangeContentState}>\r\n              HỦY\r\n            </Button>\r\n            <Button className={\"btn-update\"} variant={`${isCreateMode ? 'link' : 'success'}`} disabled={!(start && end)}\r\n                    onClick={this.onDone}>\r\n              {isCreateMode ? 'THÊM' : 'CẬP NHẬT'}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderShowContent(): React.Node {\r\n    const {\r\n      value: {name, visible}\r\n    } = this.props;\r\n    return (\r\n      <div className=\"content-show\">\r\n        <div className=\"content\">\r\n          <div className={\"segment-edit-name col-8\"}>\r\n            <p>{name}</p>\r\n          </div>\r\n\r\n          <div className={\"segment-edit-controller col-4\"}>\r\n            <Toggle\r\n              onstyle=\"success\"\r\n              offstyle=\"danger\"\r\n              handleClassName=\"toggle-handler\"\r\n              onClick={this.onVisibleChange}\r\n              off=\"HIỆN\"\r\n              on=\"ẨN\"\r\n              active={visible}\r\n            />\r\n\r\n            <div onClick={this.onChangeContentState}\r\n                 onMouseLeave={this.mouseLeaveEdition}\r\n                 onMouseOver={this.mouseHoverEdition}\r\n                 onMouseDown={this.mouseLeaveEdition}>\r\n              {\r\n                this.state.isMouseHoverEdition ?\r\n                  <Icon name={'icEdit'} color={'#218838'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icEdit'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n\r\n            <div onClick={this.onDelete}\r\n                 onMouseOver={this.mouseHoverDeletion}\r\n                 onMouseLeave={this.mouseLeaveDeletion}\r\n                 onMouseDown={this.mouseLeaveDeletion}>\r\n              {\r\n                this.state.isMouseHoverDeletion ?\r\n                  <Icon name={'icRemove'} color={'#dc3545'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icRemove'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderContent(): React.Node {\r\n    const {isEditMode} = this.state;\r\n    if (isEditMode) {\r\n      return this.renderEditContent();\r\n    }\r\n\r\n    return this.renderShowContent();\r\n  }\r\n\r\n  render(): React.Node {\r\n    const {style} = this.props;\r\n    const {isEditMode, isCreateMode} = this.state;\r\n\r\n    return (\r\n      <div className=\"segment-setting\" style={{...style}}>\r\n        <div className=\"container\">\r\n          {isEditMode && (\r\n            <div className=\"title\">\r\n              <p>{`${isCreateMode ? 'Thêm' : 'Cập nhật'} đoạn thẳng :`}</p>\r\n            </div>\r\n          )}\r\n          {this.renderContent()}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SegmentSetting;\r\n","class Geom {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  toString() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nexport { Geom };\r\n","import { Geom } from './geom';\r\n\r\nclass Point extends Geom {\r\n  constructor(name, x, y) {\r\n    if (typeof y === 'undefined') {\r\n      y = x;\r\n      x = name;\r\n      name = null;\r\n    }\r\n    super(name);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.free = true;\r\n  }\r\n\r\n  toString() {\r\n    return super.toString() + '(' + this.x + ',' + this.y + ')';\r\n  }\r\n\r\n  /* shorthand function for constructing a point from coodinates */\r\n  static P(name, x, y) {\r\n    return new Point(name, x, y);\r\n  }\r\n}\r\n\r\nexport { Point };\r\n","import { Geom } from './geom';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nclass Circle extends Geom {\r\n  constructor(name, center, a) {\r\n    if (typeof a === 'undefined') {\r\n      a = center;\r\n      center = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    this.center = center;\r\n    if (a instanceof Point) {\r\n      this._fromCenterAndBoundaryPoint(center, a);\r\n    } else if (typeof a === 'number') {\r\n      this._fromCenterAndRadius(center, a);\r\n    }\r\n  }\r\n\r\n  _fromCenterAndRadius(center, radius) {\r\n    this.radius = radius;\r\n    Object.defineProperties(this, {\r\n      radiussq: {\r\n        get() {\r\n          return this.radius * this.radius;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _fromCenterAndBoundaryPoint(center, boundaryPoint) {\r\n    this.boundaryPoint = boundaryPoint;\r\n    Object.defineProperties(this, {\r\n      radius: {\r\n        get() {\r\n          return distance(this.boundaryPoint, this.center);\r\n        }\r\n      },\r\n      radiussq: {\r\n        get() {\r\n          return distanceSquared(this.boundaryPoint, this.center);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    var w = Math.abs(x - this.center.x);\r\n    if (w > this.radius) return null;\r\n    if (w === this.radius) return new Point(x, this.center.y);\r\n\r\n    var h = Math.sqrt(this.radius * this.radius - w * w);\r\n    return [this.center.y + h, this.center.y - h];\r\n  }\r\n\r\n  contains(p) {\r\n    return distanceSquared(p, this.center) === this.radiussq;\r\n  }\r\n\r\n  toString() {\r\n    return 'Circle' + super.toString() + '[' + this.center.toString() + ';' + this.radius + ']';\r\n  }\r\n}\r\n\r\nexport { Circle };\r\n","import { Geom } from './geom';\r\n\r\nclass Line extends Geom {\r\n  constructor(name, p1, p2) {\r\n    if (typeof p2 === 'undefined') {\r\n      p2 = p1;\r\n      p1 = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    if (!p2) {\r\n      this._p = p1.slice(0);\r\n    } else {\r\n      this._p = [p1, p2];\r\n    }\r\n\r\n    this._clip = false;\r\n\r\n    Object.defineProperties(this, {\r\n      // TODO: I don't like dx and dy on the line class...\r\n      dx: {\r\n        get() {\r\n          return this._p[1].x - this._p[0].x;\r\n        }\r\n      },\r\n      dy: {\r\n        get() {\r\n          return this._p[1].y - this._p[0].y;\r\n        }\r\n      },\r\n      theta: {\r\n        get() {\r\n          return Math.atan2(this.dy, this.dx);\r\n        }\r\n      },\r\n      m: {\r\n        get() {\r\n          if (this.dx === 0) return null;\r\n          else return this.dy / this.dx;\r\n        }\r\n      },\r\n\r\n      left: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      right: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      top: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      },\r\n      bottom: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    if (this.dx === 0 || (this._clip && (this.left > x || this.right < x))) return null;\r\n    else return this._p[0].y + ((x - this._p[0].x) * this.dy) / this.dx;\r\n  }\r\n\r\n  x(y) {\r\n    if (this.dy === 0 || (this._clip && (this.top > y || this.bottom < y))) return null;\r\n    else return this._p[0].x + ((y - this._p[0].y) * this.dx) / this.dy;\r\n  }\r\n\r\n  contains(p) {\r\n    let onLine = this.dx !== 0 ? this.y(p.x) === p.y : this.x(p.y) === p.x;\r\n    return (\r\n      onLine && (!this._clip || (this.left <= p.x && p.x <= this.right && (this.top <= p.y && p.y <= this.bottom)))\r\n    );\r\n  }\r\n\r\n  toString() {\r\n    return 'Line' + super.toString() + '[' + this._p[0].toString() + ';' + this._p[1].toString() + ']';\r\n  }\r\n}\r\n\r\nexport { Line };\r\n","import { Line } from './line';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nconst P = Point.P;\r\n\r\nclass Segment extends Line {\r\n  constructor(name, p1, p2) {\r\n    super(name, p1, p2);\r\n    this._clip = true;\r\n\r\n    Object.defineProperties(this, {\r\n      p: {\r\n        // TODO: clone point themselves?\r\n        get() {\r\n          return [].concat(this._p);\r\n        }\r\n      },\r\n\r\n      lengthsq: {\r\n        get() {\r\n          return distanceSquared(this._p[0], this._p[1]);\r\n        }\r\n      },\r\n\r\n      length: {\r\n        get() {\r\n          return distance(this._p[0], this._p[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  toString() {\r\n    return 'Segment' + super.toString();\r\n  }\r\n\r\n  /*\r\n  clip the given line (or line segment) to the given bounding box, where `bounds`\r\n  must have `left`, `right`, `top`, and `bottom` properties.\r\n  */\r\n  static clip(bounds, line) {\r\n    var [p1, p2] = line._p;\r\n\r\n    var left = line.y(bounds.left),\r\n      right = line.y(bounds.right),\r\n      top = line.x(bounds.top),\r\n      bottom = line.x(bounds.bottom);\r\n\r\n    if (p1.x > p2.x) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (left && left >= bounds.top && left <= bounds.bottom) {\r\n      // intersects left wall\r\n      p1 = P(bounds.left, left);\r\n    }\r\n    if (right && right >= bounds.top && right <= bounds.bottom) {\r\n      // intersects right wall\r\n      p2 = P(bounds.right, right);\r\n    }\r\n\r\n    if (p1.y > p2.y) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (top && top >= bounds.left && top <= bounds.right) {\r\n      // intersects top wall\r\n      p1 = P(top, bounds.top);\r\n    }\r\n    if (bottom && bottom >= bounds.left && bottom <= bounds.right) {\r\n      // intersects bottom wall\r\n      p2 = P(bottom, bounds.bottom);\r\n    }\r\n\r\n    let clipped = new Segment(null, p1, p2);\r\n    clipped.parent = line;\r\n    return clipped;\r\n  }\r\n}\r\n\r\nexport { Segment };\r\n","import { Point } from './model/point';\r\nimport { Line } from './model/line';\r\nimport { Segment } from './model/segment';\r\nimport { Circle } from './model/circle';\r\nimport { distanceSquared as dd } from './calc';\r\n\r\nimport uniq from 'uniq';\r\n\r\nlet P = Point.P;\r\n\r\n/* helpers */\r\nfunction comparePoints(p, q) {\r\n  return p.x === q.x && p.y === q.y ? 0 : 1;\r\n}\r\n\r\nfunction sq(a) {\r\n  return a * a;\r\n}\r\n\r\nfunction between(x, a, b) {\r\n  let left = Math.min(a, b),\r\n    right = Math.max(a, b);\r\n  return left <= x && x <= right;\r\n}\r\n\r\n/*\r\n  Intersection of two objects; returns an array, possibly empty, of \r\n  intersection points.\r\n*/\r\n\r\n/**\r\n * intersect - Find the intersection(s) of the given two objects.\r\n *\r\n * @param  {Geom} o1 first object\r\n * @param  {Geom} o2 second object\r\n * @return {Array.<Point>}    Points of intersection between the two objects.\r\n */\r\nfunction intersect(o1, o2) {\r\n  if (o1 instanceof Circle && o2 instanceof Circle)\r\n    // circle-circle\r\n    return intersectCircleCircle(o1, o2);\r\n  // if only one is a circle, it should be first.\r\n  else if (o2 instanceof Circle) return intersect(o2, o1);\r\n  else if (o1 instanceof Circle && o2 instanceof Segment)\r\n    // circle-segment\r\n    return intersectCircleLine(o1, o2, true);\r\n  else if (o1 instanceof Circle && o2 instanceof Line)\r\n    // circle-line\r\n    return intersectCircleLine(o1, o2, false);\r\n  else if (o1 instanceof Segment && o2 instanceof Segment)\r\n    // segment-segment\r\n    return intersectLineLine(o1, o2, true);\r\n  // if only one is a segment, it should be first.\r\n  else if (o2 instanceof Segment) return intersect(o2, o1);\r\n  else if (o1 instanceof Line && o2 instanceof Line)\r\n    // line-line\r\n    return intersectLineLine(o1, o2, false);\r\n  // TODO: circle-point, segment-point, point-point\r\n  else if (o2 instanceof Point || o1 instanceof Point) return [];\r\n  else throw new Error('Cannot intersect ' + o1.constructor.name + ' and ' + o2.constructor.name);\r\n}\r\n\r\nfunction intersectCircleCircle(c1, c2) {\r\n  let dsq = dd(c1.center, c2.center);\r\n  let d = Math.sqrt(dsq);\r\n\r\n  if (d > c1.radius + c2.radius) {\r\n    return [];\r\n  } else if (d < c1.radius - c2.radius) {\r\n    return [];\r\n  } else if (dsq === 0) {\r\n    return [];\r\n  }\r\n\r\n  let a = (c1.radiussq - c2.radiussq + dsq) / (2 * d);\r\n  let h = Math.sqrt(Math.max(c1.radiussq - sq(a), 0));\r\n  let cx = c1.center.x + (a * (c2.center.x - c1.center.x)) / d;\r\n  let cy = c1.center.y + (a * (c2.center.y - c1.center.y)) / d;\r\n\r\n  let nx = (h * (c1.center.y - c2.center.y)) / d;\r\n  let ny = (h * (c1.center.x - c2.center.x)) / d;\r\n\r\n  return uniq([P(0, cx + nx, cy - ny), P(1, cx - nx, cy + ny)], comparePoints);\r\n}\r\n\r\nfunction intersectLineLine(s1, s2, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s1._p;\r\n  let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = s2._p;\r\n  let s = (-s1.dy * (x1 - x3) + s1.dx * (y1 - y3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n  let t = (s2.dx * (y1 - y3) - s2.dy * (x1 - x3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n\r\n  if (!clip || (between(s, 0, 1) && between(t, 0, 1))) return [P(0, x1 + t * s1.dx, y1 + t * s1.dy)];\r\n  else return []; // no collision\r\n}\r\n\r\n/* http://mathworld.wolfram.com/Circle-LineIntersection.html */\r\nfunction intersectCircleLine(c, s, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s._p;\r\n  let { x: x0, y: y0 } = c.center;\r\n\r\n  // note the translation (x0, y0)->(0,0).\r\n  let D = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0);\r\n  let Dsq = sq(D);\r\n\r\n  let lensq = sq(s.dx) + sq(s.dy);\r\n  let disc = Math.sqrt(sq(c.radius) * lensq - Dsq);\r\n  if (disc < 0) {\r\n    return [];\r\n  }\r\n\r\n  let cx = (D * s.dy) / lensq,\r\n    cy = (-D * s.dx) / lensq;\r\n  let nx = ((s.dy < 0 ? -1 * s.dx : s.dx) * disc) / lensq,\r\n    ny = (Math.abs(s.dy) * disc) / lensq;\r\n\r\n  // translate (0,0)->(x0, y0).\r\n  return uniq([P(0, cx + nx + x0, cy + ny + y0), P(1, cx - nx + x0, cy - ny + y0)], comparePoints).filter((p) =>\r\n    clip ? between(p.x, x1, x2) && between(p.y, y1, y2) : true\r\n  );\r\n}\r\n\r\nexport { intersect, intersectCircleCircle, intersectCircleLine, intersectLineLine };\r\n","import { Point } from './point';\r\nimport { Geom } from './geom';\r\n\r\nimport { intersect } from '../intersection';\r\n\r\nclass Intersection extends Point {\r\n  /**\r\n   * @param {string} name\r\n   * @param {...Geom} objects to be intersected\r\n   * @param {number|Geom~boolean} [which] optional array index or filter callback in case there are multiple intersections.\r\n   */\r\n  constructor(name, ...objects) {\r\n    if (name instanceof Geom) {\r\n      objects.shift(name);\r\n      name = null;\r\n    }\r\n    super(name, null, null);\r\n\r\n    this.which = /function|number/.test(typeof objects[objects.length - 1]) ? objects.pop() : 0;\r\n    this.objects = objects;\r\n    this.free = false;\r\n  }\r\n\r\n  update() {\r\n    let result = intersect.apply(null, this.objects);\r\n    if (typeof this.which === 'function') result = result.filter(this.which)[0];\r\n    else result = result[this.which];\r\n\r\n    if (result) {\r\n      ({ x: this.x, y: this.y } = result);\r\n    } else {\r\n      this.x = this.y = null;\r\n    }\r\n  }\r\n\r\n  toString(verbose) {\r\n    let pstr = super.toString();\r\n    return !verbose ? pstr : pstr + '; intersection of: ' + this.objects.map((o) => o.toString()).join(',');\r\n  }\r\n}\r\n\r\nexport { Intersection };\r\n","import { Point } from './point';\r\nimport { Circle } from './circle';\r\nimport { Line } from './line';\r\nimport { Segment } from './segment';\r\nimport { Intersection } from './intersection';\r\n\r\nconst P = Point.P;\r\nexport { P, Point, Circle, Segment, Line, Intersection };\r\n\r\n/* return a deep-equality test function that checks for geometric object\r\n   equality using the given distance threshold for point equality; i.e., if \r\n   two points are closer than `threshold`, consider them equal. */\r\nexport function equalWithin(threshold) {\r\n  threshold = threshold || 0;\r\n  return function equal(o1, o2) {\r\n    if (Array.isArray(o1) && Array.isArray(o2)) {\r\n      return o1.every((obj, index) => equal(obj, o2[index]));\r\n    }\r\n    if (typeof o1 === 'number' && typeof o2 === 'number') {\r\n      return Math.abs(o1 - o2) < threshold;\r\n    }\r\n    if (o1 instanceof Point && o2 instanceof Point) {\r\n      if (o1.x === null || o2.x === null || o1.y === null || o2.y === null) return false;\r\n      else return equal(Math.abs(o1.x - o2.x) + Math.abs(o1.y - o2.y), 0);\r\n    }\r\n    if (o1 instanceof Circle && o2 instanceof Circle) {\r\n      return equal(o1.radius, o2.radius) && equal(o1.center, o2.center);\r\n    }\r\n    if (o1 instanceof Segment && o2 instanceof Segment) {\r\n      var p1 = [].concat(o1.p),\r\n        p2 = [].concat(o2.p);\r\n      // ensure points from both segments are in the same order\r\n      // (left to right or right to left).\r\n      if (p1[0].x > p1[1].x && p2[0].x < p2[0].x) p1.reverse();\r\n      // then delegate to point equality\r\n      return equal(p1, p2);\r\n    }\r\n    if (o1 instanceof Line && o2 instanceof Line) {\r\n      return equal(o1.m, o2.m) && equal(o1.y(0), o2.y(0)) && equal(o1.x(0), o2.x(0));\r\n    }\r\n\r\n    // fallback to object equality\r\n    return o1 === o2;\r\n  };\r\n}\r\n","import * as d3 from 'd3';\r\nimport { Circle, equalWithin, Intersection, Line, Point, Segment } from './model';\r\n\r\nfunction addClass(obj, klass) {\r\n  obj.classes = obj.classes || d3.set();\r\n  obj.classes.add(klass);\r\n}\r\n\r\nclass Scene {\r\n  constructor(bounds) {\r\n    this.bounds = bounds;\r\n    this.bounds.width = this.bounds.right - this.bounds.left;\r\n    this.bounds.height = this.bounds.bottom - this.bounds.top;\r\n\r\n    this._last = null; // hack -- should be keeping objects in ordered structure anyway.\r\n    this._objects = d3.map();\r\n    this.equal = equalWithin(Math.sqrt(2));\r\n    this.log = [];\r\n  }\r\n\r\n  /* return an array of all Points in the scene */\r\n  points() {\r\n    return this._objects.values().filter((o) => o instanceof Point);\r\n  }\r\n\r\n  /* return an array of all objects in the scene */\r\n  objects() {\r\n    return this._objects.values();\r\n  }\r\n\r\n  /* find the given object is in the scene using geometric\r\n  (i.e. deep) equality rather than reference ===. */\r\n  find(obj) {\r\n    let objects = this._objects.values();\r\n    for (let i = 0; i < objects.length; i++) {\r\n      if (this.equal(objects[i], obj)) return objects[i];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * is - Get an equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is geometrically equal to obj.\r\n   */\r\n  is(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && this.equal(obj, secondObj);\r\n  }\r\n\r\n  /**\r\n   * is - Get an NON-equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is NOT geometrically equal to obj.\r\n   */\r\n  isnt(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && !this.equal(obj, secondObj);\r\n  }\r\n\r\n  last() {\r\n    return this._last;\r\n  }\r\n\r\n  get(name) {\r\n    return this._objects.get(name);\r\n  }\r\n\r\n  point(name, x, y) {\r\n    return this.add(new Point(name, x, y));\r\n  }\r\n\r\n  circle(name, centerId, radius) {\r\n    return this.add(new Circle(name, this.get(centerId), radius));\r\n  }\r\n\r\n  segment(name, id1, id2) {\r\n    return this.add(new Segment(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  line(name, id1, id2) {\r\n    return this.add(new Line(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  intersection(name, id1, id2, which) {\r\n    if (typeof id2 === 'undefined') {\r\n      id2 = id1;\r\n      id1 = name;\r\n      name = null;\r\n    }\r\n\r\n    let o1 = this.get(id1),\r\n      o2 = this.get(id2);\r\n    if (!o1) throw new Error(\"Can't find object \" + id1);\r\n    if (!o2) throw new Error(\"Can't find object \" + id2);\r\n\r\n    return this.add(new Intersection(name, o1, o2, which));\r\n  }\r\n\r\n  group(tag) {\r\n    this._currentTag = tag;\r\n    return this;\r\n  }\r\n\r\n  add(object) {\r\n    // if we already have this object, and it's the same type, then update the\r\n    // existing one in place.\r\n    let existing = this._objects.get(object.name);\r\n    if (existing && existing.constructor.name === object.constructor.name) {\r\n      for (let prop in object) existing[prop] = object[prop];\r\n      object = existing;\r\n    }\r\n    // if an object of the same name but different type or an object that is\r\n    // geometrically equivalent already exists in the scene, do nothing.\r\n    else if (existing || (existing = this.find(object))) {\r\n      return this;\r\n    }\r\n    // add a new object to the scene.\r\n    else {\r\n      object.name = object.name || this.freeName();\r\n      this._objects.set(object.name, object);\r\n    }\r\n\r\n    if (this._currentTag) addClass(object, this._currentTag);\r\n    if (object.free) addClass(object, 'free-point');\r\n\r\n    this.update(object);\r\n\r\n    this._last = object;\r\n    return this;\r\n  }\r\n\r\n  freeName() {\r\n    let keys = this._objects.keys(),\r\n      id = 0;\r\n    for (; keys.indexOf('object' + id) >= 0; id++);\r\n    return 'object' + id;\r\n  }\r\n\r\n  /**\r\n   * update - Update objects to reflect changes in dependent objects. (E.g.,\r\n   * update Intersection coordinates when the intersected objects have changed.)\r\n   *\r\n   * @param {Geom} root The object from which to start walking the dependency graph.\r\n   */\r\n  // TODO: respect `root` parameter, and do an actual DAG walk.\r\n  update(root) {\r\n    this._objects\r\n      .values()\r\n      .filter((obj) => obj instanceof Intersection)\r\n      .forEach((obj) => obj.update());\r\n  }\r\n\r\n  logState(label) {\r\n    let self = this;\r\n    let objects = this._objects.values();\r\n    let points = this.points();\r\n\r\n    let state = {\r\n      label,\r\n      time: new Date().toString(),\r\n      objects: objects.map((o) => o.toString())\r\n    };\r\n    this.log.push(state);\r\n  }\r\n}\r\n\r\nexport { Scene };\r\n","import * as d3 from 'd3';\r\nimport { Circle, Line, Point, Segment } from './model';\r\n\r\nfunction klasses() {\r\n  let init = Array.prototype.slice.call(arguments, 0);\r\n  return (d) => init.concat(d.classes ? d.classes.values() : []).join(' ');\r\n}\r\n\r\nfunction renderGeometry(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* circles */\r\n  let circles = svg.selectAll('g.circle').data(scene.objects().filter((d) => d instanceof Circle));\r\n\r\n  let circleGroup = circles\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('circle'));\r\n  circleGroup.append('circle').attr('class', 'handle');\r\n  circleGroup.append('circle').attr('class', 'visible');\r\n\r\n  circles\r\n    .attr('class', klasses('circle'))\r\n    .selectAll('circle')\r\n    .attr('cx', (d) => d.center.x)\r\n    .attr('cy', (d) => d.center.y)\r\n    .attr('r', (d) => d.radius);\r\n\r\n  circles.exit().remove();\r\n\r\n  /* lines */\r\n  let lines = svg.selectAll('g.line').data(scene.objects().filter((d) => d instanceof Line));\r\n\r\n  let lineGroup = lines\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('line'));\r\n  lineGroup.filter((d) => d instanceof Segment).attr('class', klasses('line', 'segment'));\r\n  lineGroup.append('line').attr('class', 'handle');\r\n  lineGroup.append('line').attr('class', 'visible');\r\n\r\n  // TODO: this is grossly inefficient\r\n  function endpoint(index, coord) {\r\n    return (d) => {\r\n      let s = d instanceof Segment ? d : Segment.clip(scene.bounds, d);\r\n      return s.p[index][coord];\r\n    };\r\n  }\r\n\r\n  lines\r\n    .attr('class', klasses('line'))\r\n    .selectAll('line')\r\n    .attr('x1', endpoint(0, 'x'))\r\n    .attr('y1', endpoint(0, 'y'))\r\n    .attr('x2', endpoint(1, 'x'))\r\n    .attr('y2', endpoint(1, 'y'));\r\n\r\n  lines.exit().remove();\r\n}\r\n\r\nfunction renderPoints(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* points */\r\n  let points = svg.selectAll('circle.point').data(scene.objects().filter((d) => d instanceof Point));\r\n\r\n  points\r\n    .enter()\r\n    .append('circle')\r\n    .attr('class', klasses('point'))\r\n    .attr('cx', (d) => d.x)\r\n    .attr('cy', (d) => d.y)\r\n    .attr('r', (d) => 5);\r\n\r\n  points\r\n    .enter()\r\n    .append('text')\r\n    .attr('class', klasses('point-name'))\r\n    .attr('x', (d) => d.x + 10)\r\n    .attr('y', (d) => d.y - 15)\r\n    .attr('id', (d) => `point-${d.name}`);\r\n\r\n  points.enter()._groups[0].forEach((node) => {\r\n    const name = node.__data__.name;\r\n    document.getElementById(`point-${name}`).appendChild(document.createTextNode(name));\r\n  });\r\n\r\n  points.exit().remove();\r\n}\r\n\r\nexport { renderGeometry, renderPoints };\r\n","import * as React from 'react';\r\nimport { Scene } from '../../../vendor/euclid';\r\nimport { renderGeometry, renderPoints } from '../../../vendor/euclid/render';\r\nimport type { DrawingDataType } from '../../../utils/types';\r\nimport './DrawingPanel.scss';\r\ntype PropsType = {\r\n  drawingData: DrawingDataType\r\n};\r\n\r\nclass DrawingPanel extends React.Component<PropsType> {\r\n  componentDidMount() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  renderGeometry(drawingData: DrawingDataType) {\r\n    const svg = document.getElementById('geometry');\r\n\r\n    while (svg.firstChild) {\r\n      svg.firstChild.remove();\r\n    }\r\n    const pointElements = document.getElementById('points');\r\n    while (pointElements.firstChild) {\r\n      pointElements.firstChild.remove();\r\n    }\r\n\r\n    const { points, segments, circles } = drawingData;\r\n    const viewBox = svg.viewBox.baseVal;\r\n    const width = viewBox.width;\r\n    const height = viewBox.height;\r\n\r\n    const scene = new Scene({\r\n      left: viewBox.x,\r\n      top: viewBox.y,\r\n      right: viewBox.x + width,\r\n      bottom: viewBox.y + height\r\n    });\r\n\r\n    const arrX = [];\r\n    const arrY = [];\r\n    points.forEach((point) => {\r\n      arrX.push(point.coordinate.x);\r\n      arrY.push(point.coordinate.y);\r\n    });\r\n\r\n    const disparityX = Math.max(...arrX) - Math.min(...arrX);\r\n    const disparityY = Math.max(...arrY) - Math.min(...arrY);\r\n    let ratio = 0;\r\n    const ODD = 15;\r\n    if (disparityX / disparityY >= 1) {\r\n      // scale theo width\r\n      // giá trị ước lượng (ODD): nhằm tránh điểm render ngay cạnh của viewBox sẽ làm mất tên điểm\r\n      ratio = Math.floor(width / disparityX) - ODD;\r\n    } else {\r\n      ratio = Math.floor(height / disparityY) - ODD;\r\n    }\r\n\r\n    const anchorX = Math.min(...arrX) + disparityX / 2;\r\n    const anchorY = Math.min(...arrY) + disparityY / 2;\r\n    points.forEach((point) => {\r\n      scene.point(\r\n        point.id,\r\n        point.coordinate.x * ratio + width / 2 - ratio * anchorX,\r\n        point.coordinate.y * ratio + height / 2 - ratio * anchorY\r\n      );\r\n    });\r\n\r\n    segments.forEach((segment) => {\r\n      if (segment && segment.visible) {\r\n        scene.segment(segment.name, segment.name[0], segment.name[1]);\r\n      }\r\n    });\r\n\r\n    if (circles) {\r\n      Object.keys(circles).forEach((point) => {\r\n        scene.point(\r\n          point,\r\n          circles[point].center.x * ratio + width / 2 - ratio * anchorX,\r\n          circles[point].center.y * ratio + height / 2 - ratio * anchorY\r\n        );\r\n        scene.circle(`circle-${point}`, point, circles[point].radius * ratio);\r\n      });\r\n    }\r\n\r\n    scene.update();\r\n    renderGeometry(scene, svg);\r\n    renderGeometry(scene, svg);\r\n    renderPoints(scene, pointElements);\r\n  }\r\n\r\n  render(): React.Node {\r\n    return (\r\n      <div className=\"geometry-container\">\r\n        <svg id=\"geometry\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n        <svg id=\"points\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DrawingPanel;\r\n","import React from 'react';\r\nimport './css/MainView.scss';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';\r\n\r\nimport DataViewModel from '../ViewModel/DataViewModel';\r\n\r\nimport { Icon, InputItem, SegmentSetting } from './components';\r\nimport { DrawingPanel } from './components/DrawingPanel';\r\nimport { calculateDistanceTwoPoints, calculateVector, isVectorSameDirection } from '../core/math/Math2D';\r\nimport type { DrawingSegmentType, SegmentDataType } from '../utils/types';\r\nimport GConst from '../utils/values';\r\n\r\n@observer\r\nclass MainView extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.inputRefs = [];\r\n    this.state = {\r\n      focusIndex: 0,\r\n      points: [\r\n        { id: 'A', coordinate: { x: 0, y: 0, z: 0 } },\r\n        { id: 'B', coordinate: { y: 5, x: -7 } },\r\n        { id: 'C', coordinate: { x: -9, y: 4.0901353661613005 } },\r\n        { id: 'H', coordinate: { x: -3.0849364905389067, y: 6.781088913245535 } },\r\n        { id: 'D', coordinate: { x: -5.250000000000003, y: 3.7500000000000018 } },\r\n        { id: 'E', coordinate: { x: -8, y: 9.794855240493977 } }\r\n      ],\r\n      segments: [\r\n        'AB',\r\n        'BC',\r\n        'AC',\r\n        'AH',\r\n        'DH',\r\n        'DE',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA'\r\n      ],\r\n      drawingSegments: []\r\n    };\r\n    this.scrollView = React.createRef();\r\n  }\r\n\r\n  componentWillMount() {\r\n    const { points, segments } = this.state;\r\n    this.setState({\r\n      drawingSegments: this.trimDrawingData({ points, segments }).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  scrollToBottom() {\r\n    if (this.scrollView.current) {\r\n      setTimeout(() => {\r\n        this.scrollView.current.firstChild.scrollIntoView(false);\r\n      }, 250);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  trimDrawingData(data) {\r\n    const { points, segments } = data;\r\n\r\n    //change to DataViewModel.getNodeInPointsMapById.coordinate when refactor done\r\n    const pointData = {};\r\n    points.forEach((point) => {\r\n      pointData[point.id] = point.coordinate;\r\n    });\r\n\r\n    const segmentsData = {};\r\n    let result = [];\r\n    points.forEach((point) => {\r\n      segmentsData[point.id] = segments\r\n        .map((segment: string): string =>\r\n          segment\r\n            .split('')\r\n            .sort()\r\n            .join('')\r\n        )\r\n        .filter((segment: string): boolean => segment.includes(point.id))\r\n        .map((segment: string): SegmentDataType => {\r\n          const firstPoint = pointData[segment[0]];\r\n          const secondPoint = pointData[segment[1]];\r\n          return {\r\n            name: segment,\r\n            vector: calculateVector(firstPoint, secondPoint),\r\n            length: calculateDistanceTwoPoints(firstPoint, secondPoint)\r\n          };\r\n        });\r\n    });\r\n\r\n    const removeSegments = [];\r\n\r\n    Object.keys(segmentsData).forEach((point) => {\r\n      if (segmentsData[point].length > 0) {\r\n        const segments = this.uniqueSegmentData(segmentsData[point], removeSegments);\r\n        result = result.concat(segments);\r\n      }\r\n    });\r\n\r\n    result = [...new Set(result)].filter((segment: string): boolean => segment[0] !== segment[1]);\r\n\r\n    return result;\r\n  }\r\n\r\n  uniqueSegmentData(data: Array<SegmentDataType>, removeSegments: Array<string>): Array<string> {\r\n    let result = [data[0]];\r\n    for (let i = 1; i < data.length; i++) {\r\n      const segmentData = data[i];\r\n\r\n      const length = result.length;\r\n      let replaceIndex = -1;\r\n      for (let j = 0; j < length; j++) {\r\n        if (isVectorSameDirection(segmentData.vector, result[j].vector)) {\r\n          if (segmentData.length >= result[j].length) {\r\n            replaceIndex = j;\r\n          } else {\r\n            removeSegments.push(segmentData.name);\r\n          }\r\n        }\r\n      }\r\n      if (replaceIndex >= 0) {\r\n        result[replaceIndex] = segmentData;\r\n      } else {\r\n        if (!removeSegments.includes(segmentData.name)) {\r\n          result.push(segmentData);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result.map((segmentData: SegmentDataType): string => segmentData.name);\r\n  }\r\n\r\n  @autobind\r\n  onValueChange(value: string, index: number) {\r\n    DataViewModel.RelationsInput[index].value = value;\r\n    this.setState({ focusIndex: index });\r\n  }\r\n\r\n  @autobind\r\n  onSubmit(index: number) {\r\n    if (index === DataViewModel.RelationsInput.length - 1 && DataViewModel.RelationsInput[index].value.length > 2) {\r\n      DataViewModel.addNewInput();\r\n    }\r\n\r\n    this.setState({ focusIndex: index + 1 });\r\n  }\r\n\r\n  @autobind\r\n  onBackspace(index: number) {\r\n    const value = DataViewModel.RelationsInput[index].value;\r\n    if (value.length === 0 && DataViewModel.RelationsInput.length > 1) {\r\n      DataViewModel.removeInput(index);\r\n      this.inputRefs.splice(index, 1);\r\n      this.setState({ focusIndex: index - 1 });\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onClickDrawing() {\r\n    DataViewModel.getData.clear();\r\n\r\n    const data = DataViewModel.analyzeInput();\r\n    if (data.points.length === 0 && data.segments.length === 0) {\r\n      DataViewModel.resetInputsStatus();\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      points: data.points,\r\n      segments: data.segments,\r\n      drawingSegments: this.trimDrawingData(data).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    const { focusIndex } = this.state;\r\n    if (this.inputRefs[focusIndex]) {\r\n      this.inputRefs[focusIndex].focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  renderRelationInput(): React.Node {\r\n    return DataViewModel.RelationsInput.map((model, index) => {\r\n      return (\r\n        <InputItem\r\n          key={`input-${index}`}\r\n          ref={(ref) => {\r\n            this.inputRefs[index] = ref;\r\n          }}\r\n          onValueChange={(value: string) => {\r\n            this.onValueChange(value, index);\r\n          }}\r\n          onSubmit={() => {\r\n            this.onSubmit(index);\r\n          }}\r\n          onBackspace={() => {\r\n            this.onBackspace(index);\r\n          }}\r\n          value={model.value}\r\n          status={model.status}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onDoneSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n    if (JSON.stringify(data) === JSON.stringify(drawingSegments[index])) {\r\n      return;\r\n    }\r\n\r\n    const isAddSegment = !!drawingSegments[index];\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments }, () => {\r\n      if (isAddSegment) {\r\n        if (drawingSegments.map((segment: SegmentDataType): string => segment.name).includes(data.name)) {\r\n          this.onDeleteSegmentSetting(index);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onChangeSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  onDeleteSegmentSetting(index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments.splice(index, 1);\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  addNewSegmentSetting() {\r\n    if (this.state.drawingSegments.includes(undefined)) {\r\n      return;\r\n    }\r\n    this.scrollToBottom();\r\n    this.setState((prevState) => ({\r\n      drawingSegments: prevState.drawingSegments.concat([undefined])\r\n    }));\r\n  }\r\n\r\n  @autobind\r\n  renderSegmentSettings(): React.Node {\r\n    const { drawingSegments } = this.state;\r\n    const points = this.state.points.map((point: NodeType): number => point.id);\r\n\r\n    return drawingSegments.map((segment: DrawingSegmentType, index: number): React.Node => {\r\n      return (\r\n        <SegmentSetting\r\n          key={`segment-setting-${index}`}\r\n          data={points}\r\n          value={segment}\r\n          onDone={(value) => {\r\n            this.onDoneSegmentSetting(value, index);\r\n          }}\r\n          onVisibleChange={(value) => {\r\n            this.onChangeSegmentSetting(value, index);\r\n          }}\r\n          onDelete={() => {\r\n            this.onDeleteSegmentSetting(index);\r\n          }}\r\n          style={index === 0 ? { marginTop: '1rem' } : {}}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { points, drawingSegments, segments } = this.state;\r\n    return (\r\n      <div className={'container-fluid'}>\r\n        <div className={'app-header'}>\r\n          <div className={'app-name'}>\r\n            <p>Gemath</p>\r\n          </div>\r\n\r\n          <div className={'app-description'}>\r\n            <p>app description</p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"app-body\">\r\n          <div className=\"app-controller\">\r\n            <div className=\"accordion\" id=\"accordionExample\">\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingOne\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewOne\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseOne\">\r\n                  <p>1. Nhập đề</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <div>{GConst.TutorialString.STEP_ONE}</div>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div\r\n                  id=\"viewOne\"\r\n                  className=\"collapse show\"\r\n                  aria-labelledby=\"headingOne\"\r\n                  data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\">\r\n                    <div>\r\n                      {this.renderRelationInput()}\r\n                      <Button\r\n                        type=\"button\"\r\n                        className=\"btn btn-success w-100\"\r\n                        onClick={this.onClickDrawing}\r\n                        disabled={DataViewModel.isInputEmpty}>\r\n                        Vẽ hình\r\n                      </Button>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingTwp\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewTwo\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseTwp\">\r\n                  <p>2. Chỉnh sửa hình</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <span>\r\n                          Thêm/Xóa các doạn thẳng\r\n                        </span>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div id=\"viewTwo\" className=\"collapse \" aria-labelledby=\"headingOne\" data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\" ref={this.scrollView}>\r\n                    <div>\r\n                      {this.renderSegmentSettings()}\r\n                      <div className={'add-row-container'} onClick={this.addNewSegmentSetting}>\r\n                        <Icon name={'icAdd'} width={35} height={35} color={'#757575'} />\r\n                        <p>Thêm đoạn thẳng</p>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className={'app-drawing-panel'}>\r\n            <DrawingPanel drawingData={{ points, segments: drawingSegments, circles: DataViewModel.circlesData }} />\r\n          </div>\r\n        </div>\r\n\r\n        <div className={'app-footer'}>\r\n          <p>abc</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MainView;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainView from './View/MainView';\r\n\r\nReactDOM.render(<MainView />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};"],"sourceRoot":""}