{"version":3,"sources":["serviceWorker.js","Model/AppData.js","core/definition/define.js","utils/values.js","core/math/Converter.js","core/math/Generation.js","utils/ErrorHandleService.js","vendor/euclid/calc.js","core/math/Math2D.js","utils/checker.js","core/definition/defineObjType.js","core/validation/validation.js","core/definition/index.js","core/definition/defineShapeType.js","core/definition/definePointType.js","core/math/GenerateGeometry.js","core/analysis/ReadPointsMap.js","core/analysis/ReadRelation.js","core/analysis/Analysis.js","Model/RelationInputModel.js","ViewModel/DataViewModel.js","View/components/InputItem/InputItem.js","View/components/Icon/Icon.js","View/components/Icon/Svg.js","View/components/SegmentSetting/SegmentSetting.js","vendor/euclid/model/geom.js","vendor/euclid/model/point.js","vendor/euclid/model/circle.js","vendor/euclid/model/line.js","vendor/euclid/model/segment.js","vendor/euclid/intersection.js","vendor/euclid/model/intersection.js","vendor/euclid/model/index.js","vendor/euclid/scene.js","vendor/euclid/render.js","View/components/DrawingPanel/DrawingPanel.js","View/MainView.js","index.js","utils/color.scss","View/components/InputItem/InputItem.scss"],"names":["Boolean","window","location","hostname","match","appData","AppData","Object","classCallCheck","this","additionSegment","relationsResult","pointsMap","pointsDirectionMap","executedRelations","executedNode","__pointDetails__","Map","clear","segment","push","newPointsMap","value","defineSentences","define","relation","shape","reversedDependentObjRelation","RankingObjectContain","objectWithPoint","validate","object","point","length","format","ray","line","angle","triangle","quadrilateral","trapezoid","parallelogram","rectangle","rhombus","square","circle","shapeType","shapeRules","right","isosceles","right_isosceles","equilateral","normal","mappingShapeType","vuông","cân","vuông cân","đều","nội tiếp","ngoại tiếp","bàng tiếp","circleType","TwoStaticPointRequireShape","ShapeAffectBySegmentChange","GConst","Number","freeze","MIN_RANDOM_NUMBER","MAX_RANDOM_NUMBER","MIN_RANDOM_GENERATION","MAX_RANDOM_GENERATION","NOT_FOUND","String","INFINITY","IMPOSSIBLE","TOO_SHORT","NOT_ENOUGH_SET","NOT_BE_IN_LINE","Regex","KEY","OTHER","Others","OPERATIONS","Errors","UNDEFINED_ERROR","WRONG_FORMAT","MAXIMUM_POINT_ERROR","InputStatus","SUCCESS","NORMAL","ERROR","TutorialString","STEP_ONE","convertLinearToEquation","l","a","b","c","d","e","convertEquationToLineType","convertLineTypeToEquation","MIN","MAX","getRandomValue","min","max","Math","floor","random","getRandomPointInEquation","equation","tempX","x","y","centerPoint","radius","sqrt","randomValueX","solvedValueY","calculateQuadraticEquation","secondRoot","firstRoot","generatePointAlignmentInside","firstPoint","secondPoint","getLineFromTwoPoints","generatePointAlignmentOutside","isRight","arguments","undefined","tempXRight","tempXLeft","ErrorCode","200","300","301","400","401","500","501","502","ErrorService","message","code","errorRelation","index","dataViewModel","inputData","filter","data","executedInputIndex","executingRelation","RelationsInput","status","alert","console","error","distance","p1","p2","distanceSquared","dx","dy","_makeRound","num","f","isNaN","myF","pow","round","calculateVector","calculateMiddlePoint","calculateSymmetricalPoint","directionVector","normalVector","calculateDistanceTwoPoints","squareX","squareY","calculateDistanceFromPointToLine","numerator","abs","denominator","calculateParallelLineByPointAndLine","lineEquation","parLine","result","calculatePerpendicularLineByPointAndLine","perpendicularLine","perLine","calculateIntersectionByLineAndLine","lineOne","lineTwo","calculateSetOfEquationTypeAndQuadraticEquation","calculateCircleEquationByCenterPoint","roundedRadius","calculateInternalBisectLineEquation","pointOne","pointTwo","results","_calculateBisectLineEquation","firstLine","secondLine","getAngleFromTwoLines","set","_getInternalBisectLineEquation","calculateExternalBisectLineEquation","internalLine","JSON","stringify","resultOne","resultTwo","coefficient","calculateIntersectionEquationTypeWithCircleEquation","q","A","B","delta","isIn","p","C","D","E","F","G","H","root","r1","r2","calculateIntersectionTwoCircleEquations","firstEquation","secondEquation","q1","q2","d1","d2","tempY","calculateSetOfEquationTypes","Z","_D","_E","_G","roots","calculateLinesByAnotherLineAndAngle","rootPoint","staticPoint","dynamicPoint","equations","cosine","cos","PI","_calculateLinesByAnotherLineAndAngle","map","newRootPoint","i","vectorOne","vectorTwo","staticVector","dynamicVector","acos","calculateIntegratedDirection","calculateVectorLength","parseInt","showError","vector","makeRoundCoordinate","log","a1","a2","b1","b2","getMiddlePointFromThreePointsInALine","p3","dis_p1_p2","dis_p2_p3","dis_p1_p3","calculateTangentEquation","tangentPoint","tangentEquation","isTwoEquationEqual","equationOne","equationTwo","isIsosceles","isNumber","isObjectLike","getTag","isQuadraticEquation","toString","call","checkFormatString","str","split","forEach","element","char","toLowerCase","defineObject","slice","includes","validateObject","validateValue","type","_validateName","validateType","validateGeometryType","key","validateAngle","checkObjectRelationship","obj1","obj2","check","toConsumableArray","Set","indexOf","string","item","array","validateInformation","info","outputType","keys","validateShapeFormat","validateShapeType","shapeFormatCheck","shapeTypeCheck","validateShape","j","indexOfRankingLevel","indexOfObjectCurrentLevel","indexOfObjectNextLevel","validateDataRelationship","defineInformation","splitter","shapeName","pop","otherData","replace","trim","join","defineShapeType","definePointType","reverse","sortString","toUpperCase","sort","Error","geometricObj","name","z","updateCoordinate","distance_From_A_To_B","linearEquation","coefficientX","constantTerm","p4","table","distanceX","p4X","readRelation","equationResults","operation","objectType","valueData","objectsIncludePoint","getNodeInPointsMapById","coordinate","staticValue","staticObject","angleName","angleValue","modifiedAngleName","shapeList","getData","shapes","shapeData","getShapeAffectList","concat","secondLineVector","firstVector","secondVector","renameAngle","changedPoint","calculatedEquation","intersectPoint","transitionVector","rootOne","rootTwo","replaceSetOfEquation","calculateLineEquationByAngleRelation","staticPointOne","staticPointTwo","isStaticNodeById","staticLineEquation","staticDistance","isAlign","coefficientY","ratio","calculatedPoint","betweenPoint","analyzeOperationType","segmentIncludePoint","segmentNotIncludePoint","relationType","getCircleEquation","otherStaticPoint","otherStaticNodeInSegment","points","getAdditionSegment","isValidCoordinate","generatePointMiddleTwoPoints","calculatedLineEquation","isInStaticLine","pushAdditionSegment","isExternal","analyzeRelationType","calculatedLineEquationOne","calculatedLineEquationTwo","analyzeIntersectRelation","otherPointInSegment","tangentPointCoordinate","circleEquation","exceptionPoint","center","calculateTangentIntersectPointsByPointOutsideCircle","filterRoots","isCoordinateDuplicated","filterTangentPoint","analyzeTangentRelation","count","limit","executeRelations","node","dependentNodes","temp","_makeUniqueNodeRelation","relationEquation","calculateInCircleEquation","calculateCircumCircleEquation","escribedPoint","otherPoints","calculateEscribedCirclesEquation","circlesData","ErrorMessage","isExecutedRelation","generateFunc","generateGeometry","pointCoordinate","rootCoordinate","getPointDirectionMap","isUp","makeCorrectShape","id","Array","isArray","executePointDetails","getExecutedRelations","rules","executePoint","staticPointCountRequire","staticPoints","arrayRules","RegExp","executePointIndex","nodeSetEquations","rule","staticLine","nonStaticLine","getLinearEquationByParallelRule","getLinearEquationByPerpendicularRule","includeLine","nonIncludeLine","staticLines","shapePoints","staticPointIndex","pointIndex","calculatedCoordinate","otherPointInIncludeLine","nonStaticPointIndex","updateCoordinateBySpecialPerpendicularRule","otherPoint","getLinearEquationsByEqualRule","RelationPointsMap","analyzeResult","validatedResult","objectPointsMap","sortPriority","getPointsMap","shouldStaticPoint","angles","getRelationsResult","relations","shapePointCount","minCountPoint","getFirstStaticPointInShape","createNode","updateMap","createPointsMapByShape","lastObjectPoints","objectName","createDependentNodeOfObject","nodeOne","nodeTwo","index1","findIndexByNodeId","index2","lastNode","nodeIndex","isStatic","getDependentObject","currentNode","objectSpread","createDependentNodeOfRelation","createPointsMapByRelation","setPointsMap","unique","createPointDetails","isPointsMapStatic","executingNode","getNextExecuteNode","getPointDetails","has","get","isNeedRandomCoordinate","nodeDirectionInfo","staticPointCoordinate","coordinateMatch","directionInfo","matchCount","getExecutedNode","updateStaticNode","readPointsMap","segments","getShapeSegments","getArraySegments","el1","el2","exception","_dependentNodes","oldNode","RelationInputModel","initializerDefineProperty","_descriptor","_descriptor2","observable","DataViewModel","_this","DataViewModel_descriptor","DataViewModel_descriptor2","_descriptor3","pointId","nodeId","getIndexOfNodeInPointsMapById","_coordinate","isStaticNode","updatePointsMap","clonePointsMap","sortNodeByPriority","staticNodeOneCount","getDependentStaticNodeCount","nodeOneData","static","nonStatic","dependence","minRelationIndex","getMinIndexOfDependentNodeInRelationsList","getIndexOfNodeInPointsMap","staticNodeTwoCount","nodeTwoData","rankOne","rankTwo","indexArray","getIndexOfRelationInRelationsList","apply","list","_calculateSet","relationsInput","input","newRelationInput","resetInputsStatus","splice","_this2","_updatePointDetails","setOfEquation","exceptedCoordinates","searchEquation","replaceEquation","pointDetail","isReplaceComplete","pointDetails","sum","isFirst","newSetOfEquation","currentRoots","finalRoots","_this3","_string","isMatching","preProgress","sentence","getBasicInformation","_defineSentence","others","params","start","end","param","lastParam","getLength","dictionary","centerId","_this4","stringifyCoordinate","_this5","getInformation","setRelationsResult","computed","action","KEYCODE","BACKSPACE","ENTER","InputItem","props","possibleConstructorReturn","getPrototypeOf","inputRef","React","state","shouldRemove","isEmpty","current","focus","currentTarget","onValueChange","setState","_this$props","onBackspace","onSubmit","keyCode","_this$props2","react","className","Icon_Icon","width","height","color","ref","onChange","onKeyUp","aria-describedby","autobind","iconList","inputSuccess","svg","react_default","createElement","fill","viewBox","inputError","inputNormal","icInformation","icRemove","icEdit","icAdd","fillRule","clipRule","Icon","icon","SegmentSetting","visible","isEditMode","isCreateMode","isMouseHoverEdition","isMouseHoverDeletion","_this$state","onDone","onDelete","onVisibleChange","dropdownIndex","filterValue","filterValueIndex","_this$state2","newStartValue","getIndexInData","_this$state3","onSelect","DropdownButton","title","Dropdown","Item","eventKey","_this$state4","renderDropdown","onStartPointSelect","onEndPointSelect","Button","onClick","onChangeContentState","variant","disabled","_this$props$value","dist_default","onstyle","offstyle","handleClassName","off","on","active","onMouseLeave","mouseLeaveEdition","onMouseOver","mouseHoverEdition","onMouseDown","mouseHoverDeletion","mouseLeaveDeletion","renderEditContent","renderShowContent","style","_this$state5","renderContent","Geom","Point","free","esm_get","prototype","Circle","_fromCenterAndBoundaryPoint","_fromCenterAndRadius","defineProperties","radiussq","boundaryPoint","w","h","Line","_p","_clip","assertThisInitialized","theta","atan2","m","left","top","bottom","P","Segment","lengthsq","bounds","_line$_p","slicedToArray","t","clipped","parent","comparePoints","sq","between","intersect","o1","o2","c1","c2","dsq","dd","cx","cy","nx","ny","uniq","intersectCircleCircle","intersectCircleLine","intersectLineLine","constructor","s1","s2","clip","_s1$_p","_s1$_p$","x1","y1","_s1$_p$2","_s2$_p","_s2$_p$","x3","y3","_s2$_p$2","s","_s$_p","_s$_p$","_s$_p$2","x2","y2","_c$center","x0","y0","Dsq","lensq","disc","Intersection","_len","objects","_key","shift","which","test","_result","verbose","pstr","o","addClass","obj","klass","classes","d3","add","Scene","threshold","_last","_objects","equal","every","values","secondObj","id1","id2","tag","_currentTag","existing","prop","find","freeName","update","label","time","Date","klasses","init","renderGeometry","scene","svgElement","circles","selectAll","circleGroup","enter","append","attr","exit","remove","lines","lineGroup","endpoint","coord","DrawingPanel","drawingData","document","getElementById","firstChild","pointElements","baseVal","arrX","arrY","disparityX","disparityY","anchorX","anchorY","_groups","__data__","appendChild","createTextNode","renderPoints","MainView","observer","inputRefs","focusIndex","drawingSegments","scrollView","createRef","trimDrawingData","setTimeout","scrollIntoView","pointData","segmentsData","removeSegments","uniqueSegmentData","segmentData","replaceIndex","addNewInput","removeInput","analyzeInput","model","components_InputItem_InputItem","isAddSegment","onDeleteSegmentSetting","scrollToBottom","prevState","_this6","components_SegmentSetting_SegmentSetting","onDoneSegmentSetting","onChangeSegmentSetting","marginTop","data-toggle","data-target","aria-expanded","aria-controls","OverlayTrigger","container","placement","overlay","Tooltip","aria-labelledby","data-parent","renderRelationInput","onClickDrawing","isInputEmpty","renderSegmentSettings","addNewSegmentSetting","components_DrawingPanel_DrawingPanel","Component","ReactDOM","render","View_MainView","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.32d7ccb0.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","// @flow\r\n\r\nclass AppData {\r\n  constructor() {\r\n    this.additionSegment = [];\r\n    this.relationsResult = {};\r\n    this.pointsMap = [];\r\n    this.pointsDirectionMap = {};\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__ = new Map();\r\n  }\r\n\r\n  clear() {\r\n    this.relationsResult = [];\r\n    this.pointsMap = [];\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__.clear();\r\n  }\r\n\r\n  set setRelationsResult(value) {\r\n    this.relationsResult = value;\r\n  }\r\n\r\n  pushAdditionSegment(segment: string) {\r\n    this.additionSegment.push(segment);\r\n  }\r\n\r\n  get getAdditionSegment() {\r\n    return this.additionSegment;\r\n  }\r\n\r\n  get getRelationsResult() {\r\n    return this.relationsResult;\r\n  }\r\n\r\n  get getPointsMap() {\r\n    return this.pointsMap;\r\n  }\r\n\r\n  setPointsMap(newPointsMap) {\r\n    this.pointsMap = newPointsMap;\r\n  }\r\n\r\n  get getPointDirectionMap() {\r\n    return this.pointsDirectionMap;\r\n  }\r\n\r\n  get getExecutedRelations() {\r\n    return this.executedRelations;\r\n  }\r\n\r\n  get getExecutedNode() {\r\n    return this.executedNode;\r\n  }\r\n\r\n  get getPointDetails() {\r\n    return this.__pointDetails__;\r\n  }\r\n}\r\n\r\nconst appData = new AppData();\r\n\r\nexport default appData;\r\n","const defineSentences = {\r\n  define: [\r\n    '{object} + {object} = {object}',\r\n    '{object} - {object} = {object}',\r\n    '{object} = {value} * {object}',\r\n    '{object} = {object}',\r\n    '{object} > {object}',\r\n    '{object} < {object}'\r\n  ],\r\n  relation: [\r\n    '{object} song song {object}',\r\n    '{object} vuông góc {object}',\r\n    '{object} cắt {object} tại {arrayPoints}',\r\n    '{object} phân giác ngoài {angle}',\r\n    '{object} phân giác trong {angle}',\r\n    '{object} phân giác {angle}',\r\n    '{arrayPoints} thẳng hàng',\r\n    '{point} trung điểm {segment}',\r\n    '{point} không thuộc {object}',\r\n    '{point} thuộc {object}',\r\n    'trung tuyến {segment} của {triangle}',\r\n    'đường cao {segment} của {triangle}',\r\n    '{segment} tiếp tuyến {circle}'\r\n  ],\r\n  shape: [\r\n    'tam giác {type triangle}',\r\n    'tứ giác {quadrilateral}',\r\n    'hình thang {type trapezoid}',\r\n    'hình bình hành {parallelogram}',\r\n    'hình chữ nhật {rectangle}',\r\n    'hình thoi {rhombus}',\r\n    'hình vuông {square}',\r\n    '{object type triangle} tại {escribedPoint}',\r\n    '{object type triangle}'\r\n  ]\r\n};\r\n\r\nconst shapeList = ['triangle', 'quadrilateral', 'trapezoid', 'parallelogram', 'rectangle', 'rhombus', 'square'];\r\n\r\nconst reversedDependentObjRelation = ['vuông góc', 'cắt'];\r\n\r\nconst RankingObjectContain = [['point'], ['segment', 'ray'], ['angle']];\r\n\r\nconst objectWithPoint = ['angle', 'segment', 'ray', 'point', 'circle'];\r\n\r\nconst validate = {\r\n  object: {\r\n    define: ['angle', 'segment'],\r\n    relation: ['ray', 'line', 'segment', 'circle']\r\n  },\r\n  point: { length: 1, format: '1' },\r\n  segment: { length: 2, format: '11' },\r\n  ray: { length: 2, format: '10' },\r\n  line: { length: 1, format: '0' },\r\n  angle: { length: 3 },\r\n  shape: {\r\n    triangle: { length: 3, format: '111' },\r\n    quadrilateral: { length: 4, format: '1111' },\r\n    trapezoid: { length: 4, format: '1111' },\r\n    parallelogram: { length: 4, format: '1111' },\r\n    rectangle: { length: 4, format: '1111' },\r\n    rhombus: { length: 4, format: '1111' },\r\n    square: { length: 4, format: '1111' },\r\n    circle: { length: 1, format: '1' }\r\n  },\r\n  shapeType: {\r\n    triangle: ['', 'vuông', 'cân', 'vuông cân', 'đều', 'nội tiếp', 'ngoại tiếp', 'bàng tiếp'],\r\n    trapezoid: ['', 'vuông', 'cân']\r\n  }\r\n};\r\n\r\n/*\r\n    | song song,\r\n    ^ vuông góc,\r\n    = cân\r\n */\r\nconst shapeRules = {\r\n  triangle: {\r\n    right: '01^02', // Ex: AB vuong goc AC\r\n    isosceles: '01=02',\r\n    right_isosceles: '01^02&01=02',\r\n    equilateral: '01=02&01=12&02=12'\r\n  },\r\n  trapezoid: {\r\n    normal: '01|23',\r\n    right: '01|23&01^03',\r\n    isosceles: '01|23&03=12'\r\n  },\r\n  parallelogram: {\r\n    normal: '01|23&03|12'\r\n  },\r\n  rectangle: {\r\n    normal: '01^12&12^23&23^30&30^01'\r\n  },\r\n  rhombus: {\r\n    normal: '02^13'\r\n  },\r\n  square: {\r\n    normal: '01|23&03|12&01^12&12^23&23^03&01=03&&01=12&12=23&&23=03'\r\n  }\r\n};\r\n\r\nconst mappingShapeType = {\r\n  vuông: 'right',\r\n  cân: 'isosceles',\r\n  'vuông cân': 'right_isosceles',\r\n  đều: 'equilateral',\r\n  'nội tiếp': 'nội tiếp',\r\n  'ngoại tiếp': 'ngoại tiếp',\r\n  'bàng tiếp': 'bàng tiếp'\r\n};\r\n\r\nconst circleType = ['nội tiếp', 'ngoại tiếp', 'bàng tiếp'];\r\n\r\nconst TwoStaticPointRequireShape = ['triangle', 'trapezoid', 'rectangle', 'square'];\r\n\r\nconst ShapeAffectBySegmentChange = ['rhombus', 'trapezoid', 'parallelogram'];\r\n\r\nexport {\r\n  validate,\r\n  TwoStaticPointRequireShape,\r\n  defineSentences,\r\n  RankingObjectContain,\r\n  objectWithPoint,\r\n  shapeList,\r\n  reversedDependentObjRelation,\r\n  shapeRules,\r\n  mappingShapeType,\r\n  circleType,\r\n  ShapeAffectBySegmentChange\r\n};\r\n","const Number = Object.freeze({\r\n  MIN_RANDOM_NUMBER: -10,\r\n  MAX_RANDOM_NUMBER: 10,\r\n  MIN_RANDOM_GENERATION: 5,\r\n  MAX_RANDOM_GENERATION: 15,\r\n  NOT_FOUND: 99\r\n});\r\n\r\nconst String = Object.freeze({\r\n  INFINITY: 'vô cực',\r\n  IMPOSSIBLE: 'vô nghiệm',\r\n  TOO_SHORT: 'quá ngắn',\r\n  NOT_ENOUGH_SET: 'không đủ phương trình tạo thành hệ',\r\n  NOT_BE_IN_LINE: 'điểm không thuộc đường'\r\n});\r\n\r\nconst Regex = Object.freeze({\r\n  KEY: '[^{\\\\}]+(?=})',\r\n  OTHER: '(^([^{]+(?={)))|((?<=})([^{]+)(?={))|(((?<=})[^}]+)$)'\r\n});\r\n\r\nconst Others = Object.freeze({\r\n  OPERATIONS: ['+', '-', '*', '<', '>', '=']\r\n});\r\n\r\nconst Errors = Object.freeze({\r\n  UNDEFINED_ERROR: 'Lỗi không xác dịnh',\r\n  WRONG_FORMAT: 'Sai định dạng',\r\n  MAXIMUM_POINT_ERROR: 'Tối đa 3 điểm thẳng háng'\r\n});\r\n\r\nconst InputStatus = Object.freeze({\r\n  SUCCESS: 'Success',\r\n  NORMAL: `Normal`,\r\n  ERROR: 'Error'\r\n});\r\nconst TutorialString = {\r\n  STEP_ONE: `\r\n  Danh sách các mẫu câu dặc trưng:\r\n    \\n__ = __\r\n    \\n__ song song/vuông góc __\r\n    \\n__ cắt __ tại __\r\n    \\n__ phân giác __\r\n    \\n__ thẳng hàng\r\n    \\n__ trung điểm __\r\n    \\n__ thuộc/không thuộc __\r\n    \\n__ tiếp tuyến (__)\r\n    \\ntam giác {loại} __\r\n    \\ntứ giác __\r\n    \\nđường tròn tâm __ ngoại tiếp/nội tiếp __\r\n\\nLưu ý:\r\n  \\n Đường tròn trong cái mối quan hệ khác sẽ nằm trong ()\r\n  \\n  Vd: AB tiếp tuyến (O)\r\n  `\r\n};\r\nconst GConst = {\r\n  Number,\r\n  String,\r\n  Regex,\r\n  Others,\r\n  Errors,\r\n  InputStatus,\r\n  TutorialString\r\n};\r\n\r\nexport default GConst;\r\n","import type { EquationType, LineType } from '../../utils/types';\r\n\r\nexport function convertLinearToEquation(l: EquationType): EquationType {\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: l.c,\r\n    d: l.d,\r\n    e: l.e\r\n  };\r\n}\r\n\r\nexport function convertEquationToLineType(line: EquationType): LineType {\r\n  return {\r\n    a: -line.c / (line.d === 0 ? 1 : line.d),\r\n    b: -line.e / (line.d === 0 ? 1 : line.d)\r\n  };\r\n}\r\n\r\nexport function convertLineTypeToEquation(line: LineType): EquationType {\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: -line.a,\r\n    d: 1,\r\n    e: -line.b\r\n  };\r\n}\r\n\r\n","// @flow\r\n\r\nimport GConst from '../../utils/values';\r\nimport type { CoordinateType, EquationType } from '../../utils/types';\r\nimport { calculateQuadraticEquation, getLineFromTwoPoints, calculatePerpendicularLineByPointAndLine } from './Math2D';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\n\r\nexport function getStartPoint(): CoordinateType {\r\n  return { x: 0, y: 0, z: 0 };\r\n}\r\n\r\nexport function getRandomValue(min: number, max: number): number {\r\n  if (max < min) {\r\n    return min;\r\n  }\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function getRandomPointInEquation(equation: EquationType): CoordinateType {\r\n  if (!equation.a) {\r\n    equation.a = 0;\r\n  }\r\n  if (!equation.b) {\r\n    equation.b = 0;\r\n  }\r\n  if (equation.a === 0 && equation.b === 0) {\r\n    if (equation.d !== 0) {\r\n      const tempX = getRandomValue(MIN, MAX);\r\n      return {\r\n        x: tempX,\r\n        y: (-equation.e - equation.c * tempX) / equation.d\r\n      };\r\n    } else {\r\n      return {\r\n        x: -equation.e / equation.c,\r\n        y: getRandomValue(MIN, MAX)\r\n      };\r\n    }\r\n  } else if (equation.a === 1 && equation.b === 1) {\r\n    const centerPoint = {\r\n      a: equation.c / -2,\r\n      b: equation.d / -2\r\n    };\r\n\r\n    const radius = Math.sqrt(centerPoint.a * centerPoint.a + centerPoint.b * centerPoint.b - equation.e);\r\n\r\n    const randomValueX = getRandomValue(centerPoint.a - radius, centerPoint.a + radius);\r\n\r\n    const solvedValueY = calculateQuadraticEquation(\r\n      equation.b,\r\n      equation.d,\r\n      randomValueX * randomValueX + equation.c * randomValueX + equation.e\r\n    );\r\n\r\n    if (typeof solvedValueY === 'number') {\r\n      return { x: randomValueX, y: solvedValueY };\r\n    } else if (typeof solvedValueY === 'object') {\r\n      return { x: randomValueX, y: solvedValueY.secondRoot || solvedValueY.firstRoot };\r\n    }\r\n  }\r\n}\r\n\r\nexport function generatePointAlignmentInside(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  const tempX = (firstPoint.x + secondPoint.x) / getRandomValue(2, 5);\r\n  return {\r\n    x: tempX,\r\n    y: (line.c * tempX + line.e) / -line.d\r\n  };\r\n}\r\n\r\nexport function generatePointAlignmentOutside(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true\r\n): CoordinateType {\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  const tempXRight = getRandomValue(secondPoint.x, MAX);\r\n  const tempXLeft = getRandomValue(MIN, firstPoint.x);\r\n  return isRight\r\n    ? {\r\n        x: tempXRight,\r\n        y: (line.c * tempXRight + line.e) / -line.d\r\n      }\r\n    : {\r\n        x: tempXLeft,\r\n        y: (line.c * tempXLeft + line.e) / -line.d\r\n      };\r\n}\r\n\r\nexport function generatePointNotAlignment(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  let resultPoint: CoordinateType = {};\r\n  resultPoint.x = getRandomValue(MIN, MAX);\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  do {\r\n    resultPoint.y = getRandomValue(MIN, MAX);\r\n  } while (resultPoint.y === line.c * resultPoint.x + line.e);\r\n  return resultPoint;\r\n}\r\n\r\nexport function generatePointMiddleTwoPoints(p1: CoordinateType, p2: CoordinateType) {\r\n  const line = getLineFromTwoPoints(p1, p2);\r\n  const randomPoint = generatePointAlignmentInside(p1, p2);\r\n\r\n  const randomLine = calculatePerpendicularLineByPointAndLine(randomPoint, line);\r\n  return getRandomPointInEquation(randomLine);\r\n}\r\n","// @flow\r\n\r\nimport GConst from './values';\r\nimport dataViewModel from '../ViewModel/DataViewModel';\r\n\r\nconst ErrorCode = {\r\n  200: GConst.Errors.UNDEFINED_ERROR,\r\n  300: GConst.Errors.WRONG_FORMAT,\r\n  301: GConst.Errors.MAXIMUM_POINT_ERROR,\r\n  400: GConst.String.IMPOSSIBLE,\r\n  401: GConst.String.INFINITY,\r\n  500: GConst.String.NOT_BE_IN_LINE,\r\n  501: GConst.String.NOT_ENOUGH_SET,\r\n  502: GConst.String.TOO_SHORT\r\n};\r\n\r\nclass ErrorHandleService {\r\n  message: string = '';\r\n\r\n  get ErrorMessage() {\r\n    return this.message;\r\n  }\r\n\r\n  showError(code: string, errorRelation?: mixed) {\r\n    let index;\r\n    if (errorRelation) {\r\n      index = dataViewModel.inputData.filter((data: mixed): boolean => data === errorRelation)[0];\r\n    } else {\r\n      switch (code) {\r\n        case 300:\r\n        case 301:\r\n          index = dataViewModel.executedInputIndex;\r\n          break;\r\n        default:\r\n          index = dataViewModel.inputData.filter((data: mixed): boolean => data === dataViewModel.executingRelation)[0];\r\n      }\r\n    }\r\n    if (index >= 0) {\r\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\r\n    }\r\n\r\n    alert(ErrorCode[code]);\r\n    throw console.error('error', ErrorCode[code]);\r\n  }\r\n}\r\n\r\nconst ErrorService = new ErrorHandleService();\r\n\r\nexport default ErrorService;\r\n","export { distance, distanceSquared };\r\n\r\n/* returns the Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distance(p1, p2) {\r\n  return Math.sqrt(distanceSquared(p1, p2));\r\n}\r\n\r\n/* returns the squared Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distanceSquared(p1, p2) {\r\n  let dx = p1.x - p2.x,\r\n    dy = p1.y - p2.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n","import GConst from '../../utils/values';\r\nimport type {\r\n  CircleType,\r\n  CoordinateType,\r\n  EquationType,\r\n  LineType,\r\n} from '../../utils/types';\r\nimport {\r\n  convertEquationToLineType,\r\n  convertLinearToEquation,\r\n  convertLineTypeToEquation,\r\n} from './Converter';\r\nimport { getRandomPointInEquation } from './Generation';\r\nimport ErrorService from '../../utils/ErrorHandleService';\r\nimport { distance } from '../../vendor/euclid/calc';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\nconst INFINITY = GConst.String.INFINITY;\r\nconst IMPOSSIBLE = GConst.String.IMPOSSIBLE;\r\nconst NOT_BE_IN_LINE = GConst.String.NOT_BE_IN_LINE;\r\n\r\nfunction _makeRound(num: number, f: number = 3): number {\r\n  if (isNaN(num)) {\r\n    throw console.error('error', num);\r\n  }\r\n  const myF = Math.pow(10, f);\r\n  return Math.round(num * myF) / myF;\r\n}\r\n\r\nexport function calculateVector(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isMakeRound? = true,\r\n): CoordinateType {\r\n  if (isMakeRound) {\r\n    return {\r\n      x: _makeRound(secondPoint.x - firstPoint.x),\r\n      y: _makeRound(secondPoint.y - firstPoint.y),\r\n    };\r\n  }\r\n  return {\r\n    x: secondPoint.x - firstPoint.x,\r\n    y: secondPoint.y - firstPoint.y,\r\n  };\r\n}\r\n\r\nexport function isVectorSameDirection(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (firstVector.x === 0) {\r\n    return (\r\n      secondVector.x === 0 && firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y)\r\n    );\r\n  }\r\n\r\n  if (firstVector.y === 0) {\r\n    return (\r\n      secondVector.y === 0 && firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x)\r\n    );\r\n  }\r\n\r\n  if (secondVector.x === 0) {\r\n    return firstVector.x === 0 && firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y);\r\n  }\r\n\r\n  if (secondVector.y === 0) {\r\n    return firstVector.y === 0 && firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x);\r\n  }\r\n\r\n  return (\r\n    firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x) &&\r\n    firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y) &&\r\n    _makeRound(firstVector.x * secondVector.y) === _makeRound(firstVector.y * secondVector.x)\r\n  );\r\n}\r\n\r\nexport function isVectorInSameLine(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (firstVector.x === 0) {\r\n    return secondVector.x === 0;\r\n  }\r\n\r\n  if (firstVector.y === 0) {\r\n    return secondVector.y === 0;\r\n  }\r\n\r\n  if (secondVector.x === 0) {\r\n    return firstVector.x === 0;\r\n  }\r\n\r\n  if (secondVector.y === 0) {\r\n    return firstVector.y === 0;\r\n  }\r\n\r\n  return _makeRound(firstVector.x * secondVector.y) === _makeRound(firstVector.y * secondVector.x);\r\n}\r\n\r\nexport function calculateMiddlePoint(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  return {\r\n    x: (firstPoint.x + secondPoint.x) / 2,\r\n    y: (firstPoint.y + secondPoint.y) / 2,\r\n  };\r\n}\r\n\r\nexport function calculateSymmetricalPoint(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true,\r\n): CoordinateType {\r\n  return isRight\r\n    ?\r\n    {\r\n      x: 2 * secondPoint.x - firstPoint.x,\r\n      y: 2 * secondPoint.y - firstPoint.y,\r\n    }\r\n    :\r\n    {\r\n      x: 2 * firstPoint.x - secondPoint.x,\r\n      y: 2 * firstPoint.y - secondPoint.y,\r\n    };\r\n}\r\n\r\nexport function getLineFromTwoPoints(p1: CoordinateType, p2: CoordinateType): EquationType {\r\n  const directionVector = {\r\n    a: p2.x - p1.x,\r\n    b: p2.y - p1.y,\r\n  };\r\n  const normalVector = {\r\n    a: -directionVector.b,\r\n    b: directionVector.a,\r\n  };\r\n\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: normalVector.a,\r\n    d: normalVector.b,\r\n    e: -normalVector.a * p1.x - normalVector.b * p1.y,\r\n  };\r\n}\r\n\r\nexport function calculateParallelEquation(equation: EquationType): EquationType {\r\n  // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n  const e = Math.floor(Math.random() * 100) - MAX;\r\n\r\n  let parallelEquation: EquationType = {coefficientZ: 0};\r\n  parallelEquation.c = equation.c;\r\n  parallelEquation.d = equation.d;\r\n  parallelEquation.e = e;\r\n\r\n  return parallelEquation;\r\n}\r\n\r\nexport function calculatePerpendicularEquation(equation: EquationType): EquationType {\r\n  // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n  const e = Math.floor(Math.random() * 100) - MIN;\r\n\r\n  let perpendicularEquation: EquationType = {coefficientZ: 0};\r\n  perpendicularEquation.c = -equation.c;\r\n  perpendicularEquation.d = equation.d;\r\n  perpendicularEquation.e = e;\r\n\r\n  return perpendicularEquation;\r\n}\r\n\r\nexport function calculateDistanceTwoPoints(firstPoint: CoordinateType, secondPoint: CoordinateType): number {\r\n  const squareX = (secondPoint.x - firstPoint.x) * (secondPoint.x - firstPoint.x);\r\n  const squareY = (secondPoint.y - firstPoint.y) * (secondPoint.y - firstPoint.y);\r\n\r\n  return Math.sqrt(squareX + squareY);\r\n}\r\n\r\nexport function calculateDistanceFromPointToLine(point: CoordinateType, line: EquationType): number {\r\n  let numerator = Math.abs(line.c * point.x + line.d * point.y + line.e);\r\n  let denominator = Math.sqrt(line.c * line.c + line.d * line.d);\r\n\r\n  if (denominator === 0) {\r\n    return INFINITY;\r\n  }\r\n  return numerator / denominator;\r\n}\r\n\r\nexport function calculateParallelLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  // parallel line has `a` coefficient equals the other line.\r\n  // parallel line's e = -ax - y with (x,y) is coordinate of the point\r\n  const lineEquation = convertEquationToLineType(line);\r\n  const parLine: LineType = {};\r\n  parLine.a = lineEquation.a;\r\n  parLine.b = point.y - lineEquation.a * point.x;\r\n\r\n  let result = convertLineTypeToEquation(parLine);\r\n  if (line.d === 0) {\r\n    result.d = line.d;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function calculatePerpendicularLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  let perpendicularLine: EquationType = {};\r\n\r\n  // perpendicular line has the direction vector is opposite pairs with the other line.\r\n  // perpendicular line's e = -ax - y with (x,y) is coordinate of the point\r\n  if (line.c === 0) {\r\n    perpendicularLine.c = -1 / line.d;\r\n    perpendicularLine.d = 0;\r\n    perpendicularLine.e = -perpendicularLine.c * point.x;\r\n  }\r\n  else if (line.d === 0) {\r\n    perpendicularLine.c = 0;\r\n    perpendicularLine.d = -1 / line.c;\r\n    perpendicularLine.e = -perpendicularLine.d * point.y;\r\n  }\r\n  else {\r\n    const lineEquation = convertEquationToLineType(line);\r\n    const perLine: LineType = {};\r\n    perLine.a = -1 / lineEquation.a;\r\n    perLine.b = point.y + point.x / lineEquation.a;\r\n\r\n    perpendicularLine = convertLineTypeToEquation(perLine);\r\n  }\r\n\r\n  return perpendicularLine;\r\n}\r\n\r\nexport function calculateIntersectionByLineAndLine(lineOne: EquationType, lineTwo: EquationType): CoordinateType {\r\n  return calculateSetOfEquationTypeAndQuadraticEquation(\r\n    {\r\n      c: lineOne.c,\r\n      d: lineOne.d,\r\n      e: lineOne.e,\r\n    },\r\n    {\r\n      a: 0,\r\n      b: 0,\r\n      c: lineTwo.c,\r\n      d: lineTwo.d,\r\n      e: lineTwo.e,\r\n    },\r\n  )[0];\r\n}\r\n\r\nexport function calculateCircleEquationByCenterPoint(\r\n  centerPoint: CoordinateType,\r\n  radius: number,\r\n): TwoVariableQuadraticEquation {\r\n  const roundedRadius = _makeRound(radius, 6);\r\n  return {\r\n    a: 1,\r\n    b: 1,\r\n    c: -2 * centerPoint.x,\r\n    d: -2 * centerPoint.y,\r\n    e: centerPoint.x * centerPoint.x + centerPoint.y * centerPoint.y - roundedRadius * roundedRadius,\r\n  };\r\n}\r\n\r\nexport function calculateInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType,\r\n): EquationType {\r\n  const results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n  const firstLine: EquationType = results[0];\r\n  const secondLine: EquationType = results[1];\r\n\r\n  // const pointInFirstLine: CoordinateType = getRandomPointInLine(lineOne);\r\n  // let pointInSecondLine: CoordinateType = { x: pointInFirstLine.x, y: undefined };\r\n  // if (lineTwo.d !== 0) {\r\n  //   pointInSecondLine.y = (-lineTwo.e - lineTwo.c * pointInSecondLine.x) / lineTwo.d;\r\n  // } else {\r\n  //   pointInSecondLine.y = getRandomValue(MIN_RANDOM_NUMBER, MAX_RANDOM_NUMBER);\r\n  // }\r\n\r\n  if (getAngleFromTwoLines(lineOne, lineTwo) === 0) {\r\n    throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n  }\r\n\r\n  return _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n}\r\n\r\nexport function calculateExternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType,\r\n): EquationType {\r\n  let results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n  const firstLine: EquationType = results[0];\r\n  const secondLine: EquationType = results[1];\r\n\r\n  if (getAngleFromTwoLines(lineOne, lineTwo) === 0) {\r\n    throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n  }\r\n\r\n  const internalLine = _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n\r\n  results = results.filter((line: EquationType): boolean => JSON.stringify(line) !== JSON.stringify(internalLine));\r\n  return results[0];\r\n}\r\n\r\nfunction _calculateBisectLineEquation(lineOne: EquationType, lineTwo: EquationType): [EquationType, EquationType] {\r\n  let resultOne: EquationType = {};\r\n  let resultTwo: EquationType = {};\r\n\r\n  // ax + by + c = +/- [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')] * (a'x + b'y + c)\r\n\r\n  // check if denominator equals 0\r\n  if (lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d === 0) {\r\n    return;\r\n  }\r\n\r\n  // Represent for [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')]\r\n  let coefficient =\r\n    Math.sqrt(lineOne.c * lineOne.c + lineOne.d * lineOne.d) / Math.sqrt(lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d);\r\n\r\n  /*\r\n   * Two results:\r\n   *    (a - coefficient*a')x + (b - coefficient*b')y + c - coefficient*c' = 0\r\n   *    (a + coefficient*a')x + (b + coefficient*b')y + c + coefficient*c' = 0\r\n   */\r\n  resultOne.c = lineOne.c - coefficient * lineTwo.c;\r\n  resultOne.d = lineOne.d - coefficient * lineTwo.d;\r\n  resultOne.e = lineOne.e - coefficient * lineTwo.e;\r\n\r\n  resultTwo.c = lineOne.c + coefficient * lineTwo.c;\r\n  resultTwo.d = lineOne.d + coefficient * lineTwo.d;\r\n  resultTwo.e = lineOne.e + coefficient * lineTwo.e;\r\n\r\n  return [\r\n    resultOne,\r\n    resultTwo,\r\n  ];\r\n}\r\n\r\n/*\r\n *   Line one and line two is 2 lines are the result of _calculateBisectLineEquation function\r\n *   Point one and point two are 2 points that each point located in each line\r\n *             which is equivalent each argument in _calculateBisectLineEquation function\r\n */\r\nfunction _getInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType,\r\n): EquationType {\r\n  let firstEquation = pointOne.x * lineOne.c + pointOne.y * lineOne.d + lineOne.e;\r\n  let secondEquation = pointTwo.x * lineOne.c + pointTwo.y * lineOne.d + lineOne.e;\r\n  return firstEquation * secondEquation <= 0 ?\r\n    lineOne :\r\n    lineTwo;\r\n}\r\n\r\n// TODO: Uncheck\r\nexport function calculateSetOfEquationTypes(d1: EquationType, d2: EquationType) {\r\n  if (\r\n    (d1.c === 0 && d2.c === 0) ||\r\n    (d1.d === 0 && d2.d === 0) ||\r\n    (d1.c === 0 && d1.d === 0) ||\r\n    (d2.c === 0 && d2.d === 0)\r\n  ) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  if (d1.c === 0 && d2.d === 0) {\r\n    return {\r\n      x: -d2.e / d2.c,\r\n      y: -d1.e / d1.d,\r\n    };\r\n  }\r\n  if (d2.c === 0 && d1.d === 0) {\r\n    return {\r\n      x: -d1.e / d1.c,\r\n      y: -d2.e / d2.d,\r\n    };\r\n  }\r\n  if (d1.e === 0 && d2.e === 0) {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n    };\r\n  }\r\n\r\n  if (d1.c === 0) {\r\n    const tempY = -d1.e / d1.d;\r\n    return {\r\n      x: (-d2.e - tempY * d2.d) / d2.c,\r\n      y: tempY,\r\n    };\r\n  }\r\n\r\n  if (d1.d === 0) {\r\n    const tempX = -d1.e / d1.c;\r\n    return {\r\n      x: tempX,\r\n      y: (-d2.e - tempX * d2.c) / d2.d,\r\n    };\r\n  }\r\n\r\n  if (d2.c === 0) {\r\n    const tempY = -d2.e / d2.d;\r\n    return {\r\n      x: (-d1.e - tempY * d1.d) / d1.c,\r\n      y: tempY,\r\n    };\r\n  }\r\n\r\n  if (d2.d === 0) {\r\n    const tempX = -d2.e / d2.c;\r\n    return {\r\n      x: tempX,\r\n      y: (-d1.e - tempX * d1.c) / d1.d,\r\n    };\r\n  }\r\n  const tempY = (d1.e * d2.c - d1.c * d2.e) / (d1.d * d2.c - d1.c * d2.d);\r\n  return {\r\n    x: (-d1.e - d1.d * tempY) / d1.c,\r\n    y: tempY,\r\n  };\r\n}\r\n\r\n/*\r\n *  Find point(s) of intersection between a linear equation and a circle equation.\r\n *  @params:\r\n *        + d (EquationType): a line.\r\n *        + c (CircleEquation): a circle.\r\n *  @return:\r\n *        + IMPOSSIBLE: if distance from center point of the circle to the line is greater than the radius.\r\n *        + (Array<Object>): if the line intersects the circle.\r\n *          + length = 1;\r\n *          + length = 2;\r\n */\r\nexport function calculateIntersectionEquationTypeWithCircleEquation(d: EquationType, q: EquationType): Array<Object> {\r\n  const A = -q.c / 2;\r\n  const B = -q.d / 2;\r\n  const centerPoint: CoordinateType = {\r\n    x: A,\r\n    y: B,\r\n  };\r\n  const distanceFromCenterPointToLine = calculateDistanceFromPointToLine(centerPoint, d);\r\n\r\n  if (distanceFromCenterPointToLine > Math.sqrt(A * A + B * B - q.e)) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  else {\r\n    return calculateSetOfEquationTypeAndQuadraticEquation(d, q);\r\n  }\r\n}\r\n\r\n/*\r\n * Solves a quadratic equation. This equation is defined: Ax2 + Bx + C = 0.\r\n *\r\n *  @params:\r\n *        + a (number): represents x's coefficient.\r\n *        + b (number): represents y's coefficient.\r\n *        + c (number): represents constant term.\r\n * @return:\r\n *        + IMPOSSIBLE (string): if the equation is no root.\r\n *        + (number): if the equation has only ONE root.\r\n *        + x1, x2 (Object): if the equation has TWO root.\r\n */\r\nexport function calculateQuadraticEquation(a: number, b: number, c: number) {\r\n  const delta = b * b - 4 * a * c;\r\n\r\n  let firstRoot,\r\n    secondRoot: number = undefined;\r\n\r\n  if (a === 0) {\r\n    if (b === 0) {\r\n      return INFINITY;\r\n    }\r\n    return -c / b;\r\n  }\r\n  else if (delta < 0) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  else if (delta === 0) {\r\n    return -b / (2 * a);\r\n  }\r\n  else {\r\n    firstRoot = (-b + Math.sqrt(delta)) / (2 * a);\r\n    secondRoot = (-b - Math.sqrt(delta)) / (2 * a);\r\n    return {\r\n      firstRoot,\r\n      secondRoot,\r\n    };\r\n  }\r\n}\r\n\r\n// Ax2 + By2 + Cx + Dy + E = 0\r\nexport function isIn(p: CoordinateType, e: EquationType): boolean {\r\n  if (p.x === undefined || p.y === undefined) {\r\n    return false;\r\n  }\r\n  if (e.a === undefined) {\r\n    e = convertLinearToEquation(e);\r\n  }\r\n  const temp = e.a * p.x * p.x + e.b * p.y * p.y + e.c * p.x + e.d * p.y + e.e;\r\n  return _makeRound(temp) === 0;\r\n}\r\n\r\n/*\r\n *  Solves a set of a linear equation and quadratic equation.\r\n *  Linear equation is defined:     Ax + By + C = 0.\r\n *  Quadratic equation is defined:  Ax2 + By2 + Cx + Dy + E = 0.\r\n *\r\n *  @params:\r\n *        + l (EquationType): represents a linear equation.\r\n *        + q (QuadraticEquation): represents a quadratic equation.\r\n *  @return:\r\n *        + IMPOSSIBLE (string): if the set is no root.\r\n *        + (number): if the set has only ONE root.\r\n *        + x1, x2 (Object): if the set has TWO root.\r\n */\r\nexport function calculateSetOfEquationTypeAndQuadraticEquation(l: EquationType, q: EquationType): Array<Object> {\r\n  let results: Array<Object> = [];\r\n  let u, v, w;\r\n\r\n  const A = l.c;\r\n  const B = l.d;\r\n  const C = l.e;\r\n  const D = q.a;\r\n  const E = q.b;\r\n  const F = q.c;\r\n  const G = q.d;\r\n  const H = q.e;\r\n  if (A !== 0) {\r\n    u = A * A * E + D * B * B;\r\n    v = 2 * B * C * D - A * B * F + A * A * G;\r\n    w = D * C * C - A * C * F + A * A * H;\r\n\r\n    // solves x. Unneeded check IMPOSSIBLE.\r\n    const root = calculateQuadraticEquation(u, v, w);\r\n    if (typeof root === 'number') {\r\n      results.push({\r\n        x: (-C - B * root) / A,\r\n        y: root,\r\n      });\r\n    }\r\n    else if (root === IMPOSSIBLE) {\r\n      return root;\r\n    }\r\n    else {\r\n      const r1 = root.firstRoot;\r\n      const r2 = root.secondRoot;\r\n      results.push({\r\n        x: (-C - B * root.firstRoot) / A,\r\n        y: r1,\r\n      }, {\r\n        x: (-C - B * root.secondRoot) / A,\r\n        y: r2,\r\n      });\r\n    }\r\n  }\r\n  else {\r\n    u = q.a * l.d * l.d;\r\n    v = q.c * l.d * l.d;\r\n    w = q.b * l.e * l.e - q.d * l.d * l.e + q.e * l.d * l.d;\r\n\r\n    // solves x. Unneeded check IMPOSSIBLE.\r\n    const root = calculateQuadraticEquation(u, v, w);\r\n\r\n    if (typeof root === 'number') {\r\n      results.push({\r\n        x: root,\r\n        y: -l.e / l.d,\r\n      });\r\n    }\r\n    else if (root === IMPOSSIBLE) {\r\n      return root;\r\n    }\r\n    else {\r\n      results.push({\r\n        x: root.firstRoot,\r\n        y: -l.e / l.d,\r\n      }, {\r\n        x: root.secondRoot,\r\n        y: -l.e / l.d,\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function calculateIntersectionTwoCircleEquations(firstEquation: EquationType, secondEquation: EquationType) {\r\n  let results: Array<Object> = [];\r\n  if (!firstEquation || !secondEquation) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  let q1, q2;\r\n  firstEquation.a === undefined ?\r\n    (q1 = convertLinearToEquation(firstEquation)) :\r\n    (q1 = firstEquation);\r\n  secondEquation.a === undefined ?\r\n    (q2 = convertLinearToEquation(secondEquation)) :\r\n    (q2 = secondEquation);\r\n\r\n  if (q1.a !== q2.a && q1.b !== q2.b) {\r\n    if (q1.a === 0 && q1.b === 0) {\r\n      // q2 is a quadratic equation\r\n      return calculateIntersectionEquationTypeWithCircleEquation(q1, q2);\r\n    }\r\n    else {\r\n      // q1 is a quadratic equation\r\n      return calculateIntersectionEquationTypeWithCircleEquation(q2, q1);\r\n    }\r\n  }\r\n  else if (q1.a === 0 && q1.b === 0 && q2.a === 0 && q2.b === 0) {\r\n    results.push(calculateSetOfEquationTypes(q1, q2));\r\n  }\r\n  else {\r\n    // a x2 + b y2 + Ax + By + C = 0\r\n    // a'x2 + b'y2 + Dx + Ey + G = 0\r\n    const D = q2.c;\r\n    const E = q2.d;\r\n    const G = q2.e;\r\n\r\n    // Z = a - a'\r\n    const Z = q1.a - q2.a > 0 ?\r\n      q1.a :\r\n      q2.a;\r\n    const _D = Z === q1.a ?\r\n      q1.c :\r\n      D;\r\n    const _E = Z === q1.a ?\r\n      q1.d :\r\n      E;\r\n    const _G = Z === q1.a ?\r\n      q1.e :\r\n      G;\r\n\r\n    const a = Z === q1.a ?\r\n      q1.c - D :\r\n      D - q1.c;\r\n    const b = Z === q1.a ?\r\n      q1.d - E :\r\n      E - q1.d;\r\n    const c = Z === q1.a ?\r\n      q1.e - G :\r\n      G - q1.e;\r\n\r\n    if (a === 0 || b === 0) {\r\n      return IMPOSSIBLE;\r\n    }\r\n    else {\r\n      const u = Z * (b * b + a * a);\r\n      const v = 2 * b * c * Z - _D * a * b + _E * a * a;\r\n      const w = Z * c * c - _D * a * c + _G * a * a;\r\n\r\n      const roots = calculateQuadraticEquation(u, v, w);\r\n      if (roots === IMPOSSIBLE) {\r\n        return roots;\r\n      }\r\n      else if (typeof roots === 'number') {\r\n        results.push({\r\n          x: (-c - b * roots) / a,\r\n          y: roots,\r\n        });\r\n      }\r\n      else {\r\n        const r1 = roots.firstRoot;\r\n        const r2 = roots.secondRoot;\r\n        results.push({\r\n          x: (-c - b * roots.firstRoot) / a,\r\n          y: r1,\r\n        }, {\r\n          x: (-c - b * roots.secondRoot) / a,\r\n          y: r2,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return results;\r\n}\r\n\r\nexport function calculateLinesByAnotherLineAndAngle(\r\n  rootPoint: CoordinateType,\r\n  staticPoint: CoordinateType,\r\n  dynamicPoint: CoordinateType,\r\n  angle: number,\r\n): EquationType {\r\n  const equations = _calculateLinesByAnotherLineAndAngle(\r\n    getLineFromTwoPoints(rootPoint, staticPoint),\r\n    dynamicPoint,\r\n    angle,\r\n  );\r\n  let index = 0;\r\n  const newRootPoints = equations\r\n    .map((equation: EquationType): CoordinateType => {\r\n      return calculateIntersectionByLineAndLine(getLineFromTwoPoints(rootPoint, staticPoint), equation);\r\n    })\r\n    .filter((newRootPoint: CoordinateType, i): boolean => {\r\n      const staticVector = calculateVector(rootPoint, staticPoint, false);\r\n      const dynamicVector = calculateVector(newRootPoint, dynamicPoint, false);\r\n      const result = calculateAngleTwoVector(staticVector, dynamicVector) === parseInt(angle);\r\n      if (result) {\r\n        index = i;\r\n      }\r\n      return result;\r\n    });\r\n  if (newRootPoints[0]) {\r\n    return equations[index];\r\n  }\r\n\r\n  ErrorService.showError('500');\r\n  return null;\r\n}\r\n\r\nfunction calculateIntegratedDirection(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  return vectorOne.x * vectorTwo.x + vectorOne.y * vectorTwo.y;\r\n}\r\n\r\nfunction calculateVectorLength(vector: CoordinateType): number {\r\n  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\r\n}\r\n\r\nexport function calculateAngleTwoVector(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  return _makeRound(\r\n    (Math.acos(\r\n      calculateIntegratedDirection(vectorOne, vectorTwo) /\r\n      (calculateVectorLength(vectorOne) * calculateVectorLength(vectorTwo)),\r\n      ) *\r\n      180) /\r\n    Math.PI,\r\n    1,\r\n  );\r\n}\r\n\r\nexport function _calculateLinesByAnotherLineAndAngle(d: EquationType, p: CoordinateType, angle: number) {\r\n  let results: Array<EquationType> = [];\r\n\r\n  const cosine = Math.cos((angle * Math.PI) / 180);\r\n  const A = d.c * d.c - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n  const B = 2 * d.c * d.d;\r\n  const C = d.d * d.d - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n  const root = calculateQuadraticEquation(A, B, C);\r\n\r\n  if (typeof root === 'number') {\r\n    results.push({\r\n      c: root,\r\n      d: 1,\r\n      e: -root * p.x - p.y,\r\n    });\r\n  }\r\n  else if (root === IMPOSSIBLE) {\r\n    return root;\r\n  }\r\n  else {\r\n    results.push(\r\n      {\r\n        c: root.firstRoot,\r\n        d: 1,\r\n        e: -root.firstRoot * p.x - p.y,\r\n      },\r\n      {\r\n        c: root.secondRoot,\r\n        d: 1,\r\n        e: -root.secondRoot * p.x - p.y,\r\n      },\r\n    );\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function makeRoundCoordinate(point: CoordinateType, f: number = 3) {\r\n  if (typeof point === 'string') {\r\n    return point;\r\n  }\r\n  return {\r\n    x: _makeRound(point.x, f),\r\n    y: _makeRound(point.y, f),\r\n  };\r\n}\r\n\r\nexport function getAngleFromTwoLines(d1: EquationType, d2: EquationType): number {\r\n  if (\r\n    d1.a ||\r\n    d1.b ||\r\n    d2.a ||\r\n    d2.b ||\r\n    (d1.c === 0 && d1.d === 0 && d1.e === 0) ||\r\n    (d2.c === 0 && d2.d === 0 && d2.e === 0)\r\n  ) {\r\n    return -9999;\r\n  }\r\n\r\n  console.log(d1, d2);\r\n\r\n  const a1 = d1.c;\r\n  const a2 = d2.c;\r\n  const b1 = d1.d;\r\n  const b2 = d2.d;\r\n\r\n  const result =\r\n    (Math.acos(Math.abs(a1 * a2 + b1 * b2) / Math.sqrt((a1 * a1 + b1 * b1) * (a2 * a2 + b2 * b2))) * 180) / Math.PI;\r\n\r\n  // round result\r\n  return _makeRound(result, 1);\r\n}\r\n\r\nexport function getMiddlePointFromThreePointsInALine(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType,\r\n): CoordinateType {\r\n  const line = getLineFromTwoPoints(p1, p2);\r\n  if (!isIn(p3, {\r\n    a: 0,\r\n    b: 0,\r\n    c: line.c,\r\n    d: line.d,\r\n    e: line.e,\r\n  })) {\r\n    return NOT_BE_IN_LINE;\r\n  }\r\n\r\n  // another way: check vector =)))~\r\n  const dis_p1_p2 = calculateDistanceTwoPoints(p1, p2);\r\n  const dis_p2_p3 = calculateDistanceTwoPoints(p2, p3);\r\n  const dis_p1_p3 = calculateDistanceTwoPoints(p1, p3);\r\n\r\n  const max = Math.max(dis_p1_p2, dis_p2_p3, dis_p1_p3);\r\n  if (dis_p1_p2 === max) {\r\n    return p3;\r\n  }\r\n  else if (dis_p1_p3 === max) {\r\n    return p2;\r\n  }\r\n  else {\r\n    return p1;\r\n  }\r\n}\r\n\r\nexport function calculateCircumCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  const midperpendicularsLineOne = calculatePerpendicularLineByPointAndLine(\r\n    calculateMiddlePoint(p1, p2),\r\n    getLineFromTwoPoints(p1, p2),\r\n  );\r\n\r\n  const midperpendicularsLineTwo = calculatePerpendicularLineByPointAndLine(\r\n    calculateMiddlePoint(p1, p3),\r\n    getLineFromTwoPoints(p1, p3),\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(midperpendicularsLineOne, midperpendicularsLineTwo);\r\n  const radius = calculateDistanceTwoPoints(center, p1);\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n\r\n  return {\r\n    center,\r\n    radius,\r\n    equation,\r\n  };\r\n}\r\n\r\nexport function calculateInCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  const bisectorLineOne = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(p1, p3),\r\n    getLineFromTwoPoints(p1, p2),\r\n    p2,\r\n    p3,\r\n  );\r\n\r\n  const bisectorLineTwo = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(p2, p3),\r\n    getLineFromTwoPoints(p1, p2),\r\n    p1,\r\n    p3,\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n  const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(p1, p3));\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n  return {\r\n    center,\r\n    radius,\r\n    equation,\r\n  };\r\n}\r\n\r\nexport function calculateEscribedCirclesEquation(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType,\r\n  escribedPoint: CoordinateType,\r\n): CircleType {\r\n  const otherPoints = [\r\n    p1,\r\n    p2,\r\n    p3,\r\n  ].filter(\r\n    (point: CoordinateType): boolean => JSON.stringify(point) !== JSON.stringify(escribedPoint),\r\n  );\r\n  console.log(otherPoints);\r\n\r\n  if (otherPoints.length !== 2) {\r\n    ErrorService.showError('300');\r\n    return;\r\n  }\r\n\r\n  const bisectorLineOne = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(escribedPoint, otherPoints[0]),\r\n    getLineFromTwoPoints(escribedPoint, otherPoints[1]),\r\n    otherPoints[0],\r\n    otherPoints[1],\r\n  );\r\n\r\n  const bisectorLineTwo = calculateExternalBisectLineEquation(\r\n    getLineFromTwoPoints(escribedPoint, otherPoints[0]),\r\n    getLineFromTwoPoints(otherPoints[1], otherPoints[0]),\r\n    escribedPoint,\r\n    otherPoints[1],\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n  const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(otherPoints[1], otherPoints[0]));\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n  return {\r\n    center,\r\n    radius,\r\n    equation,\r\n  };\r\n}\r\n\r\nexport function calculateTangentEquation(circle: EquationType, point?: CoordinateType = null): EquationType {\r\n  const tangentPoint: CoordinateType = point || getRandomPointInEquation(circle);\r\n\r\n  const tangentEquation: EquationType = {};\r\n\r\n  tangentEquation.a = 0;\r\n  tangentEquation.b = 0;\r\n  tangentEquation.c = tangentPoint.x + circle.c / 2;\r\n  tangentEquation.d = tangentPoint.y + circle.d / 2;\r\n  tangentEquation.e = circle.e + (circle.c * tangentPoint.x) / 2 + (circle.d * tangentPoint.y) / 2;\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nexport function calculateTangentIntersectPointsByPointOutsideCircle(\r\n  circle: EquationType,\r\n  point?: CoordinateType = null,\r\n  exceptionPoint?: CoordinateType = null,\r\n): EquationType {\r\n  const center: CoordinateType = {\r\n    x: -circle.c / 2,\r\n    y: -circle.d / 2,\r\n  };\r\n\r\n  const tempCircleCenter = calculateMiddlePoint(center, point);\r\n  const tempCircleRadius = calculateDistanceTwoPoints(center, point) / 2;\r\n\r\n  const tempCircleEquation = calculateCircleEquationByCenterPoint(tempCircleCenter, tempCircleRadius);\r\n\r\n  let roots = calculateIntersectionTwoCircleEquations(circle, tempCircleEquation);\r\n\r\n  if (exceptionPoint) {\r\n    roots = roots.filter((root: CoordinateType): boolean => JSON.stringify(root) !== JSON.stringify(exceptionPoint));\r\n  }\r\n\r\n  return roots;\r\n}\r\n\r\nexport function isTwoEquationEqual(equationOne: EquationType, equationTwo: EquationType): boolean {\r\n  return getAngleFromTwoLines(equationOne, equationTwo, 1) === 0;\r\n}\r\n\r\nexport function isIsosceles(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): boolean {\r\n  let result = false;\r\n  if (distance(p1, p2) === distance(p1, p3)) {\r\n    result = true;\r\n  }\r\n  else if (distance(p2, p1) === distance(p2, p3)) {\r\n    result = true;\r\n  }\r\n  else if (distance(p3, p2) === distance(p3, p1)) {\r\n    result = true;\r\n  }\r\n  return result;\r\n}\r\n","export function isLowerCaseChar(char) {\r\n  if (char === char.toLowerCase()) return '0';\r\n  return '1';\r\n}\r\n\r\nexport function isNumber(value) {\r\n  return !isNaN(value) || typeof value === 'number' || (isObjectLike(value) && getTag(value) === '[object Number]');\r\n}\r\n\r\nexport function isObject(value) {\r\n  const type = typeof value;\r\n  return value !== null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport function isQuadraticEquation(equation): boolean {\r\n  if (!equation) return false;\r\n  return equation.a === 1 && equation.b === 1;\r\n}\r\n\r\nexport function isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n  const tag = getTag(value);\r\n  return (\r\n    tag === '[object Function]' ||\r\n    tag === '[object AsyncFunction]' ||\r\n    tag === '[object GeneratorFunction]' ||\r\n    tag === '[object Proxy]'\r\n  );\r\n}\r\n\r\n/* ====================================================================\r\n                          INTERNAL METHODS\r\n   ==================================================================*/\r\nfunction isObjectLike(value) {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nfunction getTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? '[object Undefined]' : '[object Null]';\r\n  }\r\n  return toString.call(value);\r\n}\r\n","import { isLowerCaseChar, isNumber } from '../../utils/checker';\r\n\r\nexport function checkFormatString(str) {\r\n  let result = '';\r\n  str.split('').forEach((element) => {\r\n    result += isLowerCaseChar(element);\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction validateObject(str) {\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (isNumber(str[i])) return false;\r\n    if (i > 0) if (str.slice(0, i - 1).includes(str[i])) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function defineObject(value) {\r\n  if (isNumber(value)) {\r\n    return 'value';\r\n  }\r\n\r\n  if (!validateObject(value)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (value.length === 3) {\r\n    if (value.includes('(') && value.includes(')')) {\r\n      return 'circle';\r\n    }\r\n    return 'angle';\r\n  }\r\n\r\n  const formatObj = checkFormatString(value);\r\n  switch (formatObj) {\r\n    case '0':\r\n      return 'line';\r\n    case '1':\r\n      return 'point';\r\n    case '10':\r\n      return 'ray';\r\n    case '11':\r\n      return 'segment';\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import { RankingObjectContain, validate } from '../definition/define.js';\r\nimport { checkFormatString } from '../definition/defineObjType';\r\nimport ErrorService from '../../utils/ErrorHandleService.js';\r\n\r\nexport function validateValue(value, type) {\r\n  if (!_validateName(value.value)) return false;\r\n\r\n  const validateGeometryType = validate.object[type];\r\n  let validateType;\r\n\r\n  if (value.key === 'value' || value.key === 'relation' || value.key === 'undefined' || value.key === 'circle')\r\n    return true;\r\n  if (value.key === 'angle') if (!validateAngle(value.value)) return false;\r\n\r\n  if (validateGeometryType.includes(value.key) || value.key !== 'object') {\r\n    const format = checkFormatString(value.value);\r\n    validateType = validate[value.key];\r\n    if (validateType && format)\r\n      if (validateType.format) {\r\n        if (format === validateType.format && value.value.length === validateType.length) return true;\r\n      } else if (value.value.length === validateType.length) {\r\n        return true;\r\n      }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction validateAngle(value) {\r\n  const format = checkFormatString(value);\r\n  return format[1] === '1';\r\n}\r\n\r\nfunction validateShape(shape) {\r\n  const keys = Object.keys(shape);\r\n  const validateShapeFormat = validate.shape[keys[0]];\r\n  const validateShapeType = validate.shapeType[keys[0]] || [''];\r\n  //check format of shape value\r\n  const value = shape[keys[0]];\r\n  const format = checkFormatString(shape[keys[0]]);\r\n  const shapeFormatCheck = format === validateShapeFormat.format && value.length === validateShapeFormat.length;\r\n\r\n  //check type of shape\r\n  const type = shape.type || '';\r\n  const shapeTypeCheck = validateShapeType.includes(type);\r\n\r\n  return shapeFormatCheck && shapeTypeCheck && _validateName(shape[keys[0]]);\r\n}\r\n\r\nfunction validateDataRelationship(data) {\r\n  const keys = Object.keys(data);\r\n\r\n  for (let indexOfRankingLevel = 0; indexOfRankingLevel < RankingObjectContain.length - 1; indexOfRankingLevel++) {\r\n    for (\r\n      let indexOfObjectCurrentLevel = 0;\r\n      indexOfObjectCurrentLevel < RankingObjectContain[indexOfRankingLevel].length;\r\n      indexOfObjectCurrentLevel++\r\n    ) {\r\n      for (\r\n        let indexOfObjectNextLevel = 0;\r\n        indexOfObjectNextLevel < RankingObjectContain[indexOfRankingLevel + 1].length;\r\n        indexOfObjectNextLevel++\r\n      )\r\n        if (keys.includes(RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel])) {\r\n          if (data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]])\r\n            return checkObjectRelationship(\r\n              data[RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel]][0],\r\n              data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]][0]\r\n            );\r\n        }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction checkObjectRelationship(obj1, obj2) {\r\n  let check = obj2.split('').map((char) => {\r\n    return obj1.includes(char);\r\n  });\r\n  const result = [...new Set(check)];\r\n\r\n  if (result.length === 1) {\r\n    return !result[0];\r\n  }\r\n  if (obj2.length === 2) return check.indexOf(true) === -1;\r\n  if (obj2.length === 3) {\r\n    return !(check.indexOf(true) === 0 || check.indexOf(true) === 2);\r\n  }\r\n}\r\n\r\n// check validate name not duplicate Ex: ABB\r\nfunction _validateName(string) {\r\n  return (\r\n    string.split('').length === string.split('').filter((item, index, array) => array.indexOf(item) === index).length\r\n  );\r\n}\r\n\r\nexport function validateInformation(info) {\r\n  const type = info.outputType;\r\n\r\n  if (type === 'shape') {\r\n    return validateShape(info);\r\n  } else {\r\n    delete info.outputType;\r\n    let keys = Object.keys(info);\r\n    if (keys.includes('undefined')) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < keys.length; i++) {\r\n      let array = info[keys[i]];\r\n      let key = keys[i];\r\n      for (let j = 0; j < array.length; j++) {\r\n        let value = array[j];\r\n        const check = validateValue({ key, value }, type);\r\n\r\n        if (!check) return check;\r\n      }\r\n    }\r\n  }\r\n  const keys = Object.keys(info);\r\n  info.outputType = type;\r\n\r\n  if (type === 'define') {\r\n    if (keys.includes('value')) {\r\n      return keys.length === 2;\r\n    } else {\r\n      return keys.length === 1;\r\n    }\r\n  }\r\n\r\n  if (type === 'relation') {\r\n    return validateDataRelationship(info);\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { defineObject } from './defineObjType';\r\nimport { validateInformation } from '../validation/validation';\r\nimport { definePointType } from './definePointType';\r\nimport { defineShapeType } from './defineShapeType';\r\nimport { reversedDependentObjRelation } from './define';\r\n\r\nfunction defineInformation(data) {\r\n  let result;\r\n  switch (data.outputType) {\r\n    case 'shape': {\r\n      result = defineShapeType(data);\r\n      break;\r\n    }\r\n\r\n    case 'relation': {\r\n      result = definePointType(data);\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      result = data;\r\n    }\r\n  }\r\n\r\n  if (reversedDependentObjRelation.includes(result.relation)) {\r\n    result.object = result.object.reverse();\r\n  }\r\n\r\n  Object.keys(result).forEach((key) => {\r\n    if (key === 'object') {\r\n      result[key].forEach((value) => {\r\n        const type = defineObject(value);\r\n        if (!result[type]) result[type] = [];\r\n        if (type === 'segment') {\r\n          value = sortString(value);\r\n        }\r\n        if (type === 'circle') {\r\n          value = value[1].toUpperCase();\r\n        }\r\n\r\n        if (type === 'angle') {\r\n          value = [value[0], value[2]].sort().join(value[1]);\r\n        }\r\n        result[type].push(value);\r\n      });\r\n    }\r\n    if (key === 'circle') {\r\n      result[key].forEach((value: string, index: number) => {\r\n        result[key][index] = result[key][index][1];\r\n      });\r\n    }\r\n  });\r\n\r\n  if (data.outputType === 'shape') {\r\n    const shapeName = Object.keys(result).filter((key) => key !== 'type')[0];\r\n    if (shapeName !== 'triangle') {\r\n      result[shapeName] = sortString(result[shapeName]);\r\n    }\r\n  }\r\n\r\n  delete result.object;\r\n  const validate = validateInformation(result);\r\n\r\n  if (validate) {\r\n    return result;\r\n  } else {\r\n    return { Error: result };\r\n  }\r\n}\r\n\r\nfunction sortString(str) {\r\n  const arr = str.split('');\r\n  const sorted = arr.sort();\r\n  return sorted.join('');\r\n}\r\n\r\nexport { defineInformation };\r\n","export function defineShapeType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key.includes('type')) {\r\n      const splitter = data[key].toString().split(' ');\r\n      const shape = splitter[splitter.length - 1];\r\n      const splitKey = key.split(' ');\r\n      const shapeName = splitKey.pop();\r\n      const otherData = data[key]\r\n        .toString()\r\n        .replace(shape, '')\r\n        .trim()\r\n        .split(' ');\r\n      result[shapeName] = shape;\r\n      let point = '';\r\n      if (otherData[0].length === 3 && otherData[0].includes('(') && otherData[0].includes(')')) {\r\n        result['point'] = otherData[0][1];\r\n        point = otherData[0];\r\n      }\r\n      result['type'] = otherData\r\n        .join(' ')\r\n        .replace(point, '')\r\n        .trim();\r\n    } else {\r\n      result[key] = data[key].toString();\r\n    }\r\n  });\r\n\r\n  console.log(result);\r\n\r\n  return result;\r\n}\r\n","export function definePointType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key === 'arrayPoints') {\r\n      result['point'] = data[key].toString().split(',');\r\n    } else {\r\n      result[key] = data[key];\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n","import dataViewModel from '../../ViewModel/DataViewModel';\r\nimport type { CoordinateType } from '../../utils/types';\r\nimport {\r\n  calculateDistanceTwoPoints,\r\n  getLineFromTwoPoints,\r\n  isIn,\r\n  isIsosceles,\r\n} from './Math2D';\r\nimport { getRandomValue } from './Generation.js';\r\nimport GConst from '../../utils/values';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_GENERATION;\r\nconst MAX = GConst.Number.MAX_RANDOM_GENERATION;\r\n\r\nconst geometricObj = {\r\n  triangle: generateTriangle,\r\n  quadrilateral: generateQuadrilateral,\r\n  trapezoid: generateTrapezoid,\r\n  parallelogram: generateParallelogram,\r\n  rectangle: generateRectangle,\r\n  rhombus: generateRhombus,\r\n  square: generateSquare,\r\n  circle: generateCircle,\r\n};\r\n\r\nexport function generateGeometry(name: string, shape: string, type?: string) {\r\n  const generateFunc = geometricObj[shape];\r\n  if (generateFunc) {\r\n    generateFunc(name, type);\r\n  }\r\n}\r\n\r\nfunction generateTriangle(name: string, type: string) {\r\n  if (name.length === 3) {\r\n    let p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    let p2: CoordinateType = {};\r\n    let p3: CoordinateType = {};\r\n\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n    switch (type) {\r\n      case '': {\r\n        p3.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n        p3.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n        p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        while (isIn(p2, getLineFromTwoPoints(p1, p3)) || isIsosceles(p1, p2, p3)) {\r\n          p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n          p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        }\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        p2.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n        p2.x = p1.x;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        p3.x = getRandomValue(p1.x + 1, p1.x + 50);\r\n        p3.y = p1.y;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        /*\r\n         *            [A]\r\n         *          *    *\r\n         *        *        *\r\n         *      *            *\r\n         *    *                *\r\n         *  B  * * * * * * * *  C\r\n         */\r\n        const distance_From_A_To_B = getRandomValue(3, 6);\r\n\r\n        p3.y = getRandomValue(p1.y + 5, p1.y + 10);\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông cân': {\r\n        const distance_From_A_To_B = getRandomValue(5, 10);\r\n        p3.y = p1.y + distance_From_A_To_B;\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'đều': {\r\n        /*\r\n         *       [A]\r\n         *      *   *\r\n         *    *       *\r\n         * [B] * * * * [C]\r\n         */\r\n        p2.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n        p2.y = Math.sqrt(3) * p2.x;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        const distance_From_A_To_B = calculateDistanceTwoPoints(p1, p2);\r\n        p3.y = p2.y;\r\n        p3.x = -distance_From_A_To_B + p2.x;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Tu giac\r\nfunction generateQuadrilateral(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.y - MAX, p1.y + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {};\r\n    // prevent point C is on AB line\r\n    const linearEquation = getLineFromTwoPoints(p1, p2);\r\n    do {\r\n      p3.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n      p3.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n    }\r\n    while (p3.y === linearEquation.coefficientX * p3.x + linearEquation.constantTerm);\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: getRandomValue(p1.x - MAX, p3.x),\r\n      y: undefined,\r\n    };\r\n\r\n    // prevents p1, p2, p4 are straight\r\n    const line = getLineFromTwoPoints(p1, p2);\r\n    do {\r\n      p4.y = getRandomValue(p1.x, p1.x + MAX);\r\n    }\r\n    while (p4.y === line.coefficientX * p4.x + line.constantTerm);\r\n\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thang\r\nfunction generateTrapezoid(name: string, type: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    switch (type) {\r\n      case '': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + Math.floor(MAX / 2), p1.x + MAX),\r\n          y: p1.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: (getRandomValue(p2.x + Math.floor(MAX / 2), p2.x + MAX)),\r\n          y: getRandomValue(p2.y + Math.floor(MAX / 2), p1.y + MAX),\r\n        };\r\n        dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: getRandomValue(p1.x - Math.floor(MAX / 2), p1.x - MAX),\r\n          y: p3.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[3], p4);\r\n        console.table({\r\n          p1,\r\n          p2,\r\n          p3,\r\n          p4,\r\n        });\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n          y: p1.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: getRandomValue(p2.x + MIN, p2.x + MAX),\r\n          y: getRandomValue(p1.y + MIN, p1.y + MAX),\r\n        };\r\n        dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n        const distanceX = Math.abs(p3.x - p2.x);\r\n        const p4X = getRandomValue(0, 2) === 1 ?\r\n          p1.x + distanceX :\r\n          p1.x - distanceX;\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: p4X,\r\n          y: p3.y,\r\n        };\r\n        dataViewModel.updateCoordinate(name[3], p4);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        // TODO: vuong tai dau?\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// hinh binh hanh\r\nfunction generateParallelogram(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    let p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    let p4: CoordinateType = {\r\n      x: p3.x - p2.x - p1.x,\r\n      y: p3.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateRectangle(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: getRandomValue(p2.y + MIN, p2.y + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thoi\r\nfunction generateRhombus(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: -getRandomValue(p1.y + MIN, p1.y + MAX),\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: 2 * Math.abs(p2.x - p1.x),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p2.x,\r\n      y: Math.abs(-p2.y - p1.y),\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateSquare(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: p2.y + calculateDistanceTwoPoints(p1, p2),\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y,\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateCircle(name: string) {\r\n}\r\n","import type { CoordinateType, EquationType, NodeRelationType, NodeType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionTwoCircleEquations,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  getLineFromTwoPoints,\r\n  calculateInCircleEquation,\r\n  calculateCircumCircleEquation,\r\n  getAngleFromTwoLines,\r\n  calculateMiddlePoint,\r\n  calculateSymmetricalPoint,\r\n  calculateEscribedCirclesEquation\r\n} from '../math/Math2D';\r\nimport { getRandomValue } from '../math/Generation';\r\nimport { mappingShapeType, shapeRules, TwoStaticPointRequireShape, circleType } from '../definition/define';\r\nimport { generateGeometry } from '../math/GenerateGeometry';\r\nimport { readRelation } from './ReadRelation';\r\nimport ErrorService from '../../utils/ErrorHandleService.js';\r\nimport appData from '../../Model/AppData.js';\r\n\r\nlet shape, shapeName, shapeType;\r\n\r\nexport function readPointsMap(): Array | {} {\r\n  dataViewModel.createPointDetails();\r\n  console.table(dataViewModel.getData.getPointsMap);\r\n\r\n  while (!dataViewModel.isPointsMapStatic()) {\r\n    //get node to calculate\r\n    const executingNode = dataViewModel.getNextExecuteNode();\r\n    if (!executingNode) break;\r\n    console.log(executingNode.id);\r\n\r\n    executeRelations(executingNode);\r\n\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(executingNode.id)) {\r\n      const roots = dataViewModel.getData.getPointDetails.get(executingNode.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(executingNode.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[executingNode.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(executingNode.id, coordinate);\r\n      }\r\n    }\r\n\r\n    //appModel.updatePointsMap(executingNode);\r\n    dataViewModel.getData.getExecutedNode.push(executingNode.id);\r\n\r\n    //update static Node\r\n    dataViewModel.updateStaticNode();\r\n\r\n    if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n      makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], executingNode.id);\r\n    }\r\n  }\r\n\r\n  dataViewModel.getData.getPointsMap.forEach((node: NodeType) => {\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(node.id)) {\r\n      console.log(dataViewModel.getData.getPointDetails.get(node.id));\r\n      const roots = dataViewModel.getData.getPointDetails.get(node.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(node.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[node.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n        dataViewModel.updateCoordinate(node.id, coordinate);\r\n      }\r\n    }\r\n  });\r\n\r\n  return dataViewModel.getData.getPointsMap.map((node) => ({\r\n    id: node.id,\r\n    coordinate: node.coordinate\r\n  }));\r\n}\r\n\r\nfunction executeRelations(node: NodeType) {\r\n  const executingNodeRelations = _makeUniqueNodeRelation(node.dependentNodes);\r\n\r\n  executingNodeRelations.forEach((relation) => {\r\n    let relationEquation;\r\n    if (relation.outputType === 'shape') {\r\n      shapeName = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n      shapeType = mappingShapeType[relation.type] || 'normal';\r\n      shape = relation[shapeName];\r\n      if (circleType.includes(shapeType)) {\r\n        let data = null;\r\n        switch (shapeType) {\r\n          case 'nội tiếp':\r\n            data = calculateInCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'ngoại tiếp':\r\n            data = calculateCircumCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'bàng tiếp':\r\n            data = calculateEscribedCirclesEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(relation.escribedPoint[0]).coordinate\r\n            );\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        if (data) {\r\n          dataViewModel.circlesData[relation.point[0]] = data;\r\n          dataViewModel.updateCoordinate(relation.point[0], data.center);\r\n        } else {\r\n          ErrorService.ErrorMessage('400');\r\n        }\r\n      } else if (!dataViewModel.isExecutedRelation(relation)) {\r\n        generateGeometry(relation[shapeName], shapeName, relation.type);\r\n        setPointsDirection(relation[shapeName]);\r\n      }\r\n      if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n        makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], node.id);\r\n      }\r\n    }\r\n    relationEquation = readRelation(relation, node.id);\r\n    if (relationEquation) {\r\n      if (Array.isArray(relationEquation)) {\r\n        relationEquation = relationEquation[getRandomValue(0, relationEquation.length)];\r\n      }\r\n      dataViewModel.executePointDetails(node.id, relationEquation);\r\n    }\r\n    if (!dataViewModel.isExecutedRelation(relation)) {\r\n      dataViewModel.getData.getExecutedRelations.push(relation);\r\n    }\r\n  });\r\n}\r\n\r\nfunction setPointsDirection(shape: string) {\r\n  shape.split('').forEach((point, index) => {\r\n    if (index > 0) {\r\n      const pointCoordinate = dataViewModel.getNodeInPointsMapById(point).coordinate;\r\n      const rootCoordinate = dataViewModel.getNodeInPointsMapById(shape[index - 1]).coordinate;\r\n\r\n      dataViewModel.getData.getPointDirectionMap[point] = {\r\n        root: shape[index - 1],\r\n        isRight: pointCoordinate.x > rootCoordinate.x,\r\n        isUp: pointCoordinate.y < rootCoordinate.y\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\nexport function _makeUniqueNodeRelation(dependentNodes: Array<NodeRelationType>): Array<any> {\r\n  let result: Array<NodeRelationType> = [];\r\n\r\n  for (let index = 0; index < dependentNodes.length; index++) {\r\n    let temp = true;\r\n\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (dependentNodes[index].relation === result[i]) {\r\n        temp = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (temp) result.push(dependentNodes[index].relation);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction makeCorrectShape(shape: string, shapeName: string, rules: string, executePoint: string) {\r\n  const staticPointCountRequire = TwoStaticPointRequireShape.includes(shapeName) ? 2 : 1;\r\n  let staticPoints = shape.replace(executePoint, '').split('');\r\n  // check other points are static\r\n  let count = 0;\r\n  for (let i = 0; i < staticPoints.length; i++) {\r\n    if (dataViewModel.isStaticNodeById(staticPoints[i])) {\r\n      count++;\r\n    }\r\n  }\r\n\r\n  if (count < staticPointCountRequire) {\r\n    return;\r\n  }\r\n\r\n  // get node information\r\n  let arrayRules = rules.split(new RegExp('&', 'g'));\r\n\r\n  const executePointIndex = shape.indexOf(executePoint);\r\n  let nodeSetEquations = [];\r\n  if (arrayRules.length > 0) {\r\n    arrayRules.forEach((rule) => {\r\n      const relationType = rule[2];\r\n      if (rule.includes(executePointIndex)) {\r\n        let equation;\r\n        // eslint-disable-next-line default-case\r\n        switch (relationType) {\r\n          case '|':\r\n            equation = getLinearEquationByParallelRule(rule, shape, executePointIndex);\r\n            break;\r\n          case '^':\r\n            if (rule[1] === rule[3]) {\r\n              equation = getLinearEquationByPerpendicularRule(rule, shape, executePointIndex);\r\n            } else {\r\n              updateCoordinateBySpecialPerpendicularRule(rule, shape, executePointIndex);\r\n            }\r\n            break;\r\n          case '=':\r\n            equation = getLinearEquationsByEqualRule(rule, shape, executePointIndex);\r\n            break;\r\n        }\r\n        if (equation) {\r\n          nodeSetEquations = nodeSetEquations.concat(equation);\r\n        }\r\n      }\r\n    });\r\n    if (executePoint === 'C') console.log(nodeSetEquations);\r\n    nodeSetEquations.forEach((equation) => {\r\n      dataViewModel.executePointDetails(executePoint, equation);\r\n    });\r\n  }\r\n}\r\n\r\nfunction updateCoordinateBySpecialPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  let includeLine, nonIncludeLine;\r\n  const staticLines = rule\r\n    .split('^')\r\n    .filter(\r\n      (line: string): boolean =>\r\n        dataViewModel.isStaticNodeById(shape[line[0]]) && dataViewModel.isStaticNodeById(shape[line[1]])\r\n    );\r\n\r\n  rule.split('^').forEach((line: string) => {\r\n    if (line.includes(executePointIndex)) {\r\n      includeLine = line;\r\n    } else {\r\n      nonIncludeLine = line;\r\n    }\r\n  });\r\n\r\n  const shapePoints = shape\r\n    .split('')\r\n    .map((point: string): CoordinateType => dataViewModel.getNodeInPointsMapById(point).coordinate);\r\n\r\n  if (staticLines.length === 1) {\r\n    const intersectPoint = calculateMiddlePoint(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]]);\r\n    const nonStaticLine = staticLines[0] === nonIncludeLine ? includeLine : nonIncludeLine;\r\n\r\n    const staticPointIndex = nonStaticLine.split('').filter((pointIndex: string): boolean => {\r\n      return dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n    if (shape[nonIncludeLine.replace(staticPointIndex, '')]) {\r\n      const calculatedCoordinate = calculateSymmetricalPoint(shapePoints[staticPointIndex], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[nonIncludeLine.replace(staticPointIndex, '')], calculatedCoordinate);\r\n    }\r\n  } else if (staticLines.length === 0) {\r\n    //line perpendicular with line include 1 static point\r\n    const intersectPoint = calculateIntersectionByLineAndLine(\r\n      calculatePerpendicularLineByPointAndLine(\r\n        shapePoints[executePointIndex],\r\n        getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n      ),\r\n      getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n    );\r\n    let calculatedCoordinate;\r\n    //update coordinate\r\n    const otherPointInIncludeLine = includeLine.replace(executePointIndex, '');\r\n    if (!dataViewModel.isStaticNodeById(shape[otherPointInIncludeLine])) {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[executePointIndex], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[otherPointInIncludeLine], calculatedCoordinate);\r\n    } else {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[otherPointInIncludeLine], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[executePointIndex], calculatedCoordinate);\r\n    }\r\n    const nonStaticPointIndex = nonIncludeLine.split('').filter((pointIndex: string): boolean => {\r\n      return !dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n\r\n    calculatedCoordinate = calculateSymmetricalPoint(\r\n      shapePoints[nonIncludeLine.replace(nonStaticPointIndex, '')],\r\n      intersectPoint\r\n    );\r\n\r\n    dataViewModel.updateCoordinate(shape[nonStaticPointIndex], calculatedCoordinate);\r\n  }\r\n}\r\n\r\nfunction getLinearEquationsByEqualRule(rule: string, shape: string, executePointIndex: number): Array<EquationType> {\r\n  const lines = rule.split('=');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  console.log(staticLine, nonStaticLine);\r\n  if (staticLine) {\r\n    const count = staticLine.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n\r\n    if (count < 2) {\r\n      return [];\r\n    }\r\n\r\n    const otherPoint = shape[nonStaticLine.replace(executePointIndex, '')];\r\n\r\n    const radius = calculateDistanceTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n    );\r\n\r\n    //point is outside static line\r\n    if (staticLine.includes(nonStaticLine.replace(executePointIndex, ''))) {\r\n      return [\r\n        calculateCircleEquationByCenterPoint(dataViewModel.getNodeInPointsMapById(otherPoint).coordinate, radius)\r\n      ];\r\n    }\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByParallelRule(rule: string, shape: string, executePointIndex: number): EquationType {\r\n  const lines = rule.split('|');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  if (\r\n    staticLine &&\r\n    nonStaticLine.includes(executePointIndex) &&\r\n    dataViewModel.isStaticNodeById(shape[nonStaticLine.replace(executePointIndex, '')])\r\n  ) {\r\n    return [\r\n      calculateParallelLineByPointAndLine(\r\n        //point\r\n        dataViewModel.getNodeInPointsMapById(shape[nonStaticLine.replace(executePointIndex, '')]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  const lines = rule.split('^');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n\r\n  if (staticLine && nonStaticLine.includes(executePointIndex) && !staticLine.includes(executePointIndex)) {\r\n    return [\r\n      calculatePerpendicularLineByPointAndLine(\r\n        //Common point\r\n        dataViewModel.getNodeInPointsMapById(shape[rule[1]]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n","import type { CoordinateType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateInternalBisectLineEquation,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionEquationTypeWithCircleEquation,\r\n  calculateLinesByAnotherLineAndAngle,\r\n  calculateMiddlePoint,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  calculateSymmetricalPoint,\r\n  getAngleFromTwoLines,\r\n  getLineFromTwoPoints,\r\n  getMiddlePointFromThreePointsInALine,\r\n  isIn,\r\n  calculateIntersectionTwoCircleEquations,\r\n  isVectorInSameLine,\r\n  calculateExternalBisectLineEquation,\r\n  calculateVector,\r\n  calculateTangentEquation,\r\n  calculateTangentIntersectPointsByPointOutsideCircle\r\n} from '../math/Math2D';\r\nimport {\r\n  generatePointAlignmentInside,\r\n  generatePointAlignmentOutside,\r\n  generatePointMiddleTwoPoints,\r\n  getRandomPointInEquation,\r\n  getRandomValue\r\n} from '../math/Generation.js';\r\nimport ErrorService from '../../utils/ErrorHandleService';\r\nimport { ShapeAffectBySegmentChange, TwoStaticPointRequireShape } from '../definition/define';\r\n\r\nexport function readRelation(relation: mixed, point: string) {\r\n  let equationResults;\r\n\r\n  dataViewModel.executingRelation = relation;\r\n  if (relation.operation) {\r\n    equationResults = analyzeOperationType(relation, point);\r\n  } else if (relation.relation) {\r\n    const relationType = relation.relation;\r\n    switch (relationType) {\r\n      case 'trung điểm':\r\n      case 'thuộc':\r\n      case 'không thuộc':\r\n      case 'song song':\r\n      case 'vuông góc':\r\n      case 'phân giác':\r\n      case 'phân giác ngoài':\r\n      case 'phân giác trong':\r\n      case 'thẳng hàng':\r\n        equationResults = analyzeRelationType(relation, point);\r\n        break;\r\n      case 'cắt':\r\n        equationResults = analyzeIntersectRelation(relation, point);\r\n        break;\r\n      case 'tiếp tuyến':\r\n        equationResults = analyzeTangentRelation(relation, point);\r\n        break;\r\n      default:\r\n        equationResults = null;\r\n    }\r\n  } else if (relation.outputType === 'shape') {\r\n    const shapeType = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n    switch (shapeType) {\r\n      case 'triangle':\r\n        equationResults = getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate\r\n        );\r\n        break;\r\n      case 'quadrilateral':\r\n      case 'rectangle':\r\n      case 'square':\r\n      case 'rhombus':\r\n      case 'trapezoid':\r\n      case 'parallelogram':\r\n        if (shapeType !== 'quadrilateral') {\r\n          let count = 0;\r\n          relation[shapeType].split('').forEach((point) => {\r\n            if (dataViewModel.isStaticNodeById(point)) {\r\n              count++;\r\n            }\r\n          });\r\n          const limit = TwoStaticPointRequireShape.includes(shapeType) ? 1 : 2;\r\n          if (count > limit) {\r\n            return;\r\n          }\r\n        }\r\n        let index = relation[shapeType].indexOf(point);\r\n        if (index === relation[shapeType].length - 1) {\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate\r\n          );\r\n        } else {\r\n          index = index === 0 ? relation[shapeType].length - 1 : index - 1;\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(point).coordinate\r\n          );\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  //TODO\r\n  if (equationResults) {\r\n    if (equationResults.coefficientX !== undefined) {\r\n      // equationResults is linear\r\n      return {\r\n        a: 0,\r\n        b: 0,\r\n        c: equationResults.coefficientX,\r\n        d: equationResults.coefficientY,\r\n        e: equationResults.constantTerm\r\n      };\r\n    } else {\r\n      // equationResults is circle\r\n      return equationResults;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction analyzeRelationType(relation: mixed, point: string): LinearEquation {\r\n  let segmentIncludePoint, segmentNotIncludePoint;\r\n  if (relation.segment) {\r\n    relation.segment.forEach((segment: string) => {\r\n      if (segment.includes(point)) {\r\n        segmentIncludePoint = segment;\r\n      } else {\r\n        segmentNotIncludePoint = segment;\r\n      }\r\n    });\r\n  }\r\n\r\n  //points = [...new Set(points)].filter((point: string): boolean => !nonStaticPoints.includes(point));\r\n  const relationType = relation.relation;\r\n\r\n  if (\r\n    relationType === 'trung điểm' ||\r\n    relationType === 'thuộc' ||\r\n    relationType === 'không thuộc' ||\r\n    relationType === 'thẳng hàng'\r\n  ) {\r\n    let calculatedPoint;\r\n    if (relation.circle) {\r\n      calculatedPoint = getRandomPointInEquation(dataViewModel.getCircleEquation(relation.circle[0]));\r\n      dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n      return dataViewModel.getCircleEquation(relation.circle[0]);\r\n    }\r\n    if (segmentIncludePoint) {\r\n      const otherStaticPoint = relation.point[0];\r\n      const otherStaticNodeInSegment = dataViewModel.getNodeInPointsMapById(segmentIncludePoint.replace(point, ''));\r\n\r\n      if (!otherStaticNodeInSegment.coordinate.x && !otherStaticNodeInSegment.coordinate.y) {\r\n        return null;\r\n      }\r\n\r\n      if (relationType === 'trung điểm') {\r\n        calculatedPoint = calculateSymmetricalPoint(\r\n          otherStaticNodeInSegment.coordinate,\r\n          dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n          segmentIncludePoint.indexOf(point) === 1\r\n        );\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n    } else if (segmentNotIncludePoint) {\r\n      switch (relationType) {\r\n        case 'trung điểm':\r\n          calculatedPoint = calculateMiddlePoint(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'thuộc':\r\n          calculatedPoint = generatePointAlignmentInside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'không thuộc':\r\n          calculatedPoint = generatePointAlignmentOutside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate,\r\n            getRandomValue(0, 2) === 1\r\n          );\r\n\r\n          dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else {\r\n      const points = relation.point;\r\n      const index = points.indexOf(point);\r\n      if (index === 1) {\r\n        calculatedPoint = generatePointAlignmentInside(\r\n          dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[2]).coordinate\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedPoint = generatePointAlignmentOutside(\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 0 : 1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 1 : 2]).coordinate,\r\n          index === 2\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(points[1]).coordinate\r\n      );\r\n    }\r\n\r\n    return getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n  } else if (relationType === 'song song' || relationType === 'vuông góc') {\r\n    if (!segmentNotIncludePoint) {\r\n      return;\r\n    }\r\n    const otherStaticPoint = segmentIncludePoint.replace(point, '');\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint) && !dataViewModel.isValidCoordinate(point)) {\r\n      const point = generatePointMiddleTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n      );\r\n      if (point) {\r\n        dataViewModel.updateCoordinate(otherStaticPoint, point);\r\n      }\r\n    }\r\n    //undefined point\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(segmentNotIncludePoint[i])) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const staticLineEquation = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n    );\r\n\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint)) {\r\n      return;\r\n    }\r\n\r\n    let calculatedLineEquation;\r\n    if (relationType === 'vuông góc') {\r\n      calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const isInStaticLine = isIn(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n      const calculatedPoint = isInStaticLine\r\n        ? getRandomPointInEquation(calculatedLineEquation)\r\n        : calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n\r\n      if (!isInStaticLine) {\r\n        dataViewModel.getData.pushAdditionSegment(`${point}${segmentNotIncludePoint[1]}`);\r\n        dataViewModel.getData.pushAdditionSegment(`${point}${segmentNotIncludePoint[0]}`);\r\n      }\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    if (relationType === 'song song') {\r\n      calculatedLineEquation = calculateParallelLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    return calculatedLineEquation;\r\n  } else if (relationType.includes('phân giác')) {\r\n    const isExternal = relationType === 'phân giác ngoài';\r\n\r\n    if (relation.angle) {\r\n      const angle = relation.angle[0];\r\n      if (angle.includes(point)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n      );\r\n      let calculatedLineEquation;\r\n      if (isExternal) {\r\n        calculatedLineEquation = calculateExternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedLineEquation = calculateInternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return calculatedLineEquation;\r\n    }\r\n  }\r\n}\r\n\r\nfunction analyzeIntersectRelation(relation: mixed, point: string): CoordinateType {\r\n  for (let index in relation.segment) {\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(relation.segment[index][i])) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if (relation.segment && relation.segment.length === 2) {\r\n    const calculatedLineEquationOne = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n    const calculatedLineEquationTwo = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][1]).coordinate\r\n    );\r\n\r\n    relation.segment.forEach((segment: string) => {\r\n      dataViewModel.getData.pushAdditionSegment(`${relation.point[0]}${segment[0]}`);\r\n      dataViewModel.getData.pushAdditionSegment(`${relation.point[0]}${segment[1]}`);\r\n    });\r\n\r\n    const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquationOne, calculatedLineEquationTwo);\r\n\r\n    dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n  } else if (relation.circle && relation.circle.length === 2) {\r\n    const roots = calculateIntersectionTwoCircleEquations(\r\n      dataViewModel.getCircleEquation(relation.circle[0]),\r\n      dataViewModel.getCircleEquation(relation.circle[1])\r\n    );\r\n\r\n    roots.forEach((root: CoordinateType, index: number) => {\r\n      if (relation.point[index]) {\r\n        dataViewModel.updateCoordinate(relation.point[index], root);\r\n      }\r\n    });\r\n  } else {\r\n    const pointOne = dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate;\r\n    const pointTwo = dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate;\r\n    let roots = calculateIntersectionTwoCircleEquations(\r\n      getLineFromTwoPoints(pointOne, pointTwo),\r\n      dataViewModel.getCircleEquation(relation.circle[0])\r\n    );\r\n\r\n    roots = roots.filter(\r\n      (root: CoordinateType): boolean =>\r\n        JSON.stringify(root) !== JSON.stringify(pointOne) && JSON.stringify(root) !== JSON.stringify(pointTwo)\r\n    );\r\n    if (relation.point.length === 2) {\r\n      roots.forEach((root: CoordinateType, index: number) => {\r\n        if (!relation.point[index]) {\r\n          ErrorService.showError('200');\r\n        } else {\r\n          dataViewModel.updateCoordinate(relation.point[index], root);\r\n        }\r\n      });\r\n    } else {\r\n      dataViewModel.updateCoordinate(relation.point[0], roots[getRandomValue(0, roots.length - 1)]);\r\n    }\r\n  }\r\n}\r\n\r\n//chỉ xử lý : = , *\r\nfunction analyzeOperationType(relation: mixed, point: string): any {\r\n  const objectType = relation.segment ? 'segment' : 'angle';\r\n  const valueData = {};\r\n\r\n  const objectsIncludePoint = [];\r\n\r\n  console.log(relation[objectType]);\r\n\r\n  for (let index in relation[objectType]) {\r\n    const object = relation[objectType][index];\r\n    if (object.includes(point)) {\r\n      objectsIncludePoint.push(object);\r\n    }\r\n\r\n    valueData[object] =\r\n      objectType === 'segment'\r\n        ? calculateDistanceTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n          )\r\n        : getAngleFromTwoLines(\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n            ),\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[2]).coordinate\r\n            )\r\n          );\r\n  }\r\n\r\n  //điểm cần tính phụ thuộc 1 điểm duy nhất\r\n  if (objectsIncludePoint.length === 1) {\r\n    const index = relation[objectType].indexOf(objectsIncludePoint[0]);\r\n    const staticObject = relation[objectType][index === 0 ? 1 : 0];\r\n    let staticValue;\r\n    if (relation[objectType].length > 1) {\r\n      staticValue = index === 0 ? relation.value * valueData[staticObject] : valueData[staticObject] / relation.value;\r\n    } else {\r\n      staticValue = relation.value[0];\r\n    }\r\n\r\n    if (objectType === 'segment') {\r\n      return calculateCircleEquationByCenterPoint(\r\n        dataViewModel.getNodeInPointsMapById(objectsIncludePoint[0].replace(point, '')).coordinate,\r\n        staticValue\r\n      );\r\n    }\r\n\r\n    return calculateLineEquationByAngleRelation(objectsIncludePoint[0], staticValue);\r\n  }\r\n  if (objectsIncludePoint.length === 2) {\r\n    if (objectType === 'segment') {\r\n      const staticPointOne = objectsIncludePoint[0].replace(point, '');\r\n      const staticPointTwo = objectsIncludePoint[1].replace(point, '');\r\n      //cần check thêm loại shape\r\n      if (!dataViewModel.isStaticNodeById(staticPointOne) || !dataViewModel.isStaticNodeById(staticPointTwo)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const staticDistance = calculateDistanceTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const isAlign = isIn(dataViewModel.getNodeInPointsMapById(point).coordinate, {\r\n        a: 0,\r\n        b: 0,\r\n        c: staticLineEquation.coefficientX,\r\n        d: staticLineEquation.coefficientY,\r\n        e: staticLineEquation.constantTerm\r\n      });\r\n\r\n      const ratio = +relation.value[0];\r\n      if (isAlign) {\r\n        let calculatedPoint;\r\n        const betweenPoint = getMiddlePointFromThreePointsInALine(\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n        );\r\n\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(point).coordinate) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio + 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === p) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate && ratio < 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (1 - ratio)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate && ratio > 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio - 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n\r\n        return staticLineEquation;\r\n      } else {\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateLineEquationByAngleRelation(angleName: string, angleValue: number): EquationType {\r\n  const modifiedAngleName = renameAngle(angleName);\r\n  const staticPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[0]).coordinate;\r\n  const rootPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[1]).coordinate;\r\n  const changedPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[2]).coordinate;\r\n  const calculatedEquation = calculateLinesByAnotherLineAndAngle(rootPoint, staticPoint, changedPoint, angleValue);\r\n\r\n  const intersectPoint = calculateIntersectionByLineAndLine(\r\n    calculatedEquation,\r\n    getLineFromTwoPoints(staticPoint, rootPoint)\r\n  );\r\n  const newRootPoint = calculateIntersectionTwoCircleEquations(\r\n    calculatedEquation,\r\n    calculateCircleEquationByCenterPoint(changedPoint, calculateDistanceTwoPoints(changedPoint, rootPoint))\r\n  ).sort((rootOne: CoordinateType, rootTwo: CoordinateType): number => {\r\n    return calculateDistanceTwoPoints(intersectPoint, rootOne) - calculateDistanceTwoPoints(intersectPoint, rootTwo);\r\n  })[0];\r\n\r\n  //move newRoot to oldRoot\r\n  const transitionVector = calculateVector(newRootPoint, rootPoint, false);\r\n  console.log(modifiedAngleName, angleName);\r\n  if (modifiedAngleName === angleName) {\r\n    dataViewModel.updateCoordinate(modifiedAngleName[2], {\r\n      x: changedPoint.x + transitionVector.x,\r\n      y: changedPoint.y + transitionVector.y\r\n    });\r\n\r\n    dataViewModel.replaceSetOfEquation(\r\n      modifiedAngleName[2],\r\n      getLineFromTwoPoints(rootPoint, changedPoint),\r\n      calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  dataViewModel.updateCoordinate(modifiedAngleName[0], {\r\n    x: staticPoint.x - transitionVector.x,\r\n    y: staticPoint.y - transitionVector.y\r\n  });\r\n\r\n  dataViewModel.replaceSetOfEquation(\r\n    modifiedAngleName[1],\r\n    getLineFromTwoPoints(rootPoint, changedPoint),\r\n    calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n  );\r\n\r\n  return null;\r\n}\r\n\r\nfunction getShapeAffectList(): Array<string> {\r\n  const shapeList = [];\r\n\r\n  //get list of shape name\r\n  dataViewModel.getData.relationsResult.shapes.forEach((shapeData: Object): boolean => {\r\n    const shapeType = Object.keys(shapeData).filter((key: string): boolean => key !== 'outputType')[0];\r\n    if (ShapeAffectBySegmentChange.includes(shapeType)) {\r\n      shapeList.push(shapeData[shapeType]);\r\n    }\r\n  });\r\n\r\n  return shapeList;\r\n}\r\n\r\nfunction renameAngle(angle: string): string {\r\n  const shapeList = getShapeAffectList();\r\n\r\n  const secondLine = `${angle[1]}${angle[2]}`;\r\n\r\n  for (let i = 0; i < shapeList.length; i++) {\r\n    const shape = shapeList[i];\r\n    const secondLineVector = calculateVector(\r\n      dataViewModel.getNodeInPointsMapById(secondLine[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(secondLine[1]).coordinate\r\n    );\r\n\r\n    if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      return angle\r\n        .split('')\r\n        .reverse()\r\n        .join('');\r\n    }\r\n  }\r\n  return angle;\r\n}\r\n\r\nfunction analyzeTangentRelation(relation: mixed, point: string): any {\r\n  const otherPointInSegment = relation.segment[0].replace(point, '');\r\n  if (!dataViewModel.isStaticNodeById(otherPointInSegment)) {\r\n    return;\r\n  }\r\n\r\n  const tangentPointCoordinate = dataViewModel.getNodeInPointsMapById(otherPointInSegment).coordinate;\r\n  const circleEquation = dataViewModel.getCircleEquation(relation.circle[0]);\r\n  let tangentEquation;\r\n  if (isIn(tangentPointCoordinate, circleEquation)) {\r\n    tangentEquation = calculateTangentEquation(circleEquation, tangentPointCoordinate);\r\n    dataViewModel.updateCoordinate(point, getRandomPointInEquation(tangentEquation));\r\n  } else {\r\n    const roots = calculateTangentIntersectPointsByPointOutsideCircle(circleEquation, tangentPointCoordinate);\r\n    const result = filterTangentPoint(roots, circleEquation);\r\n    tangentEquation = result.tangentEquation;\r\n    dataViewModel.updateCoordinate(point, result.point);\r\n  }\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nfunction filterTangentPoint(\r\n  roots: Array<CoordinateType>,\r\n  circleEquation: EquationType\r\n): { equation: EquationType, point: CoordinateType } {\r\n  const filterRoots = roots.filter((root: CoordinateType): boolean => !dataViewModel.isCoordinateDuplicated(root));\r\n\r\n  return filterRoots.map((root: CoordinateType): { equation: EquationType, point: CoordinateType } => {\r\n    return {\r\n      equation: calculateTangentEquation(circleEquation, root),\r\n      point: root\r\n    };\r\n  })[getRandomValue(0, filterRoots.length - 1)];\r\n}\r\n","// @flow\r\n\r\nimport { objectWithPoint } from '../definition/define.js';\r\nimport type { DrawingDataType, NodeRelationType, NodeType } from '../../utils/types.js';\r\nimport dataViewModel from '../../ViewModel/DataViewModel';\r\nimport { readPointsMap } from './ReadPointsMap';\r\nimport { makeRoundCoordinate } from '../math/Math2D.js';\r\n\r\nlet RelationPointsMap: Array<NodeType> = [];\r\n\r\nexport function analyzeResult(validatedResult): DrawingDataType {\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    createPointsMapByShape(shape);\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n  relations.forEach((relation) => {\r\n    createPointsMapByRelation(relation).forEach((node) => {\r\n      updateMap(node, dataViewModel.getData.getPointsMap);\r\n    });\r\n  });\r\n\r\n  trimPointsMap();\r\n\r\n  let result = {};\r\n\r\n  readPointsMap();\r\n  result.points = dataViewModel.getData.getPointsMap.map((node: NodeType) => ({\r\n    id: node.id,\r\n    coordinate: makeRoundCoordinate(node.coordinate, 3)\r\n  }));\r\n\r\n  result.segments = [...getArraySegments(validatedResult), ...dataViewModel.getData.getAdditionSegment];\r\n  return result;\r\n}\r\n\r\nfunction getArraySegments(validatedResult): Array<string> {\r\n  let result: Array<string> = [];\r\n\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    result = result.concat(getShapeSegments(shape));\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n\r\n  relations.forEach((relation) => {\r\n    if (relation.segment) {\r\n      result = result.concat(relation.segment);\r\n    }\r\n  });\r\n\r\n  return result.filter((item, index, array) => array.indexOf(item) === index);\r\n}\r\n\r\nfunction getShapeSegments(shape: any): Array<string> {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  const result = [];\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    if (i === points.length - 1) {\r\n      result.push(points[0] + points[i]);\r\n    } else {\r\n      result.push(points[i] + points[i + 1]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction trimPointsMap() {\r\n  dataViewModel.getData.setPointsMap = dataViewModel.getData.getPointsMap.map((node: NodeType): NodeType => ({\r\n    ...node,\r\n    dependentNodes: unique(node.dependentNodes)\r\n  }));\r\n}\r\n\r\nfunction unique(dependentNodes: Array<NodeRelationType>): Array<NodeRelationType> {\r\n  let result = [];\r\n\r\n  dependentNodes.forEach((node) => {\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (JSON.stringify(node) === JSON.stringify(result[i])) return;\r\n    }\r\n    result.push(node);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction sortPriority(points) {\r\n  return points.sort((el1: string, el2: string): number => {\r\n    const index1 = findIndexByNodeId(el1, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(el2, dataViewModel.getData.getPointsMap);\r\n\r\n    if (index1 === -1 && index2 === -1) {\r\n      return 1;\r\n    }\r\n    if (index1 >= 0 && index2 >= 0) return 1;\r\n    return index2 - index1;\r\n  });\r\n}\r\n\r\nfunction createPointsMapByShape(shape: any) {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  points = sortPriority([...points]);\r\n\r\n  if (dataViewModel.getData.getPointsMap.length === 0) {\r\n    const shouldStaticPoint = getFirstStaticPointInShape(shape[shapeName]);\r\n    points = [shouldStaticPoint].concat(points.filter((point) => point !== shouldStaticPoint));\r\n  }\r\n\r\n  let objectPointsMap;\r\n  // đường tròn ngoại tiếp, nội tiếp\r\n  if (shape.point) {\r\n    objectPointsMap = points.map((point: string) => {\r\n      return createNode(shape.point[0], [{ id: point, relation: shape }]);\r\n    });\r\n  } else {\r\n    objectPointsMap = points.map((point: string, index: number) => {\r\n      return index !== 0 ? createNode(point, [{ id: points[0], relation: shape }]) : createNode(point);\r\n    });\r\n  }\r\n  objectPointsMap.forEach((node: NodeType) => {\r\n    updateMap(node, dataViewModel.getData.getPointsMap);\r\n  });\r\n}\r\n\r\nfunction getFirstStaticPointInShape(shape: string): string {\r\n  const angles = [];\r\n  if (dataViewModel.getData.getRelationsResult.relations) {\r\n    dataViewModel.getData.getRelationsResult.relations.forEach((relation) => {\r\n      if (!relation.angle || relation.outputType !== 'define') {\r\n        return;\r\n      }\r\n      angles.push(relation.angle[0]);\r\n    });\r\n\r\n    const shapePointCount = {};\r\n\r\n    angles.forEach((angle: string): void => {\r\n      angle.split('').forEach((point, index) => {\r\n        //don't check middle point\r\n        if (index !== 1) {\r\n          if (shapePointCount[point]) {\r\n            shapePointCount[point] += 1;\r\n          } else {\r\n            shapePointCount[point] = 1;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    let minCountPoint = shape[0];\r\n    Object.keys(shapePointCount).forEach((point) => {\r\n      if (shapePointCount[point] < shapePointCount[minCountPoint]) {\r\n        minCountPoint = point;\r\n      }\r\n    });\r\n\r\n    return minCountPoint;\r\n  }\r\n  return shape[0];\r\n}\r\n\r\nfunction createPointsMapByRelation(relation: any) {\r\n  RelationPointsMap = [];\r\n  objectWithPoint.forEach((objectType: string) => {\r\n    if (relation[objectType]) {\r\n      relation[objectType].forEach((object) => {\r\n        let points = object.split('').filter((point) => point === point.toUpperCase());\r\n\r\n        points = sortPriority([...points]);\r\n\r\n        const objectPointsMap = points.map((point: string, index: number) => {\r\n          return index === points.length - 1\r\n            ? createNode(point, createDependentNodeOfObject(objectType, object, points))\r\n            : createNode(point);\r\n        });\r\n\r\n        objectPointsMap.forEach((node: NodeType) => {\r\n          updateMap(node, RelationPointsMap);\r\n        });\r\n      });\r\n    }\r\n  });\r\n\r\n  RelationPointsMap = [...RelationPointsMap].sort((nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const index1 = findIndexByNodeId(nodeOne.id, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(nodeTwo.id, dataViewModel.getData.getPointsMap);\r\n    if (index1 === -1 && index2 === -1) return 1;\r\n    if (index1 >= 0 && index2 >= 0) return index1 - index2;\r\n    return index2 - index1;\r\n  });\r\n\r\n  let lastObjectPoints;\r\n\r\n  if (relation.angle && relation.outputType === 'define' && !!relation.value) {\r\n    const index1 = findIndexByNodeId(relation.angle[0][0], dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(relation.angle[0][2], dataViewModel.getData.getPointsMap);\r\n    lastObjectPoints = [index1 > index2 ? relation.angle[0][0] : relation.angle[0][2]];\r\n  } else {\r\n    lastObjectPoints = getDependentObject();\r\n  }\r\n  if (lastObjectPoints.length === RelationPointsMap.length) {\r\n    lastObjectPoints = [lastObjectPoints[0]];\r\n  }\r\n  if (relation.relation === 'song song' || relation.relation === 'vuông góc' || relation.relation === 'phân giác') {\r\n    lastObjectPoints = lastObjectPoints.filter(\r\n      (point: string): boolean => !dataViewModel.getNodeInPointsMapById(point)\r\n    );\r\n  }\r\n  lastObjectPoints.forEach((point) => {\r\n    const index = findIndexByNodeId(point, RelationPointsMap);\r\n    const currentNode = RelationPointsMap[index];\r\n    RelationPointsMap.forEach((node) => {\r\n      if (node.id !== point) {\r\n        RelationPointsMap[index] = {\r\n          ...currentNode,\r\n          dependentNodes: [\r\n            ...currentNode.dependentNodes,\r\n            ...createDependentNodeOfRelation(node.id, relation, lastObjectPoints)\r\n          ]\r\n        };\r\n      }\r\n    });\r\n  });\r\n\r\n  return RelationPointsMap;\r\n}\r\n\r\nfunction getDependentObject(): Array<string> {\r\n  let result: Array = [];\r\n  const lastNode = RelationPointsMap[RelationPointsMap.length - 1];\r\n  if (lastNode) {\r\n    result.push(lastNode.id);\r\n\r\n    lastNode.dependentNodes.forEach((node) => {\r\n      const nodeIndex = findIndexByNodeId(node.id, dataViewModel.getData.getPointsMap);\r\n      if (!result.includes(node.id) && nodeIndex !== -1 && !dataViewModel.getData.getPointsMap[nodeIndex].isStatic)\r\n        result.push(node.id);\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction findIndexByNodeId(id: string, map: Array<NodeType | NodeRelationType>): number {\r\n  for (let i = 0; i < map.length; i++) {\r\n    if (map[i].id === id) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction createDependentNodeOfRelation(\r\n  point: string,\r\n  relation: any,\r\n  exception: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  RelationPointsMap.forEach((node: NodeType) => {\r\n    if (exception.includes(node.id)) return;\r\n    result.push({ id: node.id, relation });\r\n  });\r\n\r\n  console.log(result);\r\n\r\n  return result;\r\n}\r\n\r\nfunction createDependentNodeOfObject(\r\n  objectType: string,\r\n  objectName: string,\r\n  points: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  let relation = {};\r\n  relation[objectType] = objectName;\r\n\r\n  points.forEach((point: string, index: number) => {\r\n    if (index === points.length - 1) return;\r\n    result.push({ id: point, relation });\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction createNode(id: string, dependentNodes?: Array<NodeRelationType>): any {\r\n  const node = { id, coordinate: { x: undefined, y: undefined, z: 0 }, isStatic: false };\r\n  const _dependentNodes = dependentNodes ? { dependentNodes } : { dependentNodes: [] };\r\n\r\n  return { ...node, ..._dependentNodes };\r\n}\r\n\r\nfunction updateMap(node: NodeType, map: Array<NodeType>) {\r\n  const index = findIndexByNodeId(node.id, map);\r\n  if (index !== -1) {\r\n    //merge dependentNodes\r\n    const oldNode = map[index];\r\n    map[index] = {\r\n      ...oldNode,\r\n      dependentNodes: [...oldNode.dependentNodes, ...node.dependentNodes]\r\n    };\r\n  } else {\r\n    map.push(node);\r\n    if (dataViewModel.getData.getPointsMap.length === 1) map[0].isStatic = true;\r\n  }\r\n}\r\n","// @flow\r\nimport { observable } from 'mobx';\r\nimport GConst from '../utils/values';\r\n\r\nexport default class RelationInputModel {\r\n  @observable\r\n  value: string = '';\r\n\r\n  @observable\r\n  status: string = GConst.InputStatus.NORMAL;\r\n\r\n  constructor(value: string) {\r\n    this.value = value;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport appData from '../Model/AppData';\r\nimport type { EquationType, PointDetailsType } from '../utils/types';\r\nimport { NodeType } from '../utils/types';\r\nimport GConst from '../utils/values.js';\r\nimport { calculateIntersectionTwoCircleEquations, isIn, makeRoundCoordinate } from '../core/math/Math2D.js';\r\nimport { isQuadraticEquation } from '../utils/checker.js';\r\nimport { defineSentences } from '../core/definition/define';\r\nimport { defineInformation } from '../core/definition';\r\nimport { analyzeResult } from '../core/analysis/Analysis';\r\nimport RelationInputModel from '../Model/RelationInputModel';\r\nimport { observable, action, computed } from 'mobx';\r\nimport ErrorService from '../utils/ErrorHandleService';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { isTwoEquationEqual } from '../core/math/Math2D';\r\nimport { getRandomValue } from '../core/math/Generation';\r\n\r\nconst NOT_FOUND = GConst.Number.NOT_FOUND;\r\nconst NOT_ENOUGH_SET = GConst.String.NOT_ENOUGH_SET;\r\n\r\nclass DataViewModel {\r\n  @observable\r\n  circlesData = {};\r\n\r\n  @observable\r\n  relationsInput: Array<RelationInputModel>;\r\n\r\n  inputData: Array<mixed> = [];\r\n\r\n  executedInputIndex: number;\r\n\r\n  @observable\r\n  executingRelation: mixed;\r\n\r\n  constructor(appData) {\r\n    this.data = appData;\r\n    this.relationsInput = [new RelationInputModel('hình thang ABCD')];\r\n  }\r\n\r\n  @computed\r\n  get RelationsInput() {\r\n    return this.relationsInput;\r\n  }\r\n\r\n  @computed\r\n  get isInputEmpty(): boolean {\r\n    if (this.relationsInput.length === 1 && !this.relationsInput[0].value) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @action\r\n  resetInputsStatus() {\r\n    this.relationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.NORMAL;\r\n    });\r\n  }\r\n\r\n  @action\r\n  onInputChange(value: string, index: number) {\r\n    const newRelationInput = { ...this.relationsInput[index] };\r\n    newRelationInput.value = value;\r\n    this.relationsInput[index] = newRelationInput;\r\n    this.resetInputsStatus();\r\n  }\r\n\r\n  @action\r\n  addNewInput() {\r\n    this.relationsInput.push(new RelationInputModel(''));\r\n  }\r\n\r\n  @action\r\n  removeInput(index: number) {\r\n    this.relationsInput.splice(index, 1);\r\n  }\r\n\r\n  clear() {\r\n    this.data.clear();\r\n  }\r\n\r\n  get getData() {\r\n    return this.data;\r\n  }\r\n\r\n  createPointDetails() {\r\n    this.data.getPointsMap.forEach((node) => {\r\n      const roots = this.isValidCoordinate(node.coordinate) ? [node.coordinate] : [];\r\n      this._updatePointDetails(node.id, {\r\n        setOfEquation: [],\r\n        roots: roots,\r\n        exceptedCoordinates: []\r\n      });\r\n    });\r\n  }\r\n\r\n  isNeedRandomCoordinate = (pointId: string): boolean => {\r\n    const roots = this.data.getPointDetails.get(pointId).roots;\r\n    if (roots) {\r\n      for (let i = 0; i < roots.length; i++) {\r\n        if (\r\n          this.data.getPointDirectionMap[pointId] ||\r\n          JSON.stringify(makeRoundCoordinate(roots[i])) ===\r\n            JSON.stringify(makeRoundCoordinate(this.getNodeInPointsMapById(pointId).coordinate))\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  updateCoordinate = (nodeId: string, coordinate: CoordinateType, f: number = 3): void => {\r\n    const index = this.getIndexOfNodeInPointsMapById(nodeId);\r\n    if (!coordinate) {\r\n      ErrorService.showError('200');\r\n    }\r\n    const _coordinate = {};\r\n    Object.keys(coordinate)\r\n      .sort()\r\n      .forEach((key: string) => {\r\n        _coordinate[key] = coordinate[key];\r\n      });\r\n    if (index !== NOT_FOUND) {\r\n      this.data.getPointsMap[index].coordinate = makeRoundCoordinate(_coordinate, f);\r\n    }\r\n  };\r\n\r\n  isStaticNode = (node: NodeType): boolean => {\r\n    if (node.isStatic) return true;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (!this.isExecutedRelation(node.dependentNodes[i].relation)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return this.data.getExecutedNode.includes(node.id);\r\n  };\r\n\r\n  isExecutedRelation = (relation: any): boolean => {\r\n    for (let i = 0; i < this.data.getExecutedRelations.length; i++) {\r\n      if (JSON.stringify(relation) === JSON.stringify(this.data.getExecutedRelations[i])) return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  updateStaticNode = () => {\r\n    const pointsMap = this.data.getPointsMap.map((node: NodeType): NodeType => {\r\n      node.isStatic = this.isStaticNode(node);\r\n      return node;\r\n    });\r\n    this.data.setPointsMap = pointsMap;\r\n  };\r\n\r\n  updatePointsMap = (node: NodeType) => {\r\n    let index = this.getIndexOfNodeInPointsMapById(node.id);\r\n    this.data.getPointsMap[index] = node;\r\n  };\r\n\r\n  isPointsMapStatic = (): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (!this.data.getPointsMap[i].isStatic) return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  isValidCoordinate = (nodeId: string) => {\r\n    if (nodeId) {\r\n      const node = this.getNodeInPointsMapById(nodeId);\r\n      if (node) {\r\n        return node.coordinate.x !== undefined && node.coordinate.y !== undefined;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  getNextExecuteNode = (): NodeType => {\r\n    const clonePointsMap = this.data.pointsMap\r\n      .filter((node) => !this.data.executedNode.includes(node.id) && !this.isStaticNode(node))\r\n      .sort(this.sortNodeByPriority);\r\n\r\n    if (clonePointsMap.length > 0) return clonePointsMap[0];\r\n    return null;\r\n  };\r\n\r\n  sortNodeByPriority = (nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const staticNodeOneCount = this.getDependentStaticNodeCount(nodeOne);\r\n    const nodeOneData = {\r\n      static: staticNodeOneCount,\r\n      nonStatic: nodeOne.dependentNodes.length - staticNodeOneCount,\r\n      dependence: nodeOne.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeOne),\r\n      index: this.getIndexOfNodeInPointsMap(nodeOne)\r\n    };\r\n\r\n    const staticNodeTwoCount = this.getDependentStaticNodeCount(nodeTwo);\r\n    const nodeTwoData = {\r\n      static: staticNodeTwoCount,\r\n      nonStatic: nodeTwo.dependentNodes.length - staticNodeTwoCount,\r\n      dependence: nodeTwo.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeTwo),\r\n      index: this.getIndexOfNodeInPointsMap(nodeTwo)\r\n    };\r\n\r\n    //get Max\r\n    const rankingOrderDesc = ['static', 'dependence'];\r\n\r\n    //get Min\r\n    const rankingOrderAsc = ['nonStatic', 'minRelationIndex', 'index'];\r\n\r\n    let rankOne = nodeOneData.static === nodeOneData.dependence ? '1' : '0';\r\n    let rankTwo = nodeTwoData.static === nodeTwoData.dependence ? '1' : '0';\r\n\r\n    rankingOrderDesc.forEach((key) => {\r\n      if (nodeOneData[key] > nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    rankingOrderAsc.forEach((key) => {\r\n      if (nodeOneData[key] < nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    return parseInt(rankTwo) - parseInt(rankOne);\r\n  };\r\n\r\n  getMinIndexOfDependentNodeInRelationsList = (node: NodeType) => {\r\n    const indexArray = [];\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      indexArray.push(this.getIndexOfRelationInRelationsList(node.dependentNodes[i]));\r\n    }\r\n\r\n    return Math.min(...indexArray);\r\n  };\r\n\r\n  getIndexOfRelationInRelationsList = (relation: any): number => {\r\n    const list = this.data.getRelationsResult.shapes.concat(this.data.getRelationsResult.relations);\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (relation === list[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getDependentStaticNodeCount = (node: NodeType): number => {\r\n    let count = 0;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (this.isStaticNodeById(node.dependentNodes[i].id)) count++;\r\n    }\r\n\r\n    return count;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMap = (node): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (node === this.data.getPointsMap[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMapById = (id: string): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getNodeInPointsMapById = (id: string): NodeType | null => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return this.data.getPointsMap[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  isStaticNodeById = (id: string): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) {\r\n        return this.isStaticNode(this.data.getPointsMap[i]);\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  _calculateSet = (equations: Array<EquationType>) => {\r\n    if (equations.length === 2) {\r\n      return calculateIntersectionTwoCircleEquations(equations[0], equations[1]);\r\n    } else return NOT_ENOUGH_SET;\r\n  };\r\n\r\n  replaceSetOfEquation(pointId: string, searchEquation: EquationType, replaceEquation: EquationType) {\r\n    const pointDetail = this.data.getPointDetails.get(pointId);\r\n    const setOfEquation = pointDetail.setOfEquation;\r\n    let isReplaceComplete = false;\r\n    setOfEquation.forEach((equation: EquationType, index: number) => {\r\n      if (isTwoEquationEqual(equation, searchEquation)) {\r\n        setOfEquation[index] = replaceEquation;\r\n        isReplaceComplete = true;\r\n      }\r\n    });\r\n\r\n    if (!isReplaceComplete) {\r\n      setOfEquation.push(replaceEquation);\r\n    }\r\n    if (setOfEquation.length === 1) {\r\n      return;\r\n    }\r\n    const roots = this._calculateSet(setOfEquation);\r\n\r\n    this.data.getPointDetails.set(pointId, {\r\n      ...pointDetail,\r\n      setOfEquation,\r\n      roots\r\n    });\r\n\r\n    if (roots.length > 0) {\r\n      let coordinate;\r\n      if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n        coordinate = roots[getRandomValue(0, roots.length)];\r\n      } else {\r\n        const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n        const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n        if (roots.length > 1 && typeof roots !== 'string') {\r\n          const rootsDirection = roots.map((root) => ({\r\n            coordinate: root,\r\n            isRight: root.x > staticPointCoordinate.x,\r\n            isUp: root.y < staticPointCoordinate.y\r\n          }));\r\n\r\n          const coordinateMatch = rootsDirection\r\n            .map((directionInfo) => {\r\n              let matchCount = 0;\r\n              if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                matchCount++;\r\n              }\r\n              if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                matchCount++;\r\n              }\r\n              return {\r\n                coordinate: directionInfo.coordinate,\r\n                matchCount\r\n              };\r\n            })\r\n            .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n          coordinate = coordinateMatch.coordinate;\r\n        } else {\r\n          if (typeof roots === 'string') {\r\n            return;\r\n          }\r\n          coordinate = roots[0];\r\n        }\r\n      }\r\n      dataViewModel.updateCoordinate(pointId, coordinate);\r\n    }\r\n  }\r\n\r\n  _updatePointDetails(pointId: string, pointDetails: PointDetailsType) {\r\n    this.data.getPointDetails.set(pointId, {\r\n      setOfEquation: pointDetails.setOfEquation,\r\n      roots: pointDetails.roots,\r\n      exceptedCoordinates: pointDetails.exceptedCoordinates\r\n    });\r\n  }\r\n\r\n  uniqueSetOfEquation(equations: any[]): any[] {\r\n    let result = [];\r\n\r\n    equations.forEach((equation) => {\r\n      for (let i = 0; i < result.length; i++) {\r\n        if (JSON.stringify(equation) === JSON.stringify(result[i])) return;\r\n      }\r\n      result.push(equation);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  executePointDetails(pointId: string, equation: EquationType) {\r\n    let sum = 0;\r\n    Object.keys(equation)\r\n      .map((key: string): number => equation[key])\r\n      .forEach((value: number) => {\r\n        sum += Math.abs(value);\r\n      });\r\n    if (sum === 0) {\r\n      return;\r\n    }\r\n\r\n    let isFirst = false;\r\n    if (!this.data.getPointDetails.has(pointId)) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [],\r\n        roots: [],\r\n        exceptedCoordinates: []\r\n      });\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length <= 1) {\r\n      let newSetOfEquation = [...this.data.getPointDetails.get(pointId).setOfEquation, equation];\r\n      if (newSetOfEquation.length === 2) {\r\n        if (isTwoEquationEqual(newSetOfEquation[0], newSetOfEquation[1])) {\r\n          newSetOfEquation = newSetOfEquation[0];\r\n        }\r\n      }\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: newSetOfEquation,\r\n        roots: this.data.getPointDetails.get(pointId).roots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n      isFirst = true;\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length === 2) {\r\n      if (isQuadraticEquation(equation) && !isFirst) {\r\n        for (let i = 0; i < 2; i++) {\r\n          if (!isQuadraticEquation(this.data.getPointDetails.get(pointId).setOfEquation[i])) {\r\n            this.data.getPointDetails.get(pointId).setOfEquation[i] = equation;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const roots = this._calculateSet(this.data.getPointDetails.get(pointId).setOfEquation);\r\n      const currentRoots = this.data.getPointDetails.get(pointId).roots;\r\n\r\n      const finalRoots = typeof roots === 'string' ? currentRoots : currentRoots.concat(roots);\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: finalRoots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n    }\r\n\r\n    let temp = this.data.getPointDetails.get(pointId).roots;\r\n\r\n    if (typeof temp === 'string') {\r\n      ErrorService.showError('500');\r\n      return;\r\n    }\r\n\r\n    temp = temp.filter((root) => {\r\n      return isIn(root, equation);\r\n    });\r\n\r\n    if (temp.length > 0) {\r\n      // TODO: Add exception\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: temp,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n\r\n      if (temp.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n          coordinate = temp[getRandomValue(0, temp.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (temp.length > 1) {\r\n            const rootsDirection = temp.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = temp[0];\r\n          }\r\n        }\r\n        console.log(coordinate);\r\n        dataViewModel.updateCoordinate(pointId, coordinate);\r\n      }\r\n    }\r\n  }\r\n\r\n  getInformation(string: string): mixed {\r\n    const _string = '_ '.concat(string.concat(' _'));\r\n    let isMatching = false;\r\n    let preProgress = [];\r\n    Object.keys(defineSentences).forEach((key) => {\r\n      defineSentences[key].forEach((sentence) => {\r\n        sentence = '_ '.concat(sentence.concat(' _'));\r\n\r\n        if (isMatching) return;\r\n        const value = this.getBasicInformation(_string, sentence, key);\r\n        if (Object.keys(value).length > 0) {\r\n          isMatching = true;\r\n          preProgress = value;\r\n          preProgress['outputType'] = key;\r\n        }\r\n      });\r\n    });\r\n    const type = preProgress.outputType;\r\n\r\n    const result = defineInformation(preProgress);\r\n    if (result.Error || !result.outputType) {\r\n      ErrorService.showError('300');\r\n      return;\r\n    }\r\n    if (result.point && result.point.length > 3) {\r\n      ErrorService.showError('301');\r\n      return;\r\n    }\r\n\r\n    // add operation for define type\r\n    if (type === 'define') {\r\n      GConst.Others.OPERATIONS.forEach((operation) => {\r\n        if (result.operation) return;\r\n        if (string.includes(operation)) {\r\n          result.operation = operation;\r\n          if (operation === '=' && !result.value) {\r\n            result.value = '1';\r\n            result.operation = '*';\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getBasicInformation(string, _defineSentence, type) {\r\n    let others = _defineSentence.match(new RegExp(GConst.Regex.OTHER, 'g'));\r\n    let params = _defineSentence.match(new RegExp(GConst.Regex.KEY, 'g'));\r\n\r\n    let result = {};\r\n\r\n    params.forEach((key) => {\r\n      result[key] = [];\r\n    });\r\n\r\n    for (let i = 0; i < params.length; i++) {\r\n      let start =\r\n        others[i]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n      let end =\r\n        others[i + 1]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n\r\n      let param = string.match(new RegExp(start + '(.*)' + end));\r\n\r\n      if (param) result[params[i]].push(param[1]);\r\n\r\n      if (i === others.length - 1) {\r\n        let lastParam = string.match(new RegExp(end + '(.*)'));\r\n        if (lastParam) result[params[i + 1]].push(lastParam[1]);\r\n      }\r\n    }\r\n\r\n    if (this.getLength(result) === params.length) {\r\n      if (type === 'relation') result[type] = others[1].replace('_', '').trim();\r\n      return result;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  getLength(dictionary) {\r\n    let count = 0;\r\n    Object.keys(dictionary).forEach((key) => {\r\n      count += dictionary[key].length;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  getCircleEquation(centerId: string): EquationType {\r\n    return this.circlesData[centerId].equation;\r\n  }\r\n\r\n  getCircleCenterCoordinate(centerId: string): CoordinateType {\r\n    return this.circlesData[centerId].coordinate;\r\n  }\r\n\r\n  isCoordinateDuplicated(coordinate: CoordinateType): boolean {\r\n    const stringifyCoordinate = JSON.stringify(coordinate);\r\n    let result = false;\r\n    this.getData.pointsMap.forEach((node: NodeType) => {\r\n      const key = node.id;\r\n      if (result) {\r\n        return;\r\n      }\r\n      if (JSON.stringify(stringifyCoordinate) === JSON.stringify(this.getNodeInPointsMapById(key).coordinate)) {\r\n        result = true;\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  analyzeInput() {\r\n    this.circlesData = {};\r\n    const data = this.RelationsInput.map((relationsInput: RelationInputModel): string => relationsInput.value)\r\n      // eslint-disable-next-line no-control-getBasicInformation\r\n      .filter((sentence) => !!sentence)\r\n      .map((sentence: string, index: number) => {\r\n        this.executedInputIndex = index;\r\n        const result = this.getInformation(sentence);\r\n        this.relationsInput[index].status = GConst.InputStatus.SUCCESS;\r\n        this.inputData.push(result);\r\n        return result;\r\n      });\r\n\r\n    let result = {\r\n      shapes: [],\r\n      relations: []\r\n    };\r\n    for (let i = 0; i < data.length; i++) {\r\n      let item = data[i];\r\n\r\n      if (item.outputType === 'shape') {\r\n        result.shapes.push(item);\r\n      } else {\r\n        result.relations.push(item);\r\n      }\r\n    }\r\n\r\n    this.data.setRelationsResult = result;\r\n\r\n    this.RelationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.SUCCESS;\r\n    });\r\n    return analyzeResult(result);\r\n  }\r\n}\r\n\r\nconst dataViewModel = new DataViewModel(appData);\r\n\r\nexport default dataViewModel;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport './InputItem.scss';\r\nimport { Icon } from '../index';\r\nimport color from '../../../utils/color.scss';\r\nimport autobind from 'autobind-decorator';\r\ntype PropsType = {\r\n  value: string,\r\n  status: string,\r\n  onValueChange: void,\r\n  onSubmit: void,\r\n  onBackspace: void\r\n};\r\n\r\ntype StateType = {\r\n  shouldRemove: boolean\r\n};\r\n\r\nconst KEYCODE = Object.freeze({\r\n  BACKSPACE: 8,\r\n  ENTER: 13\r\n});\r\n\r\nclass InputItem extends React.Component<PropsType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    this.state = {\r\n      shouldRemove: true,\r\n      isEmpty: true\r\n    };\r\n  }\r\n  inputRef: ReactRefs = React.createRef();\r\n\r\n  focus() {\r\n    if (this.inputRef.current) {\r\n      this.inputRef.current.focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onChange(e: React.FormEvent<HTMLInputElement>) {\r\n    const value = e.currentTarget.value;\r\n    const { onValueChange } = this.props;\r\n\r\n    if (value.length === 0) {\r\n      if (!this.state.isEmpty) {\r\n        this.setState({ isEmpty: true });\r\n      }\r\n    } else {\r\n      this.setState({\r\n        isEmpty: false,\r\n        shouldRemove: false\r\n      });\r\n    }\r\n    if (onValueChange) {\r\n      onValueChange(value);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onKeyUp(e: React.KeyboardEvent<FormControl>) {\r\n    const { onBackspace, onSubmit, value } = this.props;\r\n\r\n    if (e.keyCode === KEYCODE.ENTER) {\r\n      if (onSubmit) {\r\n        onSubmit();\r\n      }\r\n    } else if (e.keyCode === KEYCODE.BACKSPACE) {\r\n      if (this.state.isEmpty && !this.state.shouldRemove) {\r\n        this.setState({\r\n          shouldRemove: true\r\n        });\r\n        return;\r\n      }\r\n      if (onBackspace) {\r\n        onBackspace();\r\n      }\r\n    }\r\n  }\r\n\r\n  render(): React.Node {\r\n    const { status, value } = this.props;\r\n    return (\r\n      <div className=\"input-item\">\r\n        <div className=\"input-group input-container\">\r\n          <div className=\"input-group-prepend input-status\">\r\n            <span className={`input-group-text ${status.toLowerCase()}`} id=\"basic-addon1\">\r\n              <Icon width={15} height={15} name={`input${status}`} color={color[`input${status}`]} />\r\n            </span>\r\n          </div>\r\n          <input\r\n            type=\"text\"\r\n            ref={this.inputRef}\r\n            onChange={this.onChange}\r\n            onKeyUp={this.onKeyUp}\r\n            value={value}\r\n            className={`form-control ${status.toLowerCase()}`}\r\n            aria-describedby=\"basic-addon1\"\r\n          />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default InputItem;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport { inputSuccess, inputError, inputNormal, icInformation, icRemove, icEdit, icAdd } from './Svg';\r\n\r\ntype PropsType = {\r\n  name: string,\r\n  color: string,\r\n  width: number,\r\n  height: number\r\n};\r\n\r\nconst iconList = {\r\n  inputSuccess,\r\n  inputError,\r\n  inputNormal,\r\n  icInformation,\r\n  icRemove,\r\n  icEdit,\r\n  icAdd\r\n};\r\n\r\nexport default class Icon extends React.Component<PropsType> {\r\n  render(): React.Node {\r\n    const { name, width, height, color } = this.props;\r\n    const icon = iconList[name];\r\n    return (\r\n      <svg width={width} height={height} viewBox={icon.viewBox}>\r\n        {icon.svg({ color })}\r\n      </svg>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\n\r\nexport const inputSuccess = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M337.222 22.952c-15.912-8.568-33.66 7.956-44.064 17.748-23.867 23.256-44.063 50.184-66.708 74.664-25.092 26.928-48.348 53.856-74.052 80.173-14.688 14.688-30.6 30.6-40.392 48.96-22.032-21.421-41.004-44.677-65.484-63.648C28.774 167.385-.602 157.593.01 190.029c1.224 42.229 38.556 87.517 66.096 116.28 11.628 12.24 26.928 25.092 44.676 25.704 21.42 1.224 43.452-24.48 56.304-38.556 22.645-24.48 41.005-52.021 61.812-77.112 26.928-33.048 54.468-65.485 80.784-99.145 16.524-20.808 68.544-72.217 27.54-94.248zM26.937 187.581c-.612 0-1.224 0-2.448.611-2.448-.611-4.284-1.224-6.732-2.448 1.836-1.224 4.896-.612 9.18 1.837z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const inputError = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M285.368 234.691L459.36 60.697c13.895-13.88 13.895-36.395 0-50.275-13.881-13.895-36.38-13.895-50.275 0L235.091 184.416 61.082 10.421c-13.866-13.895-36.395-13.895-50.275 0-13.88 13.881-13.88 36.395 0 50.275l174.01 173.995L10.421 409.085c-13.895 13.895-13.895 36.395 0 50.275 6.94 6.955 16.043 10.425 25.145 10.425 9.088 0 18.19-3.47 25.132-10.425L235.09 284.967l173.995 173.995c6.955 6.94 16.043 10.425 25.145 10.425 9.088 0 18.19-3.485 25.131-10.425 13.895-13.88 13.895-36.38 0-50.275L285.367 234.691z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 469.785 469.785'\r\n};\r\n\r\nexport const inputNormal = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M370.59 250.973c-5.524 0-10 4.476-10 10v88.789c-.02 16.562-13.438 29.984-30 30H50c-16.563-.016-29.98-13.438-30-30V89.172c.02-16.559 13.438-29.98 30-30h88.79c5.523 0 10-4.477 10-10 0-5.52-4.477-10-10-10H50c-27.602.031-49.969 22.398-50 50v260.594c.031 27.601 22.398 49.968 50 50h280.59c27.601-.032 49.969-22.399 50-50v-88.793c0-5.524-4.477-10-10-10zm0 0\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M376.629 13.441c-17.574-17.574-46.067-17.574-63.64 0L134.581 191.848a9.997 9.997 0 0 0-2.566 4.402l-23.461 84.7a9.997 9.997 0 0 0 12.304 12.308l84.7-23.465a9.997 9.997 0 0 0 4.402-2.566l178.402-178.41c17.547-17.587 17.547-46.055 0-63.641zM156.37 198.348L302.383 52.332l47.09 47.09-146.016 146.016zm-9.406 18.875l37.62 37.625-52.038 14.418zM374.223 74.676L363.617 85.28l-47.094-47.094 10.61-10.605c9.762-9.762 25.59-9.762 35.351 0l11.739 11.734c9.746 9.774 9.746 25.59 0 35.36zm0 0\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const icInformation = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M194 142.8c.8 1.6 1.6 3.2 2.4 4.4.8 1.2 2 2.4 2.8 3.6 1.2 1.2 2.4 2.4 4 3.6 1.2.8 2.8 2 4.8 2.4 1.6.8 3.2 1.2 5.2 1.6 2 .4 3.6.4 5.2.4s3.6 0 5.2-.4 3.2-.8 4.4-1.6h.4c1.6-.8 3.2-1.6 4.8-2.8 1.2-.8 2.4-2 3.6-3.2l.4-.4c1.2-1.2 2-2.4 2.8-3.6s1.6-2.4 2-4c0-.4 0-.4.4-.8.8-1.6 1.2-3.6 1.6-5.2.4-1.6.4-3.6.4-5.2s0-3.6-.4-5.2-.8-3.2-1.6-5.2c-1.2-2.8-2.8-5.2-4.8-7.2l-.8-.8c-1.2-1.2-2.4-2-4-3.2-1.6-.8-2.8-1.6-4.4-2.4-1.6-.8-3.2-1.2-4.8-1.6-2-.4-3.6-.4-5.2-.4s-3.6 0-5.2.4-3.2.8-4.8 1.6h-.4c-1.6.8-3.2 1.6-4.4 2.4-1.6 1.2-2.8 2-4 3.2-1.2 1.2-2.4 2.4-3.2 3.6-.8 1.2-1.6 2.8-2.4 4.4-.8 1.6-1.2 3.2-1.6 4.8-.4 2-.4 3.6-.4 5.2s0 3.6.4 5.2c.4 3.2 1.2 4.8 1.6 6.4zM249.6 289.2h-9.2v-98c0-5.6-4.4-10.4-10.4-10.4h-42c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h8.4v66.4H188c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h61.6c5.6 0 10.4-4.4 10.4-10.4V300c0-6-4.8-10.8-10.4-10.8z\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M218.8 0C98 0 0 98 0 218.8s98 218.8 218.8 218.8 218.8-98 218.8-218.8S339.6 0 218.8 0zm0 408.8c-104.8 0-190-85.2-190-190s85.2-190 190-190 190 85.2 190 190-85.2 190-190 190z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 437.6 427.6'\r\n};\r\n\r\nexport const icEdit = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M328.883 89.125l107.59 107.589-272.34 272.34L56.604 361.465l272.279-272.34zm189.23-25.948l-47.981-47.981c-18.543-18.543-48.653-18.543-67.259 0l-45.961 45.961 107.59 107.59 53.611-53.611c14.382-14.383 14.382-37.577 0-51.959zM.3 512.69c-1.958 8.812 5.998 16.708 14.811 14.565l119.891-29.069L27.473 390.597.3 512.69z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 528.899 528.899'\r\n};\r\n\r\nexport const icRemove = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M465.167 211.613H26.69c-8.424 0-26.69 11.439-26.69 34.316s18.267 34.316 26.69 34.316H465.169c8.421 0 26.689-11.439 26.689-34.316s-18.268-34.316-26.691-34.316z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 491.858 491.858'\r\n};\r\n\r\nexport const icAdd = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fillRule=\"evenodd\"\r\n        clipRule=\"evenodd\"\r\n        d=\"M34.525 19.11l.398.038a17.705 17.705 0 000-3.296l-.398.037-.398.038a16.903 16.903 0 010 3.146l.398.038zm-.333-5.342l.39-.087a17.364 17.364 0 00-1.017-3.133l-.367.16-.367.158c.413.954.74 1.953.97 2.989l.39-.087zm-1.97-4.974l.343-.203a17.556 17.556 0 00-1.938-2.664l-.3.265-.3.264a16.76 16.76 0 011.85 2.542l.344-.204zm-3.414-4.121l.265-.3a17.551 17.551 0 00-2.663-1.938l-.204.344-.204.344a16.755 16.755 0 012.542 1.85l.264-.3zm-4.515-2.87l.159-.368c-1-.433-2.047-.775-3.133-1.017l-.087.39-.087.39c1.036.231 2.035.558 2.989.971l.159-.367zM19.11.474l.037-.398a17.718 17.718 0 00-3.296 0l.037.398.038.398a16.919 16.919 0 013.146 0l.038-.398zm-5.343.333l-.087-.39a17.365 17.365 0 00-3.133 1.017l.16.367.158.367c.954-.413 1.953-.74 2.989-.97l-.087-.39zm-4.974 1.97l-.203-.343c-.95.562-1.841 1.212-2.664 1.938l.265.3.264.3a16.756 16.756 0 012.542-1.85l-.204-.344zM4.673 6.193l-.3-.265a17.556 17.556 0 00-1.938 2.664l.344.203.344.204a16.756 16.756 0 011.85-2.542l-.3-.264zm-2.87 4.515l-.368-.159c-.433 1-.775 2.047-1.017 3.133l.39.087.39.087c.231-1.036.558-2.036.971-2.989l-.367-.159zM0 17.5c0-.556.026-1.105.077-1.648l.398.037.398.038a16.919 16.919 0 000 3.146l-.398.038-.398.037A17.718 17.718 0 010 17.5zm.808 3.732l-.39.087a17.365 17.365 0 001.017 3.133l.367-.16.367-.158a16.565 16.565 0 01-.97-2.989l-.39.087zm1.97 4.974l-.343.204a17.55 17.55 0 001.938 2.663l.3-.265.3-.264a16.755 16.755 0 01-1.85-2.542l-.344.204zm3.414 4.121l-.265.3a17.556 17.556 0 002.664 1.938l.203-.344.204-.344a16.76 16.76 0 01-2.542-1.85l-.264.3zm4.515 2.87l-.159.368c1 .433 2.047.775 3.133 1.017l.087-.39.087-.39a16.563 16.563 0 01-2.989-.971l-.159.367zm5.182 1.328l-.037.398a17.705 17.705 0 003.296 0l-.037-.398-.038-.398a16.903 16.903 0 01-3.146 0l-.038.398zm5.343-.333l.087.39a17.364 17.364 0 003.133-1.017l-.16-.367-.158-.367c-.954.413-1.953.74-2.989.97l.087.39zm4.974-1.97l.204.343c.949-.562 1.84-1.212 2.663-1.938l-.265-.3-.264-.3a16.76 16.76 0 01-2.542 1.85l.204.344zm4.121-3.414l.3.265a17.552 17.552 0 001.938-2.663l-.344-.204-.344-.204a16.76 16.76 0 01-1.85 2.542l.3.264zm2.87-4.515l.368.159c.433-1 .775-2.047 1.017-3.133l-.39-.087-.39-.087a16.563 16.563 0 01-.971 2.989l.367.159zM17.7 9.723a.5.5 0 01.5.5V17h7a.5.5 0 010 1h-7v6.778a.5.5 0 01-1 0V18h-7a.5.5 0 010-1h7v-6.778a.5.5 0 01.5-.5z\"\r\n        fill={props.color || '#dcdcdc'}\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 35 35'\r\n};\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport Toggle from 'react-bootstrap-toggle';\r\nimport { Button, Dropdown, DropdownButton } from 'react-bootstrap';\r\nimport autobind from 'autobind-decorator';\r\nimport { Icon } from '../index';\r\nimport type { DrawingSegmentType } from '../../../utils/types';\r\nimport './SegmentSetting.scss';\r\n\r\ntype PropsType = {\r\n  value?: DrawingSegmentType,\r\n  data: Array<string>,\r\n  onDone: void,\r\n  onDelete: void,\r\n  onVisibleChange: void\r\n};\r\n\r\ntype StateType = {\r\n  start: string,\r\n  end: string,\r\n  visible: boolean,\r\n  isEditMode: boolean,\r\n  isCreateMode: boolean,\r\n  isMouseHoverEdition: boolean,\r\n  isMouseHoverDeletion: boolean,\r\n};\r\n\r\nclass SegmentSetting extends React.Component<PropsType, StateType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    const start = props.value ? props.value.name[0] : '';\r\n    const end = props.value ? props.value.name[1] : '';\r\n    this.state = {\r\n      start,\r\n      end,\r\n      visible: true,\r\n      isEditMode: !props.value,\r\n      isCreateMode: !props.value,\r\n      isMouseHoverEdition: false,\r\n      isMouseHoverDeletion: false,\r\n    };\r\n  }\r\n\r\n  @autobind\r\n  onDone() {\r\n    const {start, end} = this.state;\r\n    const {onDone} = this.props;\r\n\r\n    if (onDone) {\r\n      onDone({name: [start, end].sort().join(''), visible: true});\r\n    }\r\n    this.setState({isEditMode: false});\r\n  }\r\n\r\n  @autobind\r\n  onDelete() {\r\n    const {onDelete} = this.props;\r\n    if (onDelete) {\r\n      onDelete();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onVisibleChange(visible: boolean) {\r\n    const {onVisibleChange, value} = this.props;\r\n    if (onVisibleChange) {\r\n      onVisibleChange({name: value.name, visible: !value.visible});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  getIndexInData(dropdownIndex: string, filterValue: string): number {\r\n    const {data} = this.props;\r\n    const filterValueIndex = data.indexOf(filterValue);\r\n    if (filterValueIndex < 0) {\r\n      return dropdownIndex;\r\n    }\r\n    return filterValueIndex > dropdownIndex ? dropdownIndex : parseInt(dropdownIndex) + 1;\r\n  }\r\n\r\n  @autobind\r\n  onStartPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    const {start, end} = this.state;\r\n    const newStartValue = data[index];\r\n    if (newStartValue === end) {\r\n      this.setState({start: newStartValue, end: start});\r\n    } else {\r\n      this.setState({start: newStartValue});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onEndPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    this.setState({end: data[this.getIndexInData(index, this.state.start)]});\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverEdition() {\r\n    this.setState({isMouseHoverEdition: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveEdition() {\r\n    this.setState({isMouseHoverEdition: false})\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverDeletion() {\r\n    this.setState({isMouseHoverDeletion: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveDeletion() {\r\n    this.setState({isMouseHoverDeletion: false})\r\n  }\r\n\r\n  @autobind\r\n  onChangeContentState() {\r\n    const {isEditMode, start, end} = this.state;\r\n    if (!start || !end) {\r\n      return;\r\n    }\r\n    this.setState({isEditMode: !isEditMode});\r\n  }\r\n\r\n  @autobind\r\n  renderDropdown(value: string, data: Array<string>, onSelect: void): React.Node {\r\n    return (\r\n      <DropdownButton title={value || 'Chọn điểm'} id={`segment-dropdown`} onSelect={onSelect}>\r\n        {data.map((item: string, index: number): React.Node => (\r\n          <Dropdown.Item key={`Drop-item-${index}`} eventKey={`${index}`}>\r\n            {item}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderEditContent(): React.Node {\r\n    const {data} = this.props;\r\n    const {start, end, isCreateMode} = this.state;\r\n    return (\r\n      <div className=\"content-edit\">\r\n        <div className=\"drop-down-container\">\r\n          <div className={\"col-6 p-0\"}>\r\n            {this.renderDropdown(start, data, this.onStartPointSelect)}\r\n          </div>\r\n          <div className=\"col-6 p-0 right-drop-down\">\r\n            {this.renderDropdown(end, data.filter((item) => item !== this.state.start), this.onEndPointSelect)}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"button-container mt-1\">\r\n          <div className={\"col-6 p-0 d-flex justify-content-between\"}>\r\n            <Button className={\"btn-cancel\"} onClick={isCreateMode ? this.onDelete : this.onChangeContentState}>\r\n              HỦY\r\n            </Button>\r\n            <Button className={\"btn-update\"} variant={`${isCreateMode ? 'link' : 'success'}`} disabled={!(start && end)}\r\n                    onClick={this.onDone}>\r\n              {isCreateMode ? 'THÊM' : 'CẬP NHẬT'}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderShowContent(): React.Node {\r\n    const {\r\n      value: {name, visible}\r\n    } = this.props;\r\n    return (\r\n      <div className=\"content-show\">\r\n        <div className=\"content\">\r\n          <div className={\"segment-edit-name col-8\"}>\r\n            <p>{name}</p>\r\n          </div>\r\n\r\n          <div className={\"segment-edit-controller col-4\"}>\r\n            <Toggle\r\n              onstyle=\"success\"\r\n              offstyle=\"danger\"\r\n              handleClassName=\"toggle-handler\"\r\n              onClick={this.onVisibleChange}\r\n              off=\"HIỆN\"\r\n              on=\"ẨN\"\r\n              active={visible}\r\n            />\r\n\r\n            <div onClick={this.onChangeContentState}\r\n                 onMouseLeave={this.mouseLeaveEdition}\r\n                 onMouseOver={this.mouseHoverEdition}\r\n                 onMouseDown={this.mouseLeaveEdition}>\r\n              {\r\n                this.state.isMouseHoverEdition ?\r\n                  <Icon name={'icEdit'} color={'#218838'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icEdit'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n\r\n            <div onClick={this.onDelete}\r\n                 onMouseOver={this.mouseHoverDeletion}\r\n                 onMouseLeave={this.mouseLeaveDeletion}\r\n                 onMouseDown={this.mouseLeaveDeletion}>\r\n              {\r\n                this.state.isMouseHoverDeletion ?\r\n                  <Icon name={'icRemove'} color={'#dc3545'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icRemove'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderContent(): React.Node {\r\n    const {isEditMode} = this.state;\r\n    if (isEditMode) {\r\n      return this.renderEditContent();\r\n    }\r\n\r\n    return this.renderShowContent();\r\n  }\r\n\r\n  render(): React.Node {\r\n    const {style} = this.props;\r\n    const {isEditMode, isCreateMode} = this.state;\r\n\r\n    return (\r\n      <div className=\"segment-setting\" style={{...style}}>\r\n        <div className=\"container\">\r\n          {isEditMode && (\r\n            <div className=\"title\">\r\n              <p>{`${isCreateMode ? 'Thêm' : 'Cập nhật'} đoạn thẳng :`}</p>\r\n            </div>\r\n          )}\r\n          {this.renderContent()}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SegmentSetting;\r\n","class Geom {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  toString() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nexport { Geom };\r\n","import { Geom } from './geom';\r\n\r\nclass Point extends Geom {\r\n  constructor(name, x, y) {\r\n    if (typeof y === 'undefined') {\r\n      y = x;\r\n      x = name;\r\n      name = null;\r\n    }\r\n    super(name);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.free = true;\r\n  }\r\n\r\n  toString() {\r\n    return super.toString() + '(' + this.x + ',' + this.y + ')';\r\n  }\r\n\r\n  /* shorthand function for constructing a point from coodinates */\r\n  static P(name, x, y) {\r\n    return new Point(name, x, y);\r\n  }\r\n}\r\n\r\nexport { Point };\r\n","import { Geom } from './geom';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nclass Circle extends Geom {\r\n  constructor(name, center, a) {\r\n    if (typeof a === 'undefined') {\r\n      a = center;\r\n      center = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    this.center = center;\r\n    if (a instanceof Point) {\r\n      this._fromCenterAndBoundaryPoint(center, a);\r\n    } else if (typeof a === 'number') {\r\n      this._fromCenterAndRadius(center, a);\r\n    }\r\n  }\r\n\r\n  _fromCenterAndRadius(center, radius) {\r\n    this.radius = radius;\r\n    Object.defineProperties(this, {\r\n      radiussq: {\r\n        get() {\r\n          return this.radius * this.radius;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _fromCenterAndBoundaryPoint(center, boundaryPoint) {\r\n    this.boundaryPoint = boundaryPoint;\r\n    Object.defineProperties(this, {\r\n      radius: {\r\n        get() {\r\n          return distance(this.boundaryPoint, this.center);\r\n        }\r\n      },\r\n      radiussq: {\r\n        get() {\r\n          return distanceSquared(this.boundaryPoint, this.center);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    var w = Math.abs(x - this.center.x);\r\n    if (w > this.radius) return null;\r\n    if (w === this.radius) return new Point(x, this.center.y);\r\n\r\n    var h = Math.sqrt(this.radius * this.radius - w * w);\r\n    return [this.center.y + h, this.center.y - h];\r\n  }\r\n\r\n  contains(p) {\r\n    return distanceSquared(p, this.center) === this.radiussq;\r\n  }\r\n\r\n  toString() {\r\n    return 'Circle' + super.toString() + '[' + this.center.toString() + ';' + this.radius + ']';\r\n  }\r\n}\r\n\r\nexport { Circle };\r\n","import { Geom } from './geom';\r\n\r\nclass Line extends Geom {\r\n  constructor(name, p1, p2) {\r\n    if (typeof p2 === 'undefined') {\r\n      p2 = p1;\r\n      p1 = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    if (!p2) {\r\n      this._p = p1.slice(0);\r\n    } else {\r\n      this._p = [p1, p2];\r\n    }\r\n\r\n    this._clip = false;\r\n\r\n    Object.defineProperties(this, {\r\n      // TODO: I don't like dx and dy on the line class...\r\n      dx: {\r\n        get() {\r\n          return this._p[1].x - this._p[0].x;\r\n        }\r\n      },\r\n      dy: {\r\n        get() {\r\n          return this._p[1].y - this._p[0].y;\r\n        }\r\n      },\r\n      theta: {\r\n        get() {\r\n          return Math.atan2(this.dy, this.dx);\r\n        }\r\n      },\r\n      m: {\r\n        get() {\r\n          if (this.dx === 0) return null;\r\n          else return this.dy / this.dx;\r\n        }\r\n      },\r\n\r\n      left: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      right: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      top: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      },\r\n      bottom: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    if (this.dx === 0 || (this._clip && (this.left > x || this.right < x))) return null;\r\n    else return this._p[0].y + ((x - this._p[0].x) * this.dy) / this.dx;\r\n  }\r\n\r\n  x(y) {\r\n    if (this.dy === 0 || (this._clip && (this.top > y || this.bottom < y))) return null;\r\n    else return this._p[0].x + ((y - this._p[0].y) * this.dx) / this.dy;\r\n  }\r\n\r\n  contains(p) {\r\n    let onLine = this.dx !== 0 ? this.y(p.x) === p.y : this.x(p.y) === p.x;\r\n    return (\r\n      onLine && (!this._clip || (this.left <= p.x && p.x <= this.right && (this.top <= p.y && p.y <= this.bottom)))\r\n    );\r\n  }\r\n\r\n  toString() {\r\n    return 'Line' + super.toString() + '[' + this._p[0].toString() + ';' + this._p[1].toString() + ']';\r\n  }\r\n}\r\n\r\nexport { Line };\r\n","import { Line } from './line';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nconst P = Point.P;\r\n\r\nclass Segment extends Line {\r\n  constructor(name, p1, p2) {\r\n    super(name, p1, p2);\r\n    this._clip = true;\r\n\r\n    Object.defineProperties(this, {\r\n      p: {\r\n        // TODO: clone point themselves?\r\n        get() {\r\n          return [].concat(this._p);\r\n        }\r\n      },\r\n\r\n      lengthsq: {\r\n        get() {\r\n          return distanceSquared(this._p[0], this._p[1]);\r\n        }\r\n      },\r\n\r\n      length: {\r\n        get() {\r\n          return distance(this._p[0], this._p[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  toString() {\r\n    return 'Segment' + super.toString();\r\n  }\r\n\r\n  /*\r\n  clip the given line (or line segment) to the given bounding box, where `bounds`\r\n  must have `left`, `right`, `top`, and `bottom` properties.\r\n  */\r\n  static clip(bounds, line) {\r\n    var [p1, p2] = line._p;\r\n\r\n    var left = line.y(bounds.left),\r\n      right = line.y(bounds.right),\r\n      top = line.x(bounds.top),\r\n      bottom = line.x(bounds.bottom);\r\n\r\n    if (p1.x > p2.x) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (left && left >= bounds.top && left <= bounds.bottom) {\r\n      // intersects left wall\r\n      p1 = P(bounds.left, left);\r\n    }\r\n    if (right && right >= bounds.top && right <= bounds.bottom) {\r\n      // intersects right wall\r\n      p2 = P(bounds.right, right);\r\n    }\r\n\r\n    if (p1.y > p2.y) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (top && top >= bounds.left && top <= bounds.right) {\r\n      // intersects top wall\r\n      p1 = P(top, bounds.top);\r\n    }\r\n    if (bottom && bottom >= bounds.left && bottom <= bounds.right) {\r\n      // intersects bottom wall\r\n      p2 = P(bottom, bounds.bottom);\r\n    }\r\n\r\n    let clipped = new Segment(null, p1, p2);\r\n    clipped.parent = line;\r\n    return clipped;\r\n  }\r\n}\r\n\r\nexport { Segment };\r\n","import { Point } from './model/point';\r\nimport { Line } from './model/line';\r\nimport { Segment } from './model/segment';\r\nimport { Circle } from './model/circle';\r\nimport { distanceSquared as dd } from './calc';\r\n\r\nimport uniq from 'uniq';\r\n\r\nlet P = Point.P;\r\n\r\n/* helpers */\r\nfunction comparePoints(p, q) {\r\n  return p.x === q.x && p.y === q.y ? 0 : 1;\r\n}\r\n\r\nfunction sq(a) {\r\n  return a * a;\r\n}\r\n\r\nfunction between(x, a, b) {\r\n  let left = Math.min(a, b),\r\n    right = Math.max(a, b);\r\n  return left <= x && x <= right;\r\n}\r\n\r\n/*\r\n  Intersection of two objects; returns an array, possibly empty, of \r\n  intersection points.\r\n*/\r\n\r\n/**\r\n * intersect - Find the intersection(s) of the given two objects.\r\n *\r\n * @param  {Geom} o1 first object\r\n * @param  {Geom} o2 second object\r\n * @return {Array.<Point>}    Points of intersection between the two objects.\r\n */\r\nfunction intersect(o1, o2) {\r\n  if (o1 instanceof Circle && o2 instanceof Circle)\r\n    // circle-circle\r\n    return intersectCircleCircle(o1, o2);\r\n  // if only one is a circle, it should be first.\r\n  else if (o2 instanceof Circle) return intersect(o2, o1);\r\n  else if (o1 instanceof Circle && o2 instanceof Segment)\r\n    // circle-segment\r\n    return intersectCircleLine(o1, o2, true);\r\n  else if (o1 instanceof Circle && o2 instanceof Line)\r\n    // circle-line\r\n    return intersectCircleLine(o1, o2, false);\r\n  else if (o1 instanceof Segment && o2 instanceof Segment)\r\n    // segment-segment\r\n    return intersectLineLine(o1, o2, true);\r\n  // if only one is a segment, it should be first.\r\n  else if (o2 instanceof Segment) return intersect(o2, o1);\r\n  else if (o1 instanceof Line && o2 instanceof Line)\r\n    // line-line\r\n    return intersectLineLine(o1, o2, false);\r\n  // TODO: circle-point, segment-point, point-point\r\n  else if (o2 instanceof Point || o1 instanceof Point) return [];\r\n  else throw new Error('Cannot intersect ' + o1.constructor.name + ' and ' + o2.constructor.name);\r\n}\r\n\r\nfunction intersectCircleCircle(c1, c2) {\r\n  let dsq = dd(c1.center, c2.center);\r\n  let d = Math.sqrt(dsq);\r\n\r\n  if (d > c1.radius + c2.radius) {\r\n    return [];\r\n  } else if (d < c1.radius - c2.radius) {\r\n    return [];\r\n  } else if (dsq === 0) {\r\n    return [];\r\n  }\r\n\r\n  let a = (c1.radiussq - c2.radiussq + dsq) / (2 * d);\r\n  let h = Math.sqrt(Math.max(c1.radiussq - sq(a), 0));\r\n  let cx = c1.center.x + (a * (c2.center.x - c1.center.x)) / d;\r\n  let cy = c1.center.y + (a * (c2.center.y - c1.center.y)) / d;\r\n\r\n  let nx = (h * (c1.center.y - c2.center.y)) / d;\r\n  let ny = (h * (c1.center.x - c2.center.x)) / d;\r\n\r\n  return uniq([P(0, cx + nx, cy - ny), P(1, cx - nx, cy + ny)], comparePoints);\r\n}\r\n\r\nfunction intersectLineLine(s1, s2, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s1._p;\r\n  let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = s2._p;\r\n  let s = (-s1.dy * (x1 - x3) + s1.dx * (y1 - y3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n  let t = (s2.dx * (y1 - y3) - s2.dy * (x1 - x3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n\r\n  if (!clip || (between(s, 0, 1) && between(t, 0, 1))) return [P(0, x1 + t * s1.dx, y1 + t * s1.dy)];\r\n  else return []; // no collision\r\n}\r\n\r\n/* http://mathworld.wolfram.com/Circle-LineIntersection.html */\r\nfunction intersectCircleLine(c, s, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s._p;\r\n  let { x: x0, y: y0 } = c.center;\r\n\r\n  // note the translation (x0, y0)->(0,0).\r\n  let D = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0);\r\n  let Dsq = sq(D);\r\n\r\n  let lensq = sq(s.dx) + sq(s.dy);\r\n  let disc = Math.sqrt(sq(c.radius) * lensq - Dsq);\r\n  if (disc < 0) {\r\n    return [];\r\n  }\r\n\r\n  let cx = (D * s.dy) / lensq,\r\n    cy = (-D * s.dx) / lensq;\r\n  let nx = ((s.dy < 0 ? -1 * s.dx : s.dx) * disc) / lensq,\r\n    ny = (Math.abs(s.dy) * disc) / lensq;\r\n\r\n  // translate (0,0)->(x0, y0).\r\n  return uniq([P(0, cx + nx + x0, cy + ny + y0), P(1, cx - nx + x0, cy - ny + y0)], comparePoints).filter((p) =>\r\n    clip ? between(p.x, x1, x2) && between(p.y, y1, y2) : true\r\n  );\r\n}\r\n\r\nexport { intersect, intersectCircleCircle, intersectCircleLine, intersectLineLine };\r\n","import { Point } from './point';\r\nimport { Geom } from './geom';\r\n\r\nimport { intersect } from '../intersection';\r\n\r\nclass Intersection extends Point {\r\n  /**\r\n   * @param {string} name\r\n   * @param {...Geom} objects to be intersected\r\n   * @param {number|Geom~boolean} [which] optional array index or filter callback in case there are multiple intersections.\r\n   */\r\n  constructor(name, ...objects) {\r\n    if (name instanceof Geom) {\r\n      objects.shift(name);\r\n      name = null;\r\n    }\r\n    super(name, null, null);\r\n\r\n    this.which = /function|number/.test(typeof objects[objects.length - 1]) ? objects.pop() : 0;\r\n    this.objects = objects;\r\n    this.free = false;\r\n  }\r\n\r\n  update() {\r\n    let result = intersect.apply(null, this.objects);\r\n    if (typeof this.which === 'function') result = result.filter(this.which)[0];\r\n    else result = result[this.which];\r\n\r\n    if (result) {\r\n      ({ x: this.x, y: this.y } = result);\r\n    } else {\r\n      this.x = this.y = null;\r\n    }\r\n  }\r\n\r\n  toString(verbose) {\r\n    let pstr = super.toString();\r\n    return !verbose ? pstr : pstr + '; intersection of: ' + this.objects.map((o) => o.toString()).join(',');\r\n  }\r\n}\r\n\r\nexport { Intersection };\r\n","import { Point } from './point';\r\nimport { Circle } from './circle';\r\nimport { Line } from './line';\r\nimport { Segment } from './segment';\r\nimport { Intersection } from './intersection';\r\n\r\nconst P = Point.P;\r\nexport { P, Point, Circle, Segment, Line, Intersection };\r\n\r\n/* return a deep-equality test function that checks for geometric object\r\n   equality using the given distance threshold for point equality; i.e., if \r\n   two points are closer than `threshold`, consider them equal. */\r\nexport function equalWithin(threshold) {\r\n  threshold = threshold || 0;\r\n  return function equal(o1, o2) {\r\n    if (Array.isArray(o1) && Array.isArray(o2)) {\r\n      return o1.every((obj, index) => equal(obj, o2[index]));\r\n    }\r\n    if (typeof o1 === 'number' && typeof o2 === 'number') {\r\n      return Math.abs(o1 - o2) < threshold;\r\n    }\r\n    if (o1 instanceof Point && o2 instanceof Point) {\r\n      if (o1.x === null || o2.x === null || o1.y === null || o2.y === null) return false;\r\n      else return equal(Math.abs(o1.x - o2.x) + Math.abs(o1.y - o2.y), 0);\r\n    }\r\n    if (o1 instanceof Circle && o2 instanceof Circle) {\r\n      return equal(o1.radius, o2.radius) && equal(o1.center, o2.center);\r\n    }\r\n    if (o1 instanceof Segment && o2 instanceof Segment) {\r\n      var p1 = [].concat(o1.p),\r\n        p2 = [].concat(o2.p);\r\n      // ensure points from both segments are in the same order\r\n      // (left to right or right to left).\r\n      if (p1[0].x > p1[1].x && p2[0].x < p2[0].x) p1.reverse();\r\n      // then delegate to point equality\r\n      return equal(p1, p2);\r\n    }\r\n    if (o1 instanceof Line && o2 instanceof Line) {\r\n      return equal(o1.m, o2.m) && equal(o1.y(0), o2.y(0)) && equal(o1.x(0), o2.x(0));\r\n    }\r\n\r\n    // fallback to object equality\r\n    return o1 === o2;\r\n  };\r\n}\r\n","import * as d3 from 'd3';\r\nimport { Circle, equalWithin, Intersection, Line, Point, Segment } from './model';\r\n\r\nfunction addClass(obj, klass) {\r\n  obj.classes = obj.classes || d3.set();\r\n  obj.classes.add(klass);\r\n}\r\n\r\nclass Scene {\r\n  constructor(bounds) {\r\n    this.bounds = bounds;\r\n    this.bounds.width = this.bounds.right - this.bounds.left;\r\n    this.bounds.height = this.bounds.bottom - this.bounds.top;\r\n\r\n    this._last = null; // hack -- should be keeping objects in ordered structure anyway.\r\n    this._objects = d3.map();\r\n    this.equal = equalWithin(Math.sqrt(2));\r\n    this.log = [];\r\n  }\r\n\r\n  /* return an array of all Points in the scene */\r\n  points() {\r\n    return this._objects.values().filter((o) => o instanceof Point);\r\n  }\r\n\r\n  /* return an array of all objects in the scene */\r\n  objects() {\r\n    return this._objects.values();\r\n  }\r\n\r\n  /* find the given object is in the scene using geometric\r\n  (i.e. deep) equality rather than reference ===. */\r\n  find(obj) {\r\n    let objects = this._objects.values();\r\n    for (let i = 0; i < objects.length; i++) {\r\n      if (this.equal(objects[i], obj)) return objects[i];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * is - Get an equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is geometrically equal to obj.\r\n   */\r\n  is(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && this.equal(obj, secondObj);\r\n  }\r\n\r\n  /**\r\n   * is - Get an NON-equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is NOT geometrically equal to obj.\r\n   */\r\n  isnt(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && !this.equal(obj, secondObj);\r\n  }\r\n\r\n  last() {\r\n    return this._last;\r\n  }\r\n\r\n  get(name) {\r\n    return this._objects.get(name);\r\n  }\r\n\r\n  point(name, x, y) {\r\n    return this.add(new Point(name, x, y));\r\n  }\r\n\r\n  circle(name, centerId, radius) {\r\n    return this.add(new Circle(name, this.get(centerId), radius));\r\n  }\r\n\r\n  segment(name, id1, id2) {\r\n    return this.add(new Segment(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  line(name, id1, id2) {\r\n    return this.add(new Line(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  intersection(name, id1, id2, which) {\r\n    if (typeof id2 === 'undefined') {\r\n      id2 = id1;\r\n      id1 = name;\r\n      name = null;\r\n    }\r\n\r\n    let o1 = this.get(id1),\r\n      o2 = this.get(id2);\r\n    if (!o1) throw new Error(\"Can't find object \" + id1);\r\n    if (!o2) throw new Error(\"Can't find object \" + id2);\r\n\r\n    return this.add(new Intersection(name, o1, o2, which));\r\n  }\r\n\r\n  group(tag) {\r\n    this._currentTag = tag;\r\n    return this;\r\n  }\r\n\r\n  add(object) {\r\n    // if we already have this object, and it's the same type, then update the\r\n    // existing one in place.\r\n    let existing = this._objects.get(object.name);\r\n    if (existing && existing.constructor.name === object.constructor.name) {\r\n      for (let prop in object) existing[prop] = object[prop];\r\n      object = existing;\r\n    }\r\n    // if an object of the same name but different type or an object that is\r\n    // geometrically equivalent already exists in the scene, do nothing.\r\n    else if (existing || (existing = this.find(object))) {\r\n      return this;\r\n    }\r\n    // add a new object to the scene.\r\n    else {\r\n      object.name = object.name || this.freeName();\r\n      this._objects.set(object.name, object);\r\n    }\r\n\r\n    if (this._currentTag) addClass(object, this._currentTag);\r\n    if (object.free) addClass(object, 'free-point');\r\n\r\n    this.update(object);\r\n\r\n    this._last = object;\r\n    return this;\r\n  }\r\n\r\n  freeName() {\r\n    let keys = this._objects.keys(),\r\n      id = 0;\r\n    for (; keys.indexOf('object' + id) >= 0; id++);\r\n    return 'object' + id;\r\n  }\r\n\r\n  /**\r\n   * update - Update objects to reflect changes in dependent objects. (E.g.,\r\n   * update Intersection coordinates when the intersected objects have changed.)\r\n   *\r\n   * @param {Geom} root The object from which to start walking the dependency graph.\r\n   */\r\n  // TODO: respect `root` parameter, and do an actual DAG walk.\r\n  update(root) {\r\n    this._objects\r\n      .values()\r\n      .filter((obj) => obj instanceof Intersection)\r\n      .forEach((obj) => obj.update());\r\n  }\r\n\r\n  logState(label) {\r\n    let self = this;\r\n    let objects = this._objects.values();\r\n    let points = this.points();\r\n\r\n    let state = {\r\n      label,\r\n      time: new Date().toString(),\r\n      objects: objects.map((o) => o.toString())\r\n    };\r\n    this.log.push(state);\r\n  }\r\n}\r\n\r\nexport { Scene };\r\n","import * as d3 from 'd3';\r\nimport { Circle, Line, Point, Segment } from './model';\r\n\r\nfunction klasses() {\r\n  let init = Array.prototype.slice.call(arguments, 0);\r\n  return (d) => init.concat(d.classes ? d.classes.values() : []).join(' ');\r\n}\r\n\r\nfunction renderGeometry(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* circles */\r\n  let circles = svg.selectAll('g.circle').data(scene.objects().filter((d) => d instanceof Circle));\r\n\r\n  let circleGroup = circles\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('circle'));\r\n  circleGroup.append('circle').attr('class', 'handle');\r\n  circleGroup.append('circle').attr('class', 'visible');\r\n\r\n  circles\r\n    .attr('class', klasses('circle'))\r\n    .selectAll('circle')\r\n    .attr('cx', (d) => d.center.x)\r\n    .attr('cy', (d) => d.center.y)\r\n    .attr('r', (d) => d.radius);\r\n\r\n  circles.exit().remove();\r\n\r\n  /* lines */\r\n  let lines = svg.selectAll('g.line').data(scene.objects().filter((d) => d instanceof Line));\r\n\r\n  let lineGroup = lines\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('line'));\r\n  lineGroup.filter((d) => d instanceof Segment).attr('class', klasses('line', 'segment'));\r\n  lineGroup.append('line').attr('class', 'handle');\r\n  lineGroup.append('line').attr('class', 'visible');\r\n\r\n  // TODO: this is grossly inefficient\r\n  function endpoint(index, coord) {\r\n    return (d) => {\r\n      let s = d instanceof Segment ? d : Segment.clip(scene.bounds, d);\r\n      return s.p[index][coord];\r\n    };\r\n  }\r\n\r\n  lines\r\n    .attr('class', klasses('line'))\r\n    .selectAll('line')\r\n    .attr('x1', endpoint(0, 'x'))\r\n    .attr('y1', endpoint(0, 'y'))\r\n    .attr('x2', endpoint(1, 'x'))\r\n    .attr('y2', endpoint(1, 'y'));\r\n\r\n  lines.exit().remove();\r\n}\r\n\r\nfunction renderPoints(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* points */\r\n  let points = svg.selectAll('circle.point').data(scene.objects().filter((d) => d instanceof Point));\r\n\r\n  points\r\n    .enter()\r\n    .append('circle')\r\n    .attr('class', klasses('point'))\r\n    .attr('cx', (d) => d.x)\r\n    .attr('cy', (d) => d.y)\r\n    .attr('r', (d) => 5);\r\n\r\n  points\r\n    .enter()\r\n    .append('text')\r\n    .attr('class', klasses('point-name'))\r\n    .attr('x', (d) => d.x + 10)\r\n    .attr('y', (d) => d.y - 15)\r\n    .attr('id', (d) => `point-${d.name}`);\r\n\r\n  points.enter()._groups[0].forEach((node) => {\r\n    const name = node.__data__.name;\r\n    document.getElementById(`point-${name}`).appendChild(document.createTextNode(name));\r\n  });\r\n\r\n  points.exit().remove();\r\n}\r\n\r\nexport { renderGeometry, renderPoints };\r\n","import * as React from 'react';\r\nimport { Scene } from '../../../vendor/euclid';\r\nimport { renderGeometry, renderPoints } from '../../../vendor/euclid/render';\r\nimport type { DrawingDataType } from '../../../utils/types';\r\nimport './DrawingPanel.scss';\r\ntype PropsType = {\r\n  drawingData: DrawingDataType\r\n};\r\n\r\nclass DrawingPanel extends React.Component<PropsType> {\r\n  componentDidMount() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  renderGeometry(drawingData: DrawingDataType) {\r\n    const svg = document.getElementById('geometry');\r\n\r\n    while (svg.firstChild) {\r\n      svg.firstChild.remove();\r\n    }\r\n    const pointElements = document.getElementById('points');\r\n    while (pointElements.firstChild) {\r\n      pointElements.firstChild.remove();\r\n    }\r\n\r\n    const { points, segments, circles } = drawingData;\r\n    const viewBox = svg.viewBox.baseVal;\r\n    const width = viewBox.width;\r\n    const height = viewBox.height;\r\n\r\n    const scene = new Scene({\r\n      left: viewBox.x,\r\n      top: viewBox.y,\r\n      right: viewBox.x + width,\r\n      bottom: viewBox.y + height\r\n    });\r\n\r\n    const arrX = [];\r\n    const arrY = [];\r\n    points.forEach((point) => {\r\n      arrX.push(point.coordinate.x);\r\n      arrY.push(point.coordinate.y);\r\n    });\r\n\r\n    const disparityX = Math.max(...arrX) - Math.min(...arrX);\r\n    const disparityY = Math.max(...arrY) - Math.min(...arrY);\r\n    let ratio = 0;\r\n    const ODD = 15;\r\n    if (disparityX / disparityY >= 1) {\r\n      // scale theo width\r\n      // giá trị ước lượng (ODD): nhằm tránh điểm render ngay cạnh của viewBox sẽ làm mất tên điểm\r\n      ratio = Math.floor(width / disparityX) - ODD;\r\n    } else {\r\n      ratio = Math.floor(height / disparityY) - ODD;\r\n    }\r\n\r\n    const anchorX = Math.min(...arrX) + disparityX / 2;\r\n    const anchorY = Math.min(...arrY) + disparityY / 2;\r\n    points.forEach((point) => {\r\n      scene.point(\r\n        point.id,\r\n        point.coordinate.x * ratio + width / 2 - ratio * anchorX,\r\n        point.coordinate.y * ratio + height / 2 - ratio * anchorY\r\n      );\r\n    });\r\n\r\n    segments.forEach((segment) => {\r\n      if (segment && segment.visible) {\r\n        scene.segment(segment.name, segment.name[0], segment.name[1]);\r\n      }\r\n    });\r\n\r\n    if (circles) {\r\n      Object.keys(circles).forEach((point) => {\r\n        scene.point(\r\n          point,\r\n          circles[point].center.x * ratio + width / 2 - ratio * anchorX,\r\n          circles[point].center.y * ratio + height / 2 - ratio * anchorY\r\n        );\r\n        scene.circle(`circle-${point}`, point, circles[point].radius * ratio);\r\n      });\r\n    }\r\n\r\n    scene.update();\r\n    renderGeometry(scene, svg);\r\n    renderGeometry(scene, svg);\r\n    renderPoints(scene, pointElements);\r\n  }\r\n\r\n  render(): React.Node {\r\n    return (\r\n      <div className=\"geometry-container\">\r\n        <svg id=\"geometry\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n        <svg id=\"points\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DrawingPanel;\r\n","import React from 'react';\r\nimport './css/MainView.scss';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';\r\n\r\nimport DataViewModel from '../ViewModel/DataViewModel';\r\n\r\nimport { Icon, InputItem, SegmentSetting } from './components';\r\nimport { DrawingPanel } from './components/DrawingPanel';\r\nimport { calculateDistanceTwoPoints, calculateVector, isVectorSameDirection } from '../core/math/Math2D';\r\nimport type { DrawingSegmentType, SegmentDataType } from '../utils/types';\r\nimport GConst from '../utils/values';\r\n\r\n@observer\r\nclass MainView extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.inputRefs = [];\r\n    this.state = {\r\n      focusIndex: 0,\r\n      points: [\r\n        { id: 'A', coordinate: { x: 0, y: 0, z: 0 } },\r\n        { id: 'B', coordinate: { y: 5, x: -7 } },\r\n        { id: 'C', coordinate: { x: -9, y: 4.0901353661613005 } },\r\n        { id: 'H', coordinate: { x: -3.0849364905389067, y: 6.781088913245535 } },\r\n        { id: 'D', coordinate: { x: -5.250000000000003, y: 3.7500000000000018 } },\r\n        { id: 'E', coordinate: { x: -8, y: 9.794855240493977 } }\r\n      ],\r\n      segments: [\r\n        'AB',\r\n        'BC',\r\n        'AC',\r\n        'AH',\r\n        'DH',\r\n        'DE',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA'\r\n      ],\r\n      drawingSegments: []\r\n    };\r\n    this.scrollView = React.createRef();\r\n  }\r\n\r\n  componentWillMount() {\r\n    const { points, segments } = this.state;\r\n    this.setState({\r\n      drawingSegments: this.trimDrawingData({ points, segments }).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  scrollToBottom() {\r\n    if (this.scrollView.current) {\r\n      setTimeout(() => {\r\n        this.scrollView.current.firstChild.scrollIntoView(false);\r\n      }, 250);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  trimDrawingData(data) {\r\n    const { points, segments } = data;\r\n\r\n    //change to DataViewModel.getNodeInPointsMapById.coordinate when refactor done\r\n    const pointData = {};\r\n    points.forEach((point) => {\r\n      pointData[point.id] = point.coordinate;\r\n    });\r\n\r\n    const segmentsData = {};\r\n    let result = [];\r\n    points.forEach((point) => {\r\n      segmentsData[point.id] = segments\r\n        .map((segment: string): string =>\r\n          segment\r\n            .split('')\r\n            .sort()\r\n            .join('')\r\n        )\r\n        .filter((segment: string): boolean => segment.includes(point.id))\r\n        .map((segment: string): SegmentDataType => {\r\n          const firstPoint = pointData[segment[0]];\r\n          const secondPoint = pointData[segment[1]];\r\n          return {\r\n            name: segment,\r\n            vector: calculateVector(firstPoint, secondPoint),\r\n            length: calculateDistanceTwoPoints(firstPoint, secondPoint)\r\n          };\r\n        });\r\n    });\r\n\r\n    const removeSegments = [];\r\n\r\n    Object.keys(segmentsData).forEach((point) => {\r\n      if (segmentsData[point].length > 0) {\r\n        const segments = this.uniqueSegmentData(segmentsData[point], removeSegments);\r\n        result = result.concat(segments);\r\n      }\r\n    });\r\n\r\n    result = [...new Set(result)].filter((segment: string): boolean => segment[0] !== segment[1]);\r\n\r\n    return result;\r\n  }\r\n\r\n  uniqueSegmentData(data: Array<SegmentDataType>, removeSegments: Array<string>): Array<string> {\r\n    let result = [data[0]];\r\n    for (let i = 1; i < data.length; i++) {\r\n      const segmentData = data[i];\r\n\r\n      const length = result.length;\r\n      let replaceIndex = -1;\r\n      for (let j = 0; j < length; j++) {\r\n        if (isVectorSameDirection(segmentData.vector, result[j].vector)) {\r\n          if (segmentData.length >= result[j].length) {\r\n            replaceIndex = j;\r\n          } else {\r\n            removeSegments.push(segmentData.name);\r\n          }\r\n        }\r\n      }\r\n      if (replaceIndex >= 0) {\r\n        result[replaceIndex] = segmentData;\r\n      } else {\r\n        if (!removeSegments.includes(segmentData.name)) {\r\n          result.push(segmentData);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result.map((segmentData: SegmentDataType): string => segmentData.name);\r\n  }\r\n\r\n  @autobind\r\n  onValueChange(value: string, index: number) {\r\n    DataViewModel.RelationsInput[index].value = value;\r\n    this.setState({ focusIndex: index });\r\n  }\r\n\r\n  @autobind\r\n  onSubmit(index: number) {\r\n    if (index === DataViewModel.RelationsInput.length - 1 && DataViewModel.RelationsInput[index].value.length > 2) {\r\n      DataViewModel.addNewInput();\r\n    }\r\n\r\n    this.setState({ focusIndex: index + 1 });\r\n  }\r\n\r\n  @autobind\r\n  onBackspace(index: number) {\r\n    const value = DataViewModel.RelationsInput[index].value;\r\n    if (value.length === 0 && DataViewModel.RelationsInput.length > 1) {\r\n      DataViewModel.removeInput(index);\r\n      this.inputRefs.splice(index, 1);\r\n      this.setState({ focusIndex: index - 1 });\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onClickDrawing() {\r\n    DataViewModel.getData.clear();\r\n\r\n    const data = DataViewModel.analyzeInput();\r\n    if (data.points.length === 0 && data.segments.length === 0) {\r\n      DataViewModel.resetInputsStatus();\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      points: data.points,\r\n      segments: data.segments,\r\n      drawingSegments: this.trimDrawingData(data).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    const { focusIndex } = this.state;\r\n    if (this.inputRefs[focusIndex]) {\r\n      this.inputRefs[focusIndex].focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  renderRelationInput(): React.Node {\r\n    return DataViewModel.RelationsInput.map((model, index) => {\r\n      return (\r\n        <InputItem\r\n          key={`input-${index}`}\r\n          ref={(ref) => {\r\n            this.inputRefs[index] = ref;\r\n          }}\r\n          onValueChange={(value: string) => {\r\n            this.onValueChange(value, index);\r\n          }}\r\n          onSubmit={() => {\r\n            this.onSubmit(index);\r\n          }}\r\n          onBackspace={() => {\r\n            this.onBackspace(index);\r\n          }}\r\n          value={model.value}\r\n          status={model.status}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onDoneSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n    if (JSON.stringify(data) === JSON.stringify(drawingSegments[index])) {\r\n      return;\r\n    }\r\n\r\n    const isAddSegment = !!drawingSegments[index];\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments }, () => {\r\n      if (isAddSegment) {\r\n        if (drawingSegments.map((segment: SegmentDataType): string => segment.name).includes(data.name)) {\r\n          this.onDeleteSegmentSetting(index);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onChangeSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  onDeleteSegmentSetting(index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments.splice(index, 1);\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  addNewSegmentSetting() {\r\n    if (this.state.drawingSegments.includes(undefined)) {\r\n      return;\r\n    }\r\n    this.scrollToBottom();\r\n    this.setState((prevState) => ({\r\n      drawingSegments: prevState.drawingSegments.concat([undefined])\r\n    }));\r\n  }\r\n\r\n  @autobind\r\n  renderSegmentSettings(): React.Node {\r\n    const { drawingSegments } = this.state;\r\n    const points = this.state.points.map((point: NodeType): number => point.id);\r\n\r\n    return drawingSegments.map((segment: DrawingSegmentType, index: number): React.Node => {\r\n      return (\r\n        <SegmentSetting\r\n          key={`segment-setting-${index}`}\r\n          data={points}\r\n          value={segment}\r\n          onDone={(value) => {\r\n            this.onDoneSegmentSetting(value, index);\r\n          }}\r\n          onVisibleChange={(value) => {\r\n            this.onChangeSegmentSetting(value, index);\r\n          }}\r\n          onDelete={() => {\r\n            this.onDeleteSegmentSetting(index);\r\n          }}\r\n          style={index === 0 ? { marginTop: '1rem' } : {}}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { points, drawingSegments, segments } = this.state;\r\n    return (\r\n      <div className={'container-fluid'}>\r\n        <div className={'app-header'}>\r\n          <div className={'app-name'}>\r\n            <p>Gemath</p>\r\n          </div>\r\n\r\n          <div className={'app-description'}>\r\n            <p>app description</p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"app-body\">\r\n          <div className=\"app-controller\">\r\n            <div className=\"accordion\" id=\"accordionExample\">\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingOne\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewOne\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseOne\">\r\n                  <p>1. Nhập đề</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <div>{GConst.TutorialString.STEP_ONE}</div>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div\r\n                  id=\"viewOne\"\r\n                  className=\"collapse show\"\r\n                  aria-labelledby=\"headingOne\"\r\n                  data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\">\r\n                    <div>\r\n                      {this.renderRelationInput()}\r\n                      <Button\r\n                        type=\"button\"\r\n                        className=\"btn btn-success w-100\"\r\n                        onClick={this.onClickDrawing}\r\n                        disabled={DataViewModel.isInputEmpty}>\r\n                        Vẽ hình\r\n                      </Button>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingTwp\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewTwo\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseTwp\">\r\n                  <p>2. Chỉnh sửa hình</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <span>\r\n                          Thêm/Xóa các doạn thẳng\r\n                        </span>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div id=\"viewTwo\" className=\"collapse \" aria-labelledby=\"headingOne\" data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\" ref={this.scrollView}>\r\n                    <div>\r\n                      {this.renderSegmentSettings()}\r\n                      <div className={'add-row-container'} onClick={this.addNewSegmentSetting}>\r\n                        <Icon name={'icAdd'} width={35} height={35} color={'#757575'} />\r\n                        <p>Thêm đoạn thẳng</p>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className={'app-drawing-panel'}>\r\n            <DrawingPanel drawingData={{ points, segments: drawingSegments, circles: DataViewModel.circlesData }} />\r\n          </div>\r\n        </div>\r\n\r\n        <div className={'app-footer'}>\r\n          <p>abc</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MainView;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainView from './View/MainView';\r\n\r\nReactDOM.render(<MainView />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};"],"sourceRoot":""}