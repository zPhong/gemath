{"version":3,"sources":["serviceWorker.js","Model/AppData.js","core/definition/define.js","utils/values.js","core/math/Converter.js","core/math/Generation.js","utils/ErrorHandleService.js","core/math/Math2D.js","utils/checker.js","core/definition/defineObjType.js","core/validation/validation.js","core/definition/index.js","core/definition/defineShapeType.js","core/definition/definePointType.js","core/math/GenerateGeometry.js","core/analysis/ReadPointsMap.js","core/analysis/ReadRelation.js","core/analysis/Analysis.js","Model/RelationInputModel.js","ViewModel/DataViewModel.js","View/components/InputItem/InputItem.js","View/components/Icon/Icon.js","View/components/Icon/Svg.js","View/components/SegmentSetting/SegmentSetting.js","vendor/euclid/model/geom.js","vendor/euclid/model/point.js","vendor/euclid/calc.js","vendor/euclid/model/circle.js","vendor/euclid/model/line.js","vendor/euclid/model/segment.js","vendor/euclid/intersection.js","vendor/euclid/model/intersection.js","vendor/euclid/model/index.js","vendor/euclid/scene.js","vendor/euclid/render.js","View/components/DrawingPanel/DrawingPanel.js","View/MainView.js","index.js","utils/color.scss","View/components/InputItem/InputItem.scss"],"names":["Boolean","window","location","hostname","match","appData","AppData","Object","classCallCheck","this","additionSegment","relationsResult","pointsMap","pointsDirectionMap","executedRelations","executedNode","__pointDetails__","Map","clear","segment","push","newPointsMap","value","defineSentences","define","relation","shape","reversedDependentObjRelation","RankingObjectContain","objectWithPoint","validate","object","point","length","format","ray","line","angle","triangle","quadrilateral","trapezoid","parallelogram","rectangle","rhombus","square","circle","shapeType","shapeRules","right","isosceles","right_isosceles","equilateral","normal","mappingShapeType","vuông","cân","vuông cân","đều","nội tiếp","ngoại tiếp","circleType","TwoStaticPointRequireShape","ShapeAffectBySegmentChange","GConst","Number","freeze","MIN_RANDOM_NUMBER","MAX_RANDOM_NUMBER","MIN_RANDOM_GENERATION","MAX_RANDOM_GENERATION","NOT_FOUND","String","INFINITY","IMPOSSIBLE","TOO_SHORT","NOT_ENOUGH_SET","NOT_BE_IN_LINE","Regex","KEY","OTHER","Others","OPERATIONS","Errors","UNDEFINED_ERROR","WRONG_FORMAT","MAXIMUM_POINT_ERROR","InputStatus","SUCCESS","NORMAL","ERROR","TutorialString","STEP_ONE","convertLinearToEquation","l","a","b","c","d","e","convertEquationToLineType","convertLineTypeToEquation","MIN","MAX","getRandomValue","min","max","Math","floor","random","getRandomPointInEquation","equation","tempX","x","y","centerPoint","radius","sqrt","randomValueX","solvedValueY","calculateQuadraticEquation","secondRoot","firstRoot","generatePointAlignmentInside","firstPoint","secondPoint","getLineFromTwoPoints","generatePointAlignmentOutside","isRight","arguments","undefined","tempXRight","tempXLeft","ErrorCode","200","300","301","400","401","500","501","502","ErrorService","message","code","errorRelation","index","dataViewModel","inputData","filter","data","executedInputIndex","executingRelation","RelationsInput","status","alert","console","error","_makeRound","num","f","isNaN","myF","pow","round","calculateVector","calculateMiddlePoint","calculateSymmetricalPoint","p1","p2","directionVector","normalVector","calculateDistanceTwoPoints","squareX","squareY","calculateDistanceFromPointToLine","numerator","abs","denominator","calculateParallelLineByPointAndLine","lineEquation","parLine","result","calculatePerpendicularLineByPointAndLine","perpendicularLine","perLine","calculateIntersectionByLineAndLine","lineOne","lineTwo","calculateSetOfEquationTypeAndQuadraticEquation","calculateCircleEquationByCenterPoint","roundedRadius","calculateInternalBisectLineEquation","pointOne","pointTwo","results","_calculateBisectLineEquation","firstLine","secondLine","getAngleFromTwoLines","set","_getInternalBisectLineEquation","resultOne","resultTwo","coefficient","calculateIntersectionEquationTypeWithCircleEquation","q","A","B","delta","isIn","p","C","D","E","F","G","H","root","r1","r2","calculateIntersectionTwoCircleEquations","firstEquation","secondEquation","q1","q2","d1","d2","tempY","calculateSetOfEquationTypes","Z","_D","_E","_G","roots","calculateLinesByAnotherLineAndAngle","rootPoint","staticPoint","dynamicPoint","equations","cosine","cos","PI","_calculateLinesByAnotherLineAndAngle","map","newRootPoint","i","vectorOne","vectorTwo","staticVector","dynamicVector","acos","calculateIntegratedDirection","calculateVectorLength","parseInt","showError","vector","makeRoundCoordinate","a1","a2","b1","b2","getMiddlePointFromThreePointsInALine","p3","dis_p1_p2","dis_p2_p3","dis_p1_p3","calculateTangentEquation","tangentPoint","tangentEquation","isNumber","isObjectLike","getTag","isQuadraticEquation","toString","call","checkFormatString","str","split","forEach","element","char","toLowerCase","defineObject","slice","includes","validateObject","validateValue","type","_validateName","validateType","validateGeometryType","key","validateAngle","checkObjectRelationship","obj1","obj2","check","toConsumableArray","Set","indexOf","string","item","array","validateInformation","info","outputType","keys","validateShapeFormat","validateShapeType","shapeFormatCheck","shapeTypeCheck","validateShape","j","indexOfRankingLevel","indexOfObjectCurrentLevel","indexOfObjectNextLevel","validateDataRelationship","defineInformation","splitter","shapeName","pop","otherData","replace","trim","join","log","defineShapeType","definePointType","reverse","sortString","toUpperCase","Error","sort","geometricObj","name","z","updateCoordinate","distance_From_A_To_B","linearEquation","coefficientX","constantTerm","p4","distanceX","p4X","readRelation","equationResults","operation","objectType","valueData","objectsIncludePoint","isStatic","objPoint","isStaticNodeById","getNodeInPointsMapById","coordinate","staticValue","staticObject","angleName","angleValue","modifiedAngleName","shapeList","getData","shapes","shapeData","getShapeAffectList","concat","secondLineVector","firstVector","secondVector","renameAngle","changedPoint","calculatedEquation","intersectPoint","transitionVector","rootOne","rootTwo","replaceSetOfEquation","calculateLineEquationByAngleRelation","staticPointOne","staticPointTwo","staticLineEquation","staticDistance","isAlign","coefficientY","ratio","calculatedPoint","betweenPoint","analyzeOperationType","segmentIncludePoint","segmentNotIncludePoint","relationType","getCircleEquation","otherStaticPoint","otherStaticNodeInSegment","points","getAdditionSegment","isValidCoordinate","generatePointMiddleTwoPoints","calculatedLineEquation","isInStaticLine","pushAdditionSegment","isExternal","internalLine","JSON","stringify","calculateExternalBisectLineEquation","analyzeRelationType","calculatedLineEquationOne","calculatedLineEquationTwo","analyzeIntersectRelation","otherPointInSegment","tangentPointCoordinate","circleEquation","exceptionPoint","center","calculateTangentIntersectPointsByPointOutsideCircle","filterRoots","isCoordinateDuplicated","filterTangentPoint","analyzeTangentRelation","count","limit","executeRelations","node","dependentNodes","temp","_makeUniqueNodeRelation","relationEquation","calculateInCircleEquation","calculateCircumCircleEquation","circlesData","ErrorMessage","isExecutedRelation","generateFunc","generateGeometry","pointCoordinate","rootCoordinate","getPointDirectionMap","isUp","makeCorrectShape","id","Array","isArray","executePointDetails","getExecutedRelations","rules","executePoint","staticPointCountRequire","staticPoints","arrayRules","RegExp","executePointIndex","nodeSetEquations","rule","staticLine","nonStaticLine","getLinearEquationByParallelRule","getLinearEquationByPerpendicularRule","includeLine","nonIncludeLine","staticLines","shapePoints","staticPointIndex","pointIndex","calculatedCoordinate","otherPointInIncludeLine","nonStaticPointIndex","updateCoordinateBySpecialPerpendicularRule","otherPoint","getLinearEquationsByEqualRule","RelationPointsMap","analyzeResult","validatedResult","objectPointsMap","sortPriority","getPointsMap","shouldStaticPoint","angles","getRelationsResult","relations","shapePointCount","minCountPoint","getFirstStaticPointInShape","createNode","updateMap","createPointsMapByShape","lastObjectPoints","objectName","createDependentNodeOfObject","nodeOne","nodeTwo","index1","findIndexByNodeId","index2","lastNode","nodeIndex","getDependentObject","currentNode","objectSpread","createDependentNodeOfRelation","createPointsMapByRelation","setPointsMap","unique","createPointDetails","table","isPointsMapStatic","executingNode","getNextExecuteNode","getPointDetails","has","get","isNeedRandomCoordinate","nodeDirectionInfo","staticPointCoordinate","coordinateMatch","directionInfo","matchCount","getExecutedNode","updateStaticNode","readPointsMap","segments","getShapeSegments","getArraySegments","el1","el2","exception","_dependentNodes","oldNode","RelationInputModel","initializerDefineProperty","_descriptor","_descriptor2","observable","DataViewModel","_this","DataViewModel_descriptor","DataViewModel_descriptor2","_descriptor3","pointId","nodeId","getIndexOfNodeInPointsMapById","_coordinate","isStaticNode","updatePointsMap","clonePointsMap","sortNodeByPriority","staticNodeOneCount","getDependentStaticNodeCount","nodeOneData","static","nonStatic","dependence","minRelationIndex","getMinIndexOfDependentNodeInRelationsList","getIndexOfNodeInPointsMap","staticNodeTwoCount","nodeTwoData","rankOne","rankTwo","indexArray","getIndexOfRelationInRelationsList","apply","list","_calculateSet","relationsInput","input","newRelationInput","resetInputsStatus","splice","_this2","_updatePointDetails","setOfEquation","exceptedCoordinates","searchEquation","replaceEquation","pointDetail","isReplaceComplete","pointDetails","isFirst","currentRoots","finalRoots","_this3","_string","isMatching","preProgress","sentence","getBasicInformation","_defineSentence","others","params","start","end","param","lastParam","getLength","dictionary","centerId","_this4","stringifyCoordinate","_this5","getInformation","setRelationsResult","computed","action","KEYCODE","BACKSPACE","ENTER","InputItem","props","possibleConstructorReturn","getPrototypeOf","inputRef","React","state","shouldRemove","isEmpty","current","focus","currentTarget","onValueChange","setState","_this$props","onBackspace","onSubmit","keyCode","_this$props2","react","className","Icon_Icon","width","height","color","ref","onChange","onKeyUp","aria-describedby","autobind","iconList","inputSuccess","svg","react_default","createElement","fill","viewBox","inputError","inputNormal","icInformation","icRemove","icEdit","icAdd","fillRule","clipRule","Icon","icon","SegmentSetting","visible","isEditMode","isCreateMode","isMouseHoverEdition","isMouseHoverDeletion","_this$state","onDone","onDelete","onVisibleChange","dropdownIndex","filterValue","filterValueIndex","_this$state2","newStartValue","getIndexInData","_this$state3","onSelect","DropdownButton","title","Dropdown","Item","eventKey","_this$state4","renderDropdown","onStartPointSelect","onEndPointSelect","Button","onClick","onChangeContentState","variant","disabled","_this$props$value","dist_default","onstyle","offstyle","handleClassName","off","on","active","onMouseLeave","mouseLeaveEdition","onMouseOver","mouseHoverEdition","onMouseDown","mouseHoverDeletion","mouseLeaveDeletion","renderEditContent","renderShowContent","style","_this$state5","renderContent","Geom","Point","free","esm_get","prototype","distance","distanceSquared","dx","dy","Circle","_fromCenterAndBoundaryPoint","_fromCenterAndRadius","defineProperties","radiussq","boundaryPoint","w","h","Line","_p","_clip","assertThisInitialized","theta","atan2","m","left","top","bottom","P","Segment","lengthsq","bounds","_line$_p","slicedToArray","t","clipped","parent","comparePoints","sq","between","intersect","o1","o2","c1","c2","dsq","dd","cx","cy","nx","ny","uniq","intersectCircleCircle","intersectCircleLine","intersectLineLine","constructor","s1","s2","clip","_s1$_p","_s1$_p$","x1","y1","_s1$_p$2","_s2$_p","_s2$_p$","x3","y3","_s2$_p$2","s","_s$_p","_s$_p$","_s$_p$2","x2","y2","_c$center","x0","y0","Dsq","lensq","disc","Intersection","_len","objects","_key","shift","which","test","_result","verbose","pstr","o","addClass","obj","klass","classes","d3","add","Scene","threshold","_last","_objects","equal","every","values","secondObj","id1","id2","tag","_currentTag","existing","prop","find","freeName","update","label","time","Date","klasses","init","renderGeometry","scene","svgElement","circles","selectAll","circleGroup","enter","append","attr","exit","remove","lines","lineGroup","endpoint","coord","DrawingPanel","drawingData","document","getElementById","firstChild","pointElements","baseVal","arrX","arrY","disparityX","disparityY","anchorX","anchorY","_groups","__data__","appendChild","createTextNode","renderPoints","MainView","observer","inputRefs","focusIndex","drawingSegments","scrollView","createRef","trimDrawingData","setTimeout","scrollIntoView","pointData","segmentsData","removeSegments","uniqueSegmentData","segmentData","replaceIndex","addNewInput","removeInput","analyzeInput","model","components_InputItem_InputItem","isAddSegment","onDeleteSegmentSetting","scrollToBottom","prevState","_this6","components_SegmentSetting_SegmentSetting","onDoneSegmentSetting","onChangeSegmentSetting","marginTop","data-toggle","data-target","aria-expanded","aria-controls","OverlayTrigger","container","placement","overlay","Tooltip","aria-labelledby","data-parent","renderRelationInput","onClickDrawing","isInputEmpty","renderSegmentSettings","addNewSegmentSetting","components_DrawingPanel_DrawingPanel","Component","ReactDOM","render","View_MainView","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.1d3c6467.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","// @flow\r\n\r\nclass AppData {\r\n  constructor() {\r\n    this.additionSegment = [];\r\n    this.relationsResult = {};\r\n    this.pointsMap = [];\r\n    this.pointsDirectionMap = {};\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__ = new Map();\r\n  }\r\n\r\n  clear() {\r\n    this.relationsResult = [];\r\n    this.pointsMap = [];\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__.clear();\r\n  }\r\n\r\n  set setRelationsResult(value) {\r\n    this.relationsResult = value;\r\n  }\r\n\r\n  pushAdditionSegment(segment: string) {\r\n    this.additionSegment.push(segment);\r\n  }\r\n\r\n  get getAdditionSegment() {\r\n    return this.additionSegment;\r\n  }\r\n\r\n  get getRelationsResult() {\r\n    return this.relationsResult;\r\n  }\r\n\r\n  get getPointsMap() {\r\n    return this.pointsMap;\r\n  }\r\n\r\n  setPointsMap(newPointsMap) {\r\n    this.pointsMap = newPointsMap;\r\n  }\r\n\r\n  get getPointDirectionMap() {\r\n    return this.pointsDirectionMap;\r\n  }\r\n\r\n  get getExecutedRelations() {\r\n    return this.executedRelations;\r\n  }\r\n\r\n  get getExecutedNode() {\r\n    return this.executedNode;\r\n  }\r\n\r\n  get getPointDetails() {\r\n    return this.__pointDetails__;\r\n  }\r\n}\r\n\r\nconst appData = new AppData();\r\n\r\nexport default appData;\r\n","const defineSentences = {\r\n  define: [\r\n    '{object} + {object} = {object}',\r\n    '{object} - {object} = {object}',\r\n    '{object} = {value} * {object}',\r\n    '{object} = {object}',\r\n    '{object} > {object}',\r\n    '{object} < {object}'\r\n  ],\r\n  relation: [\r\n    '{object} song song {object}',\r\n    '{object} vuông góc {object}',\r\n    '{object} cắt {object} tại {arrayPoints}',\r\n    '{object} phân giác ngoài {angle}',\r\n    '{object} phân giác trong {angle}',\r\n    '{object} phân giác {angle}',\r\n    '{arrayPoints} thẳng hàng',\r\n    '{point} trung điểm {segment}',\r\n    '{point} không thuộc {object}',\r\n    '{point} thuộc {object}',\r\n    'trung tuyến {segment} của {triangle}',\r\n    'đường cao {segment} của {triangle}',\r\n    '{segment} tiếp tuyến {circle}'\r\n  ],\r\n  shape: [\r\n    'tam giác {type triangle}',\r\n    'tứ giác {quadrilateral}',\r\n    'hình thang {type trapezoid}',\r\n    'hình bình hành {parallelogram}',\r\n    'hình chữ nhật {rectangle}',\r\n    'hình thoi {rhombus}',\r\n    'hình vuông {square}',\r\n    '{object type triangle}'\r\n  ]\r\n};\r\n\r\nconst shapeList = ['triangle', 'quadrilateral', 'trapezoid', 'parallelogram', 'rectangle', 'rhombus', 'square'];\r\n\r\nconst reversedDependentObjRelation = ['vuông góc', 'cắt'];\r\n\r\nconst RankingObjectContain = [['point'], ['segment', 'ray'], ['angle']];\r\n\r\nconst objectWithPoint = ['angle', 'segment', 'ray', 'point', 'circle'];\r\n\r\nconst validate = {\r\n  object: {\r\n    define: ['angle', 'segment'],\r\n    relation: ['ray', 'line', 'segment', 'circle']\r\n  },\r\n  point: { length: 1, format: '1' },\r\n  segment: { length: 2, format: '11' },\r\n  ray: { length: 2, format: '10' },\r\n  line: { length: 1, format: '0' },\r\n  angle: { length: 3 },\r\n  shape: {\r\n    triangle: { length: 3, format: '111' },\r\n    quadrilateral: { length: 4, format: '1111' },\r\n    trapezoid: { length: 4, format: '1111' },\r\n    parallelogram: { length: 4, format: '1111' },\r\n    rectangle: { length: 4, format: '1111' },\r\n    rhombus: { length: 4, format: '1111' },\r\n    square: { length: 4, format: '1111' },\r\n    circle: { length: 1, format: '1' }\r\n  },\r\n  shapeType: {\r\n    triangle: ['', 'vuông', 'cân', 'vuông cân', 'đều', 'nội tiếp', 'ngoại tiếp'],\r\n    trapezoid: ['', 'vuông', 'cân']\r\n  }\r\n};\r\n\r\n/*\r\n    | song song,\r\n    ^ vuông góc,\r\n    = cân\r\n */\r\nconst shapeRules = {\r\n  triangle: {\r\n    right: '01^02', // Ex: AB vuong goc AC\r\n    isosceles: '01=02',\r\n    right_isosceles: '01^02&01=02',\r\n    equilateral: '01=02&01=12&02=12'\r\n  },\r\n  trapezoid: {\r\n    normal: '01|23',\r\n    right: '01|23&01^03',\r\n    isosceles: '01|23&03=12'\r\n  },\r\n  parallelogram: {\r\n    normal: '01|23&03|12'\r\n  },\r\n  rectangle: {\r\n    normal: '01^12&12^23&23^30&30^01'\r\n  },\r\n  rhombus: {\r\n    normal: '02^13'\r\n  },\r\n  square: {\r\n    normal: '01|23&03|12&01^12&12^23&23^03&01=03&&01=12&12=23&&23=03'\r\n  }\r\n};\r\n\r\nconst mappingShapeType = {\r\n  vuông: 'right',\r\n  cân: 'isosceles',\r\n  'vuông cân': 'right_isosceles',\r\n  đều: 'equilateral',\r\n  'nội tiếp': 'nội tiếp',\r\n  'ngoại tiếp': 'ngoại tiếp'\r\n};\r\n\r\nconst circleType = ['nội tiếp', 'ngoại tiếp'];\r\n\r\nconst TwoStaticPointRequireShape = ['triangle', 'trapezoid', 'rectangle', 'square'];\r\n\r\nconst ShapeAffectBySegmentChange = ['rhombus', 'trapezoid', 'parallelogram'];\r\n\r\nexport {\r\n  validate,\r\n  TwoStaticPointRequireShape,\r\n  defineSentences,\r\n  RankingObjectContain,\r\n  objectWithPoint,\r\n  shapeList,\r\n  reversedDependentObjRelation,\r\n  shapeRules,\r\n  mappingShapeType,\r\n  circleType,\r\n  ShapeAffectBySegmentChange\r\n};\r\n","const Number = Object.freeze({\r\n  MIN_RANDOM_NUMBER: -10,\r\n  MAX_RANDOM_NUMBER: 10,\r\n  MIN_RANDOM_GENERATION: 5,\r\n  MAX_RANDOM_GENERATION: 15,\r\n  NOT_FOUND: 99\r\n});\r\n\r\nconst String = Object.freeze({\r\n  INFINITY: 'vô cực',\r\n  IMPOSSIBLE: 'vô nghiệm',\r\n  TOO_SHORT: 'quá ngắn',\r\n  NOT_ENOUGH_SET: 'không đủ phương trình tạo thành hệ',\r\n  NOT_BE_IN_LINE: 'điểm không thuộc đường'\r\n});\r\n\r\nconst Regex = Object.freeze({\r\n  KEY: '[^{\\\\}]+(?=})',\r\n  OTHER: '(^([^{]+(?={)))|((?<=})([^{]+)(?={))|(((?<=})[^}]+)$)'\r\n});\r\n\r\nconst Others = Object.freeze({\r\n  OPERATIONS: ['+', '-', '*', '<', '>', '=']\r\n});\r\n\r\nconst Errors = Object.freeze({\r\n  UNDEFINED_ERROR: 'Lỗi không xác dịnh',\r\n  WRONG_FORMAT: 'Sai định dạng',\r\n  MAXIMUM_POINT_ERROR: 'Tối đa 3 điểm thẳng háng'\r\n});\r\n\r\nconst InputStatus = Object.freeze({\r\n  SUCCESS: 'Success',\r\n  NORMAL: `Normal`,\r\n  ERROR: 'Error'\r\n});\r\nconst TutorialString = {\r\n  STEP_ONE: `\r\n  Danh sách các mẫu câu dặc trưng:\r\n    \\n__ = __\r\n    \\n__ song song/vuông góc __\r\n    \\n__ cắt __ tại __\r\n    \\n__ phân giác __\r\n    \\n__ thẳng hàng\r\n    \\n__ trung điểm __\r\n    \\n__ thuộc/không thuộc __\r\n    \\n__ tiếp tuyến (__)\r\n    \\ntam giác {loại} __\r\n    \\ntứ giác __\r\n    \\nđường tròn tâm __ ngoại tiếp/nội tiếp __\r\n\\nLưu ý:\r\n  \\n Đường tròn trong cái mối quan hệ khác sẽ nằm trong ()\r\n  \\n  Vd: AB tiếp tuyến (O)\r\n  `\r\n};\r\nconst GConst = {\r\n  Number,\r\n  String,\r\n  Regex,\r\n  Others,\r\n  Errors,\r\n  InputStatus,\r\n  TutorialString\r\n};\r\n\r\nexport default GConst;\r\n","import type { EquationType, LineType } from '../../utils/types';\r\n\r\nexport function convertLinearToEquation(l: EquationType): EquationType {\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: l.c,\r\n    d: l.d,\r\n    e: l.e\r\n  };\r\n}\r\n\r\nexport function convertEquationToLineType(line: EquationType): LineType {\r\n  return {\r\n    a: -line.c / (line.d === 0 ? 1 : line.d),\r\n    b: -line.e / (line.d === 0 ? 1 : line.d)\r\n  };\r\n}\r\n\r\nexport function convertLineTypeToEquation(line: LineType): EquationType {\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: -line.a,\r\n    d: 1,\r\n    e: -line.b\r\n  };\r\n}\r\n\r\n","// @flow\r\n\r\nimport GConst from '../../utils/values';\r\nimport type { CoordinateType, EquationType } from '../../utils/types';\r\nimport { calculateQuadraticEquation, getLineFromTwoPoints, calculatePerpendicularLineByPointAndLine } from './Math2D';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\n\r\nexport function getStartPoint(): CoordinateType {\r\n  return { x: 0, y: 0, z: 0 };\r\n}\r\n\r\nexport function getRandomValue(min: number, max: number): number {\r\n  if (max < min) {\r\n    return min;\r\n  }\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function getRandomPointInEquation(equation: EquationType): CoordinateType {\r\n  if (!equation.a) {\r\n    equation.a = 0;\r\n  }\r\n  if (!equation.b) {\r\n    equation.b = 0;\r\n  }\r\n  if (equation.a === 0 && equation.b === 0) {\r\n    if (equation.d !== 0) {\r\n      const tempX = getRandomValue(MIN, MAX);\r\n      return {\r\n        x: tempX,\r\n        y: (-equation.e - equation.c * tempX) / equation.d\r\n      };\r\n    } else {\r\n      return {\r\n        x: -equation.e / equation.c,\r\n        y: getRandomValue(MIN, MAX)\r\n      };\r\n    }\r\n  } else if (equation.a === 1 && equation.b === 1) {\r\n    const centerPoint = {\r\n      a: equation.c / -2,\r\n      b: equation.d / -2\r\n    };\r\n\r\n    const radius = Math.sqrt(centerPoint.a * centerPoint.a + centerPoint.b * centerPoint.b - equation.e);\r\n\r\n    const randomValueX = getRandomValue(centerPoint.a - radius, centerPoint.a + radius);\r\n\r\n    const solvedValueY = calculateQuadraticEquation(\r\n      equation.b,\r\n      equation.d,\r\n      randomValueX * randomValueX + equation.c * randomValueX + equation.e\r\n    );\r\n\r\n    if (typeof solvedValueY === 'number') {\r\n      return { x: randomValueX, y: solvedValueY };\r\n    } else if (typeof solvedValueY === 'object') {\r\n      return { x: randomValueX, y: solvedValueY.secondRoot || solvedValueY.firstRoot };\r\n    }\r\n  }\r\n}\r\n\r\nexport function generatePointAlignmentInside(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  const tempX = (firstPoint.x + secondPoint.x) / getRandomValue(2, 5);\r\n  return {\r\n    x: tempX,\r\n    y: (line.c * tempX + line.e) / -line.d\r\n  };\r\n}\r\n\r\nexport function generatePointAlignmentOutside(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true\r\n): CoordinateType {\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  const tempXRight = getRandomValue(secondPoint.x, MAX);\r\n  const tempXLeft = getRandomValue(MIN, firstPoint.x);\r\n  return isRight\r\n    ? {\r\n        x: tempXRight,\r\n        y: (line.c * tempXRight + line.e) / -line.d\r\n      }\r\n    : {\r\n        x: tempXLeft,\r\n        y: (line.c * tempXLeft + line.e) / -line.d\r\n      };\r\n}\r\n\r\nexport function generatePointNotAlignment(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  let resultPoint: CoordinateType = {};\r\n  resultPoint.x = getRandomValue(MIN, MAX);\r\n  const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n  do {\r\n    resultPoint.y = getRandomValue(MIN, MAX);\r\n  } while (resultPoint.y === line.c * resultPoint.x + line.e);\r\n  return resultPoint;\r\n}\r\n\r\nexport function generatePointMiddleTwoPoints(p1: CoordinateType, p2: CoordinateType) {\r\n  const line = getLineFromTwoPoints(p1, p2);\r\n  const randomPoint = generatePointAlignmentInside(p1, p2);\r\n\r\n  const randomLine = calculatePerpendicularLineByPointAndLine(randomPoint, line);\r\n  return getRandomPointInEquation(randomLine);\r\n}\r\n","// @flow\r\n\r\nimport GConst from './values';\r\nimport dataViewModel from '../ViewModel/DataViewModel';\r\n\r\nconst ErrorCode = {\r\n  200: GConst.Errors.UNDEFINED_ERROR,\r\n  300: GConst.Errors.WRONG_FORMAT,\r\n  301: GConst.Errors.MAXIMUM_POINT_ERROR,\r\n  400: GConst.String.IMPOSSIBLE,\r\n  401: GConst.String.INFINITY,\r\n  500: GConst.String.NOT_BE_IN_LINE,\r\n  501: GConst.String.NOT_ENOUGH_SET,\r\n  502: GConst.String.TOO_SHORT\r\n};\r\n\r\nclass ErrorHandleService {\r\n  message: string = '';\r\n\r\n  get ErrorMessage() {\r\n    return this.message;\r\n  }\r\n\r\n  showError(code: string, errorRelation?: mixed) {\r\n    let index;\r\n    if (errorRelation) {\r\n      index = dataViewModel.inputData.filter((data: mixed): boolean => data === errorRelation)[0];\r\n    } else {\r\n      switch (code) {\r\n        case 300:\r\n        case 301:\r\n          index = dataViewModel.executedInputIndex;\r\n          break;\r\n        default:\r\n          index = dataViewModel.inputData.filter((data: mixed): boolean => data === dataViewModel.executingRelation)[0];\r\n      }\r\n    }\r\n    if (index >= 0) {\r\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\r\n    }\r\n\r\n    alert(ErrorCode[code]);\r\n    throw console.error('error', ErrorCode[code]);\r\n  }\r\n}\r\n\r\nconst ErrorService = new ErrorHandleService();\r\n\r\nexport default ErrorService;\r\n","import GConst from '../../utils/values';\r\nimport type { CircleType, CoordinateType, EquationType, LineType } from '../../utils/types';\r\nimport { convertEquationToLineType, convertLinearToEquation, convertLineTypeToEquation } from './Converter';\r\nimport { getRandomPointInEquation, getRandomValue } from './Generation';\r\nimport ErrorService from '../../utils/ErrorHandleService';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\nconst INFINITY = GConst.String.INFINITY;\r\nconst IMPOSSIBLE = GConst.String.IMPOSSIBLE;\r\nconst NOT_BE_IN_LINE = GConst.String.NOT_BE_IN_LINE;\r\n\r\nfunction _makeRound(num: number, f: number = 3): number {\r\n  if (isNaN(num)) {\r\n    throw console.error('error', num);\r\n  }\r\n  const myF = Math.pow(10, f);\r\n  return Math.round(num * myF) / myF;\r\n}\r\n\r\nexport function calculateVector(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isMakeRound? = true\r\n): CoordinateType {\r\n  if (isMakeRound) {\r\n    return {\r\n      x: _makeRound(secondPoint.x - firstPoint.x),\r\n      y: _makeRound(secondPoint.y - firstPoint.y)\r\n    };\r\n  }\r\n  return {\r\n    x: secondPoint.x - firstPoint.x,\r\n    y: secondPoint.y - firstPoint.y\r\n  };\r\n}\r\n\r\nexport function isVectorSameDirection(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (firstVector.x === 0) {\r\n    return (\r\n      secondVector.x === 0 && firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y)\r\n    );\r\n  }\r\n\r\n  if (firstVector.y === 0) {\r\n    return (\r\n      secondVector.y === 0 && firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x)\r\n    );\r\n  }\r\n\r\n  if (secondVector.x === 0) {\r\n    return firstVector.x === 0 && firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y);\r\n  }\r\n\r\n  if (secondVector.y === 0) {\r\n    return firstVector.y === 0 && firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x);\r\n  }\r\n\r\n  return (\r\n    firstVector.x / Math.abs(firstVector.x) === secondVector.x / Math.abs(secondVector.x) &&\r\n    firstVector.y / Math.abs(firstVector.y) === secondVector.y / Math.abs(secondVector.y) &&\r\n    _makeRound(firstVector.x * secondVector.y) === _makeRound(firstVector.y * secondVector.x)\r\n  );\r\n}\r\n\r\nexport function isVectorInSameLine(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (firstVector.x === 0) {\r\n    return secondVector.x === 0;\r\n  }\r\n\r\n  if (firstVector.y === 0) {\r\n    return secondVector.y === 0;\r\n  }\r\n\r\n  if (secondVector.x === 0) {\r\n    return firstVector.x === 0;\r\n  }\r\n\r\n  if (secondVector.y === 0) {\r\n    return firstVector.y === 0;\r\n  }\r\n\r\n  return _makeRound(firstVector.x * secondVector.y) === _makeRound(firstVector.y * secondVector.x);\r\n}\r\n\r\nexport function calculateMiddlePoint(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  return {\r\n    x: (firstPoint.x + secondPoint.x) / 2,\r\n    y: (firstPoint.y + secondPoint.y) / 2\r\n  };\r\n}\r\n\r\nexport function calculateSymmetricalPoint(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true\r\n): CoordinateType {\r\n  return isRight\r\n    ? {\r\n        x: 2 * secondPoint.x - firstPoint.x,\r\n        y: 2 * secondPoint.y - firstPoint.y\r\n      }\r\n    : {\r\n        x: 2 * firstPoint.x - secondPoint.x,\r\n        y: 2 * firstPoint.y - secondPoint.y\r\n      };\r\n}\r\n\r\nexport function getLineFromTwoPoints(p1: CoordinateType, p2: CoordinateType): EquationType {\r\n  const directionVector = {\r\n    a: p2.x - p1.x,\r\n    b: p2.y - p1.y\r\n  };\r\n  const normalVector = {\r\n    a: -directionVector.b,\r\n    b: directionVector.a\r\n  };\r\n\r\n  return {\r\n    a: 0,\r\n    b: 0,\r\n    c: normalVector.a,\r\n    d: normalVector.b,\r\n    e: -normalVector.a * p1.x - normalVector.b * p1.y\r\n  };\r\n}\r\n\r\nexport function calculateParallelEquation(equation: EquationType): EquationType {\r\n  // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n  const e = Math.floor(Math.random() * 100) - MAX;\r\n\r\n  let parallelEquation: EquationType = { coefficientZ: 0 };\r\n  parallelEquation.c = equation.c;\r\n  parallelEquation.d = equation.d;\r\n  parallelEquation.e = e;\r\n\r\n  return parallelEquation;\r\n}\r\n\r\nexport function calculatePerpendicularEquation(equation: EquationType): EquationType {\r\n  // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n  const e = Math.floor(Math.random() * 100) - MIN;\r\n\r\n  let perpendicularEquation: EquationType = { coefficientZ: 0 };\r\n  perpendicularEquation.c = -equation.c;\r\n  perpendicularEquation.d = equation.d;\r\n  perpendicularEquation.e = e;\r\n\r\n  return perpendicularEquation;\r\n}\r\n\r\nexport function calculateDistanceTwoPoints(firstPoint: CoordinateType, secondPoint: CoordinateType): number {\r\n  const squareX = (secondPoint.x - firstPoint.x) * (secondPoint.x - firstPoint.x);\r\n  const squareY = (secondPoint.y - firstPoint.y) * (secondPoint.y - firstPoint.y);\r\n\r\n  return Math.sqrt(squareX + squareY);\r\n}\r\n\r\nexport function calculateDistanceFromPointToLine(point: CoordinateType, line: EquationType): number {\r\n  let numerator = Math.abs(line.c * point.x + line.d * point.y + line.e);\r\n  let denominator = Math.sqrt(line.c * line.c + line.d * line.d);\r\n\r\n  if (denominator === 0) return INFINITY;\r\n  return numerator / denominator;\r\n}\r\n\r\nexport function calculateParallelLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  // parallel line has `a` coefficient equals the other line.\r\n  // parallel line's e = -ax - y with (x,y) is coordinate of the point\r\n  const lineEquation = convertEquationToLineType(line);\r\n  const parLine: LineType = {};\r\n  parLine.a = lineEquation.a;\r\n  parLine.b = point.y - lineEquation.a * point.x;\r\n\r\n  let result = convertLineTypeToEquation(parLine);\r\n  if (line.d === 0) {\r\n    result.d = line.d;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function calculatePerpendicularLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  let perpendicularLine: EquationType = {};\r\n\r\n  // perpendicular line has the direction vector is opposite pairs with the other line.\r\n  // perpendicular line's e = -ax - y with (x,y) is coordinate of the point\r\n  if (line.c === 0) {\r\n    perpendicularLine.c = -1 / line.d;\r\n    perpendicularLine.d = 0;\r\n    perpendicularLine.e = -perpendicularLine.c * point.x;\r\n  } else if (line.d === 0) {\r\n    perpendicularLine.c = 0;\r\n    perpendicularLine.d = -1 / line.c;\r\n    perpendicularLine.e = -perpendicularLine.d * point.y;\r\n  } else {\r\n    const lineEquation = convertEquationToLineType(line);\r\n    const perLine: LineType = {};\r\n    perLine.a = -1 / lineEquation.a;\r\n    perLine.b = point.y + point.x / lineEquation.a;\r\n\r\n    perpendicularLine = convertLineTypeToEquation(perLine);\r\n  }\r\n\r\n  return perpendicularLine;\r\n}\r\n\r\nexport function calculateIntersectionByLineAndLine(lineOne: EquationType, lineTwo: EquationType): CoordinateType {\r\n  return calculateSetOfEquationTypeAndQuadraticEquation(\r\n    {\r\n      c: lineOne.c,\r\n      d: lineOne.d,\r\n      e: lineOne.e\r\n    },\r\n    {\r\n      a: 0,\r\n      b: 0,\r\n      c: lineTwo.c,\r\n      d: lineTwo.d,\r\n      e: lineTwo.e\r\n    }\r\n  )[0];\r\n}\r\n\r\nexport function calculateCircleEquationByCenterPoint(\r\n  centerPoint: CoordinateType,\r\n  radius: number\r\n): TwoVariableQuadraticEquation {\r\n  const roundedRadius = _makeRound(radius, 6);\r\n  return {\r\n    a: 1,\r\n    b: 1,\r\n    c: -2 * centerPoint.x,\r\n    d: -2 * centerPoint.y,\r\n    e: centerPoint.x * centerPoint.x + centerPoint.y * centerPoint.y - roundedRadius * roundedRadius\r\n  };\r\n}\r\n\r\nexport function calculateInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType\r\n): EquationType {\r\n  const results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n  const firstLine: EquationType = results[0];\r\n  const secondLine: EquationType = results[1];\r\n\r\n  // const pointInFirstLine: CoordinateType = getRandomPointInLine(lineOne);\r\n  // let pointInSecondLine: CoordinateType = { x: pointInFirstLine.x, y: undefined };\r\n  // if (lineTwo.d !== 0) {\r\n  //   pointInSecondLine.y = (-lineTwo.e - lineTwo.c * pointInSecondLine.x) / lineTwo.d;\r\n  // } else {\r\n  //   pointInSecondLine.y = getRandomValue(MIN_RANDOM_NUMBER, MAX_RANDOM_NUMBER);\r\n  // }\r\n\r\n  if (getAngleFromTwoLines(lineOne, lineTwo) === 0) {\r\n    throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n  }\r\n\r\n  return _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n}\r\n\r\nexport function calculateExternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType\r\n): EquationType {\r\n  let results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n  const firstLine: EquationType = results[0];\r\n  const secondLine: EquationType = results[1];\r\n\r\n  if (getAngleFromTwoLines(lineOne, lineTwo) === 0) {\r\n    throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n  }\r\n\r\n  const internalLine = _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n\r\n  results = results.filter((line: EquationType): boolean => JSON.stringify(line) !== JSON.stringify(internalLine));\r\n  return results[0];\r\n}\r\n\r\nfunction _calculateBisectLineEquation(lineOne: EquationType, lineTwo: EquationType): [EquationType, EquationType] {\r\n  let resultOne: EquationType = {};\r\n  let resultTwo: EquationType = {};\r\n\r\n  // ax + by + c = +/- [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')] * (a'x + b'y + c)\r\n\r\n  // check if denominator equals 0\r\n  if (lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d === 0) return;\r\n\r\n  // Represent for [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')]\r\n  let coefficient =\r\n    Math.sqrt(lineOne.c * lineOne.c + lineOne.d * lineOne.d) / Math.sqrt(lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d);\r\n\r\n  /*\r\n   * Two results:\r\n   *    (a - coefficient*a')x + (b - coefficient*b')y + c - coefficient*c' = 0\r\n   *    (a + coefficient*a')x + (b + coefficient*b')y + c + coefficient*c' = 0\r\n   */\r\n  resultOne.c = lineOne.c - coefficient * lineTwo.c;\r\n  resultOne.d = lineOne.d - coefficient * lineTwo.d;\r\n  resultOne.e = lineOne.e - coefficient * lineTwo.e;\r\n\r\n  resultTwo.c = lineOne.c + coefficient * lineTwo.c;\r\n  resultTwo.d = lineOne.d + coefficient * lineTwo.d;\r\n  resultTwo.e = lineOne.e + coefficient * lineTwo.e;\r\n\r\n  return [resultOne, resultTwo];\r\n}\r\n\r\n/*\r\n *   Line one and line two is 2 lines are the result of _calculateBisectLineEquation function\r\n *   Point one and point two are 2 points that each point located in each line\r\n *             which is equivalent each argument in _calculateBisectLineEquation function\r\n */\r\nfunction _getInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType\r\n): EquationType {\r\n  let firstEquation = pointOne.x * lineOne.c + pointOne.y * lineOne.d + lineOne.e;\r\n  let secondEquation = pointTwo.x * lineOne.c + pointTwo.y * lineOne.d + lineOne.e;\r\n  return firstEquation * secondEquation <= 0 ? lineOne : lineTwo;\r\n}\r\n\r\n// TODO: Uncheck\r\nexport function calculateSetOfEquationTypes(d1: EquationType, d2: EquationType) {\r\n  if (\r\n    (d1.c === 0 && d2.c === 0) ||\r\n    (d1.d === 0 && d2.d === 0) ||\r\n    (d1.c === 0 && d1.d === 0) ||\r\n    (d2.c === 0 && d2.d === 0)\r\n  ) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  if (d1.c === 0 && d2.d === 0) {\r\n    return { x: -d2.e / d2.c, y: -d1.e / d1.d };\r\n  }\r\n  if (d2.c === 0 && d1.d === 0) {\r\n    return { x: -d1.e / d1.c, y: -d2.e / d2.d };\r\n  }\r\n  if (d1.e === 0 && d2.e === 0) {\r\n    return { x: 0, y: 0 };\r\n  }\r\n\r\n  if (d1.c === 0) {\r\n    const tempY = -d1.e / d1.d;\r\n    return { x: (-d2.e - tempY * d2.d) / d2.c, y: tempY };\r\n  }\r\n\r\n  if (d1.d === 0) {\r\n    const tempX = -d1.e / d1.c;\r\n    return { x: tempX, y: (-d2.e - tempX * d2.c) / d2.d };\r\n  }\r\n\r\n  if (d2.c === 0) {\r\n    const tempY = -d2.e / d2.d;\r\n    return { x: (-d1.e - tempY * d1.d) / d1.c, y: tempY };\r\n  }\r\n\r\n  if (d2.d === 0) {\r\n    const tempX = -d2.e / d2.c;\r\n    return { x: tempX, y: (-d1.e - tempX * d1.c) / d1.d };\r\n  }\r\n  const tempY = (d1.e * d2.c - d1.c * d2.e) / (d1.d * d2.c - d1.c * d2.d);\r\n  return { x: (-d1.e - d1.d * tempY) / d1.c, y: tempY };\r\n}\r\n\r\n/*\r\n *  Find point(s) of intersection between a linear equation and a circle equation.\r\n *  @params:\r\n *        + d (EquationType): a line.\r\n *        + c (CircleEquation): a circle.\r\n *  @return:\r\n *        + IMPOSSIBLE: if distance from center point of the circle to the line is greater than the radius.\r\n *        + (Array<Object>): if the line intersects the circle.\r\n *          + length = 1;\r\n *          + length = 2;\r\n */\r\nexport function calculateIntersectionEquationTypeWithCircleEquation(d: EquationType, q: EquationType): Array<Object> {\r\n  const A = -q.c / 2;\r\n  const B = -q.d / 2;\r\n  const centerPoint: CoordinateType = { x: A, y: B };\r\n  const distanceFromCenterPointToLine = calculateDistanceFromPointToLine(centerPoint, d);\r\n\r\n  if (distanceFromCenterPointToLine > Math.sqrt(A * A + B * B - q.e)) {\r\n    return IMPOSSIBLE;\r\n  } else {\r\n    return calculateSetOfEquationTypeAndQuadraticEquation(d, q);\r\n  }\r\n}\r\n\r\n/*\r\n * Solves a quadratic equation. This equation is defined: Ax2 + Bx + C = 0.\r\n *\r\n *  @params:\r\n *        + a (number): represents x's coefficient.\r\n *        + b (number): represents y's coefficient.\r\n *        + c (number): represents constant term.\r\n * @return:\r\n *        + IMPOSSIBLE (string): if the equation is no root.\r\n *        + (number): if the equation has only ONE root.\r\n *        + x1, x2 (Object): if the equation has TWO root.\r\n */\r\nexport function calculateQuadraticEquation(a: number, b: number, c: number) {\r\n  const delta = b * b - 4 * a * c;\r\n\r\n  let firstRoot,\r\n    secondRoot: number = undefined;\r\n\r\n  if (a === 0) {\r\n    if (b === 0) return INFINITY;\r\n    return -c / b;\r\n  } else if (delta < 0) {\r\n    return IMPOSSIBLE;\r\n  } else if (delta === 0) {\r\n    return -b / (2 * a);\r\n  } else {\r\n    firstRoot = (-b + Math.sqrt(delta)) / (2 * a);\r\n    secondRoot = (-b - Math.sqrt(delta)) / (2 * a);\r\n    return { firstRoot, secondRoot };\r\n  }\r\n}\r\n\r\n// Ax2 + By2 + Cx + Dy + E = 0\r\nexport function isIn(p: CoordinateType, e: EquationType): boolean {\r\n  if (p.x === undefined || p.y === undefined) return false;\r\n  if (e.a === undefined) {\r\n    e = convertLinearToEquation(e);\r\n  }\r\n  const temp = e.a * p.x * p.x + e.b * p.y * p.y + e.c * p.x + e.d * p.y + e.e;\r\n  return _makeRound(temp) === 0;\r\n}\r\n\r\n/*\r\n *  Solves a set of a linear equation and quadratic equation.\r\n *  Linear equation is defined:     Ax + By + C = 0.\r\n *  Quadratic equation is defined:  Ax2 + By2 + Cx + Dy + E = 0.\r\n *\r\n *  @params:\r\n *        + l (EquationType): represents a linear equation.\r\n *        + q (QuadraticEquation): represents a quadratic equation.\r\n *  @return:\r\n *        + IMPOSSIBLE (string): if the set is no root.\r\n *        + (number): if the set has only ONE root.\r\n *        + x1, x2 (Object): if the set has TWO root.\r\n */\r\nexport function calculateSetOfEquationTypeAndQuadraticEquation(l: EquationType, q: EquationType): Array<Object> {\r\n  let results: Array<Object> = [];\r\n  let u, v, w;\r\n\r\n  const A = l.c;\r\n  const B = l.d;\r\n  const C = l.e;\r\n  const D = q.a;\r\n  const E = q.b;\r\n  const F = q.c;\r\n  const G = q.d;\r\n  const H = q.e;\r\n  if (A !== 0) {\r\n    u = A * A * E + D * B * B;\r\n    v = 2 * B * C * D - A * B * F + A * A * G;\r\n    w = D * C * C - A * C * F + A * A * H;\r\n\r\n    // solves x. Unneeded check IMPOSSIBLE.\r\n    const root = calculateQuadraticEquation(u, v, w);\r\n    if (typeof root === 'number') {\r\n      results.push({ x: (-C - B * root) / A, y: root });\r\n    } else if (root === IMPOSSIBLE) {\r\n      return root;\r\n    } else {\r\n      const r1 = root.firstRoot;\r\n      const r2 = root.secondRoot;\r\n      results.push({ x: (-C - B * root.firstRoot) / A, y: r1 }, { x: (-C - B * root.secondRoot) / A, y: r2 });\r\n    }\r\n  } else {\r\n    u = q.a * l.d * l.d;\r\n    v = q.c * l.d * l.d;\r\n    w = q.b * l.e * l.e - q.d * l.d * l.e + q.e * l.d * l.d;\r\n\r\n    // solves x. Unneeded check IMPOSSIBLE.\r\n    const root = calculateQuadraticEquation(u, v, w);\r\n\r\n    if (typeof root === 'number') {\r\n      results.push({ x: root, y: -l.e / l.d });\r\n    } else if (root === IMPOSSIBLE) {\r\n      return root;\r\n    } else {\r\n      results.push({ x: root.firstRoot, y: -l.e / l.d }, { x: root.secondRoot, y: -l.e / l.d });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function calculateIntersectionTwoCircleEquations(firstEquation: EquationType, secondEquation: EquationType) {\r\n  let results: Array<Object> = [];\r\n  if (!firstEquation || !secondEquation) {\r\n    return IMPOSSIBLE;\r\n  }\r\n  let q1, q2;\r\n  firstEquation.a === undefined ? (q1 = convertLinearToEquation(firstEquation)) : (q1 = firstEquation);\r\n  secondEquation.a === undefined ? (q2 = convertLinearToEquation(secondEquation)) : (q2 = secondEquation);\r\n\r\n  if (q1.a !== q2.a && q1.b !== q2.b) {\r\n    if (q1.a === 0 && q1.b === 0) {\r\n      // q2 is a quadratic equation\r\n      return calculateIntersectionEquationTypeWithCircleEquation(q1, q2);\r\n    } else {\r\n      // q1 is a quadratic equation\r\n      return calculateIntersectionEquationTypeWithCircleEquation(q2, q1);\r\n    }\r\n  } else if (q1.a === 0 && q1.b === 0 && q2.a === 0 && q2.b === 0) {\r\n    results.push(calculateSetOfEquationTypes(q1, q2));\r\n  } else {\r\n    // a x2 + b y2 + Ax + By + C = 0\r\n    // a'x2 + b'y2 + Dx + Ey + G = 0\r\n    const D = q2.c;\r\n    const E = q2.d;\r\n    const G = q2.e;\r\n\r\n    // Z = a - a'\r\n    const Z = q1.a - q2.a > 0 ? q1.a : q2.a;\r\n    const _D = Z === q1.a ? q1.c : D;\r\n    const _E = Z === q1.a ? q1.d : E;\r\n    const _G = Z === q1.a ? q1.e : G;\r\n\r\n    const a = Z === q1.a ? q1.c - D : D - q1.c;\r\n    const b = Z === q1.a ? q1.d - E : E - q1.d;\r\n    const c = Z === q1.a ? q1.e - G : G - q1.e;\r\n\r\n    if (a === 0 || b === 0) {\r\n      return IMPOSSIBLE;\r\n    } else {\r\n      const u = Z * (b * b + a * a);\r\n      const v = 2 * b * c * Z - _D * a * b + _E * a * a;\r\n      const w = Z * c * c - _D * a * c + _G * a * a;\r\n\r\n      const roots = calculateQuadraticEquation(u, v, w);\r\n      if (roots === IMPOSSIBLE) {\r\n        return roots;\r\n      } else if (typeof roots === 'number') {\r\n        results.push({\r\n          x: (-c - b * roots) / a,\r\n          y: roots\r\n        });\r\n      } else {\r\n        const r1 = roots.firstRoot;\r\n        const r2 = roots.secondRoot;\r\n        results.push({ x: (-c - b * roots.firstRoot) / a, y: r1 }, { x: (-c - b * roots.secondRoot) / a, y: r2 });\r\n      }\r\n    }\r\n  }\r\n  return results;\r\n}\r\n\r\nexport function calculateLinesByAnotherLineAndAngle(\r\n  rootPoint: CoordinateType,\r\n  staticPoint: CoordinateType,\r\n  dynamicPoint: CoordinateType,\r\n  angle: number\r\n): EquationType {\r\n  const equations = _calculateLinesByAnotherLineAndAngle(\r\n    getLineFromTwoPoints(rootPoint, staticPoint),\r\n    dynamicPoint,\r\n    angle\r\n  );\r\n  let index = 0;\r\n  const newRootPoints = equations\r\n    .map((equation: EquationType): CoordinateType => {\r\n      return calculateIntersectionByLineAndLine(getLineFromTwoPoints(rootPoint, staticPoint), equation);\r\n    })\r\n    .filter((newRootPoint: CoordinateType, i): boolean => {\r\n      const staticVector = calculateVector(rootPoint, staticPoint, false);\r\n      const dynamicVector = calculateVector(newRootPoint, dynamicPoint, false);\r\n      const result = calculateAngleTwoVector(staticVector, dynamicVector) === parseInt(angle);\r\n      if (result) {\r\n        index = i;\r\n      }\r\n      return result;\r\n    });\r\n  if (newRootPoints[0]) {\r\n    return equations[index];\r\n  }\r\n\r\n  ErrorService.showError('500');\r\n  return null;\r\n}\r\n\r\nfunction calculateIntegratedDirection(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  return vectorOne.x * vectorTwo.x + vectorOne.y * vectorTwo.y;\r\n}\r\n\r\nfunction calculateVectorLength(vector: CoordinateType): number {\r\n  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\r\n}\r\n\r\nexport function calculateAngleTwoVector(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  return _makeRound(\r\n    (Math.acos(\r\n      calculateIntegratedDirection(vectorOne, vectorTwo) /\r\n        (calculateVectorLength(vectorOne) * calculateVectorLength(vectorTwo))\r\n    ) *\r\n      180) /\r\n      Math.PI,\r\n    1\r\n  );\r\n}\r\n\r\nexport function _calculateLinesByAnotherLineAndAngle(d: EquationType, p: CoordinateType, angle: number) {\r\n  let results: Array<EquationType> = [];\r\n\r\n  const cosine = Math.cos((angle * Math.PI) / 180);\r\n  const A = d.c * d.c - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n  const B = 2 * d.c * d.d;\r\n  const C = d.d * d.d - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n  const root = calculateQuadraticEquation(A, B, C);\r\n\r\n  if (typeof root === 'number') {\r\n    results.push({\r\n      c: root,\r\n      d: 1,\r\n      e: -root * p.x - p.y\r\n    });\r\n  } else if (root === IMPOSSIBLE) {\r\n    return root;\r\n  } else {\r\n    results.push(\r\n      {\r\n        c: root.firstRoot,\r\n        d: 1,\r\n        e: -root.firstRoot * p.x - p.y\r\n      },\r\n      {\r\n        c: root.secondRoot,\r\n        d: 1,\r\n        e: -root.secondRoot * p.x - p.y\r\n      }\r\n    );\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function makeRoundCoordinate(point: CoordinateType, f: number = 3) {\r\n  if (typeof point === 'string') {\r\n    return point;\r\n  }\r\n  return {\r\n    x: _makeRound(point.x, f),\r\n    y: _makeRound(point.y, f)\r\n  };\r\n}\r\n\r\nexport function getAngleFromTwoLines(d1: EquationType, d2: EquationType): number {\r\n  if (d1.a || d1.b || d2.a || d2.b) {\r\n    return -9999;\r\n  }\r\n\r\n  const a1 = d1.c;\r\n  const a2 = d2.c;\r\n  const b1 = d1.d;\r\n  const b2 = d2.d;\r\n\r\n  const result =\r\n    (Math.acos(Math.abs(a1 * a2 + b1 * b2) / Math.sqrt((a1 * a1 + b1 * b1) * (a2 * a2 + b2 * b2))) * 180) / Math.PI;\r\n\r\n  // round result\r\n  return _makeRound(result, 1);\r\n}\r\n\r\nexport function getMiddlePointFromThreePointsInALine(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType\r\n): CoordinateType {\r\n  const line = getLineFromTwoPoints(p1, p2);\r\n  if (!isIn(p3, { a: 0, b: 0, c: line.c, d: line.d, e: line.e })) return NOT_BE_IN_LINE;\r\n\r\n  // another way: check vector =)))~\r\n  const dis_p1_p2 = calculateDistanceTwoPoints(p1, p2);\r\n  const dis_p2_p3 = calculateDistanceTwoPoints(p2, p3);\r\n  const dis_p1_p3 = calculateDistanceTwoPoints(p1, p3);\r\n\r\n  const max = Math.max(dis_p1_p2, dis_p2_p3, dis_p1_p3);\r\n  if (dis_p1_p2 === max) return p3;\r\n  else if (dis_p1_p3 === max) return p2;\r\n  else return p1;\r\n}\r\n\r\nexport function calculateCircumCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  const midperpendicularsLineOne = calculatePerpendicularLineByPointAndLine(\r\n    calculateMiddlePoint(p1, p2),\r\n    getLineFromTwoPoints(p1, p2)\r\n  );\r\n\r\n  const midperpendicularsLineTwo = calculatePerpendicularLineByPointAndLine(\r\n    calculateMiddlePoint(p1, p3),\r\n    getLineFromTwoPoints(p1, p3)\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(midperpendicularsLineOne, midperpendicularsLineTwo);\r\n  const radius = calculateDistanceTwoPoints(center, p1);\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n\r\n  return { center, radius, equation };\r\n}\r\n\r\nexport function calculateInCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  const bisectorLineOne = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(p1, p3),\r\n    getLineFromTwoPoints(p1, p2),\r\n    p2,\r\n    p3\r\n  );\r\n\r\n  const bisectorLineTwo = calculateInternalBisectLineEquation(\r\n    getLineFromTwoPoints(p2, p3),\r\n    getLineFromTwoPoints(p1, p2),\r\n    p1,\r\n    p3\r\n  );\r\n\r\n  const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n  const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(p1, p3));\r\n\r\n  const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n  return { center, radius, equation };\r\n}\r\n\r\nexport function calculateTangentEquation(circle: EquationType, point?: CoordinateType = null): EquationType {\r\n  const tangentPoint: CoordinateType = point || getRandomPointInEquation(circle);\r\n\r\n  const tangentEquation: EquationType = {};\r\n\r\n  tangentEquation.a = 0;\r\n  tangentEquation.b = 0;\r\n  tangentEquation.c = tangentPoint.x + circle.c / 2;\r\n  tangentEquation.d = tangentPoint.y + circle.d / 2;\r\n  tangentEquation.e = circle.e + (circle.c * tangentPoint.x) / 2 + (circle.d * tangentPoint.y) / 2;\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nexport function calculateTangentIntersectPointsByPointOutsideCircle(\r\n  circle: EquationType,\r\n  point?: CoordinateType = null,\r\n  exceptionPoint?: CoordinateType = null\r\n): EquationType {\r\n  const center: CoordinateType = { x: -circle.c / 2, y: -circle.d / 2 };\r\n\r\n  const tempCircleCenter = calculateMiddlePoint(center, point);\r\n  const tempCircleRadius = calculateDistanceTwoPoints(center, point) / 2;\r\n\r\n  const tempCircleEquation = calculateCircleEquationByCenterPoint(tempCircleCenter, tempCircleRadius);\r\n\r\n  let roots = calculateIntersectionTwoCircleEquations(circle, tempCircleEquation);\r\n\r\n  if (exceptionPoint) {\r\n    roots = roots.filter((root: CoordinateType): boolean => JSON.stringify(root) !== JSON.stringify(exceptionPoint));\r\n  }\r\n\r\n  return roots;\r\n}\r\n\r\nexport function isTwoEquationEqual(equationOne: EquationType, equationTwo: EquationType): boolean {\r\n  return getAngleFromTwoLines(equationOne, equationTwo, 1) === 0;\r\n}\r\n","export function isLowerCaseChar(char) {\r\n  if (char === char.toLowerCase()) return '0';\r\n  return '1';\r\n}\r\n\r\nexport function isNumber(value) {\r\n  return !isNaN(value) || typeof value === 'number' || (isObjectLike(value) && getTag(value) === '[object Number]');\r\n}\r\n\r\nexport function isObject(value) {\r\n  const type = typeof value;\r\n  return value !== null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport function isQuadraticEquation(equation): boolean {\r\n  if (!equation) return false;\r\n  return equation.a === 1 && equation.b === 1;\r\n}\r\n\r\nexport function isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n  const tag = getTag(value);\r\n  return (\r\n    tag === '[object Function]' ||\r\n    tag === '[object AsyncFunction]' ||\r\n    tag === '[object GeneratorFunction]' ||\r\n    tag === '[object Proxy]'\r\n  );\r\n}\r\n\r\n/* ====================================================================\r\n                          INTERNAL METHODS\r\n   ==================================================================*/\r\nfunction isObjectLike(value) {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nfunction getTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? '[object Undefined]' : '[object Null]';\r\n  }\r\n  return toString.call(value);\r\n}\r\n","import { isLowerCaseChar, isNumber } from '../../utils/checker';\r\n\r\nexport function checkFormatString(str) {\r\n  let result = '';\r\n  str.split('').forEach((element) => {\r\n    result += isLowerCaseChar(element);\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction validateObject(str) {\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (isNumber(str[i])) return false;\r\n    if (i > 0) if (str.slice(0, i - 1).includes(str[i])) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function defineObject(value) {\r\n  if (isNumber(value)) {\r\n    return 'value';\r\n  }\r\n\r\n  if (!validateObject(value)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (value.length === 3) {\r\n    if (value.includes('(') && value.includes(')')) {\r\n      return 'circle';\r\n    }\r\n    return 'angle';\r\n  }\r\n\r\n  const formatObj = checkFormatString(value);\r\n  switch (formatObj) {\r\n    case '0':\r\n      return 'line';\r\n    case '1':\r\n      return 'point';\r\n    case '10':\r\n      return 'ray';\r\n    case '11':\r\n      return 'segment';\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import { RankingObjectContain, validate } from '../definition/define.js';\r\nimport { checkFormatString } from '../definition/defineObjType';\r\nimport ErrorService from '../../utils/ErrorHandleService.js';\r\n\r\nexport function validateValue(value, type) {\r\n  if (!_validateName(value.value)) return false;\r\n\r\n  const validateGeometryType = validate.object[type];\r\n  let validateType;\r\n\r\n  if (value.key === 'value' || value.key === 'relation' || value.key === 'undefined' || value.key === 'circle')\r\n    return true;\r\n  if (value.key === 'angle') if (!validateAngle(value.value)) return false;\r\n\r\n  if (validateGeometryType.includes(value.key) || value.key !== 'object') {\r\n    const format = checkFormatString(value.value);\r\n    validateType = validate[value.key];\r\n    if (validateType && format)\r\n      if (validateType.format) {\r\n        if (format === validateType.format && value.value.length === validateType.length) return true;\r\n      } else if (value.value.length === validateType.length) {\r\n        return true;\r\n      }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction validateAngle(value) {\r\n  const format = checkFormatString(value);\r\n  return format[1] === '1';\r\n}\r\n\r\nfunction validateShape(shape) {\r\n  const keys = Object.keys(shape);\r\n  const validateShapeFormat = validate.shape[keys[0]];\r\n  const validateShapeType = validate.shapeType[keys[0]] || [''];\r\n  //check format of shape value\r\n  const value = shape[keys[0]];\r\n  const format = checkFormatString(shape[keys[0]]);\r\n  const shapeFormatCheck = format === validateShapeFormat.format && value.length === validateShapeFormat.length;\r\n\r\n  //check type of shape\r\n  const type = shape.type || '';\r\n  const shapeTypeCheck = validateShapeType.includes(type);\r\n\r\n  return shapeFormatCheck && shapeTypeCheck && _validateName(shape[keys[0]]);\r\n}\r\n\r\nfunction validateDataRelationship(data) {\r\n  const keys = Object.keys(data);\r\n\r\n  for (let indexOfRankingLevel = 0; indexOfRankingLevel < RankingObjectContain.length - 1; indexOfRankingLevel++) {\r\n    for (\r\n      let indexOfObjectCurrentLevel = 0;\r\n      indexOfObjectCurrentLevel < RankingObjectContain[indexOfRankingLevel].length;\r\n      indexOfObjectCurrentLevel++\r\n    ) {\r\n      for (\r\n        let indexOfObjectNextLevel = 0;\r\n        indexOfObjectNextLevel < RankingObjectContain[indexOfRankingLevel + 1].length;\r\n        indexOfObjectNextLevel++\r\n      )\r\n        if (keys.includes(RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel])) {\r\n          if (data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]])\r\n            return checkObjectRelationship(\r\n              data[RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel]][0],\r\n              data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]][0]\r\n            );\r\n        }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction checkObjectRelationship(obj1, obj2) {\r\n  let check = obj2.split('').map((char) => {\r\n    return obj1.includes(char);\r\n  });\r\n  const result = [...new Set(check)];\r\n\r\n  if (result.length === 1) {\r\n    return !result[0];\r\n  }\r\n  if (obj2.length === 2) return check.indexOf(true) === -1;\r\n  if (obj2.length === 3) {\r\n    return !(check.indexOf(true) === 0 || check.indexOf(true) === 2);\r\n  }\r\n}\r\n\r\n// check validate name not duplicate Ex: ABB\r\nfunction _validateName(string) {\r\n  return (\r\n    string.split('').length === string.split('').filter((item, index, array) => array.indexOf(item) === index).length\r\n  );\r\n}\r\n\r\nexport function validateInformation(info) {\r\n  const type = info.outputType;\r\n\r\n  if (type === 'shape') {\r\n    return validateShape(info);\r\n  } else {\r\n    delete info.outputType;\r\n    let keys = Object.keys(info);\r\n    if (keys.includes('undefined')) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < keys.length; i++) {\r\n      let array = info[keys[i]];\r\n      let key = keys[i];\r\n      for (let j = 0; j < array.length; j++) {\r\n        let value = array[j];\r\n        const check = validateValue({ key, value }, type);\r\n\r\n        if (!check) return check;\r\n      }\r\n    }\r\n  }\r\n  const keys = Object.keys(info);\r\n  info.outputType = type;\r\n\r\n  if (type === 'define') {\r\n    if (keys.includes('value')) {\r\n      return keys.length === 2;\r\n    } else {\r\n      return keys.length === 1;\r\n    }\r\n  }\r\n\r\n  if (type === 'relation') {\r\n    return validateDataRelationship(info);\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { defineObject } from './defineObjType';\r\nimport { validateInformation } from '../validation/validation';\r\nimport { definePointType } from './definePointType';\r\nimport { defineShapeType } from './defineShapeType';\r\nimport { reversedDependentObjRelation } from './define';\r\n\r\nfunction defineInformation(data) {\r\n  let result;\r\n  switch (data.outputType) {\r\n    case 'shape': {\r\n      result = defineShapeType(data);\r\n      break;\r\n    }\r\n\r\n    case 'relation': {\r\n      result = definePointType(data);\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      result = data;\r\n    }\r\n  }\r\n\r\n  if (reversedDependentObjRelation.includes(result.relation)) {\r\n    result.object = result.object.reverse();\r\n  }\r\n\r\n  Object.keys(result).forEach((key) => {\r\n    if (key === 'object') {\r\n      result[key].forEach((value) => {\r\n        const type = defineObject(value);\r\n        if (!result[type]) result[type] = [];\r\n        if (type === 'segment') {\r\n          value = sortString(value);\r\n        }\r\n        if (type === 'circle') {\r\n          value = value[1].toUpperCase();\r\n        }\r\n        result[type].push(value);\r\n      });\r\n    }\r\n    if (key === 'circle') {\r\n      result[key].forEach((value: string, index: number) => {\r\n        result[key][index] = result[key][index][1];\r\n      });\r\n    }\r\n  });\r\n\r\n  if (data.outputType === 'shape') {\r\n    const shapeName = Object.keys(result).filter((key) => key !== 'type')[0];\r\n    if (shapeName !== 'triangle') {\r\n      result[shapeName] = sortString(result[shapeName]);\r\n    }\r\n  }\r\n\r\n  delete result.object;\r\n  const validate = validateInformation(result);\r\n\r\n  if (validate) {\r\n    return result;\r\n  } else {\r\n    return { Error: result };\r\n  }\r\n}\r\n\r\nfunction sortString(str) {\r\n  const arr = str.split('');\r\n  const sorted = arr.sort();\r\n  return sorted.join('');\r\n}\r\n\r\nexport { defineInformation };\r\n","export function defineShapeType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key.includes('type')) {\r\n      const splitter = data[key].toString().split(' ');\r\n      const shape = splitter[splitter.length - 1];\r\n      const splitKey = key.split(' ');\r\n      const shapeName = splitKey.pop();\r\n      const otherData = data[key]\r\n        .toString()\r\n        .replace(shape, '')\r\n        .trim()\r\n        .split(' ');\r\n      result[shapeName] = shape;\r\n      let point = '';\r\n      if (otherData[0].length === 3 && otherData[0].includes('(') && otherData[0].includes(')')) {\r\n        result['point'] = otherData[0][1];\r\n        point = otherData[0];\r\n      }\r\n      result['type'] = otherData\r\n        .join(' ')\r\n        .replace(point, '')\r\n        .trim();\r\n    } else {\r\n      result[key] = data[key].toString();\r\n    }\r\n  });\r\n\r\n  console.log(result);\r\n\r\n  return result;\r\n}\r\n","export function definePointType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key === 'arrayPoints') {\r\n      result['point'] = data[key].toString().split(',');\r\n    } else {\r\n      result[key] = data[key];\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n","import dataViewModel from '../../ViewModel/DataViewModel';\r\nimport type { CoordinateType } from '../../utils/types';\r\nimport { calculateDistanceTwoPoints, getLineFromTwoPoints } from './Math2D';\r\nimport { getRandomValue } from './Generation.js';\r\nimport GConst from '../../utils/values';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_GENERATION;\r\nconst MAX = GConst.Number.MAX_RANDOM_GENERATION;\r\n\r\nconst geometricObj = {\r\n  triangle: generateTriangle,\r\n  quadrilateral: generateQuadrilateral,\r\n  trapezoid: generateTrapezoid,\r\n  parallelogram: generateParallelogram,\r\n  rectangle: generateRectangle,\r\n  rhombus: generateRhombus,\r\n  square: generateSquare,\r\n  circle: generateCircle\r\n};\r\n\r\nexport function generateGeometry(name: string, shape: string, type?: string) {\r\n  const generateFunc = geometricObj[shape];\r\n  if (generateFunc) {\r\n    generateFunc(name, type);\r\n  }\r\n}\r\n\r\nfunction generateTriangle(name: string, type: string) {\r\n  if (name.length === 3) {\r\n    let p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    let p2: CoordinateType = {};\r\n    let p3: CoordinateType = {};\r\n\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n    switch (type) {\r\n      case '': {\r\n        p3.y = getRandomValue(p1.y + 5, p1.y + 10);\r\n        p3.x = getRandomValue(p1.x - 3, p1.x - 10);\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = getRandomValue(p1.x + 3, p3.x + 10);\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        p2.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n        p2.x = p1.x;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        p3.x = getRandomValue(p1.x + 1, p1.x + 50);\r\n        p3.y = p1.y;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        /*\r\n         *            [A]\r\n         *          *    *\r\n         *        *        *\r\n         *      *            *\r\n         *    *                *\r\n         *  B  * * * * * * * *  C\r\n         */\r\n        const distance_From_A_To_B = getRandomValue(3, 6);\r\n\r\n        p3.y = getRandomValue(p1.y + 5, p1.y + 10);\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông cân': {\r\n        const distance_From_A_To_B = getRandomValue(5, 10);\r\n        p3.y = p1.y + distance_From_A_To_B;\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'đều': {\r\n        /*\r\n         *       [A]\r\n         *      *   *\r\n         *    *       *\r\n         * [B] * * * * [C]\r\n         */\r\n        p2.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n        p2.y = Math.sqrt(3) * p2.x;\r\n        dataViewModel.updateCoordinate(name[2], p2);\r\n        const distance_From_A_To_B = calculateDistanceTwoPoints(p1, p2);\r\n        p3.y = p2.y;\r\n        p3.x = -distance_From_A_To_B + p2.x;\r\n        dataViewModel.updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Tu giac\r\nfunction generateQuadrilateral(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.y - MAX, p1.y + MAX)\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {};\r\n    // prevent point C is on AB line\r\n    const linearEquation = getLineFromTwoPoints(p1, p2);\r\n    do {\r\n      p3.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n      p3.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n    } while (p3.y === linearEquation.coefficientX * p3.x + linearEquation.constantTerm);\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: getRandomValue(p1.x - MAX, p3.x),\r\n      y: undefined\r\n    };\r\n\r\n    // prevents p1, p2, p4 are straight\r\n    const line = getLineFromTwoPoints(p1, p2);\r\n    do {\r\n      p4.y = getRandomValue(p1.x, p1.x + MAX);\r\n    } while (p4.y === line.coefficientX * p4.x + line.constantTerm);\r\n\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thang\r\nfunction generateTrapezoid(name: string, type: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    switch (type) {\r\n      case '': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n          y: p1.y\r\n        };\r\n        dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: getRandomValue(p2.x + MIN, p2.x + MAX),\r\n          y: getRandomValue(p1.y + MIN, p1.y + MAX)\r\n        };\r\n        dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: getRandomValue(p1.x - MAX, p3.x - MIN),\r\n          y: p3.y\r\n        };\r\n        dataViewModel.updateCoordinate(name[3], p4);\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n          y: p1.y\r\n        };\r\n        dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: getRandomValue(p2.x + MIN, p2.x + MAX),\r\n          y: getRandomValue(p1.y + MIN, p1.y + MAX)\r\n        };\r\n        dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n        const distanceX = Math.abs(p3.x - p2.x);\r\n        const p4X = getRandomValue(0, 2) === 1 ? p1.x + distanceX : p1.x - distanceX;\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: p4X,\r\n          y: p3.y\r\n        };\r\n        dataViewModel.updateCoordinate(name[3], p4);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        // TODO: vuong tai dau?\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// hinh binh hanh\r\nfunction generateParallelogram(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    let p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.x + MIN, p1.x + MAX)\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    let p4: CoordinateType = {\r\n      x: p3.x - p2.x - p1.x,\r\n      y: p3.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateRectangle(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: getRandomValue(p2.y + MIN, p2.y + MAX)\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thoi\r\nfunction generateRhombus(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: -getRandomValue(p1.y + MIN, p1.y + MAX)\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: 2 * Math.abs(p2.x - p1.x),\r\n      y: p1.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p2.x,\r\n      y: Math.abs(-p2.y - p1.y)\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateSquare(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = { x: 0, y: 0, z: 0 };\r\n    dataViewModel.updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: p2.y + calculateDistanceTwoPoints(p1, p2)\r\n    };\r\n    dataViewModel.updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y\r\n    };\r\n    dataViewModel.updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateCircle(name: string) {}\r\n","import type { CoordinateType, EquationType, NodeRelationType, NodeType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionTwoCircleEquations,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  getLineFromTwoPoints,\r\n  calculateInCircleEquation,\r\n  calculateCircumCircleEquation,\r\n  getAngleFromTwoLines,\r\n  calculateMiddlePoint,\r\n  calculateSymmetricalPoint\r\n} from '../math/Math2D';\r\nimport { getRandomValue } from '../math/Generation';\r\nimport { mappingShapeType, shapeRules, TwoStaticPointRequireShape, circleType } from '../definition/define';\r\nimport { generateGeometry } from '../math/GenerateGeometry';\r\nimport { readRelation } from './ReadRelation';\r\nimport ErrorService from '../../utils/ErrorHandleService.js';\r\nimport appData from '../../Model/AppData.js';\r\n\r\nlet shape, shapeName, shapeType;\r\n\r\nexport function readPointsMap(): Array | {} {\r\n  dataViewModel.createPointDetails();\r\n  console.table(dataViewModel.getData.getPointsMap);\r\n\r\n  while (!dataViewModel.isPointsMapStatic()) {\r\n    //get node to calculate\r\n    const executingNode = dataViewModel.getNextExecuteNode();\r\n    if (!executingNode) break;\r\n    console.log(executingNode.id);\r\n\r\n    executeRelations(executingNode);\r\n\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(executingNode.id)) {\r\n      const roots = dataViewModel.getData.getPointDetails.get(executingNode.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(executingNode.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[executingNode.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(executingNode.id, coordinate);\r\n      }\r\n    }\r\n\r\n    //appModel.updatePointsMap(executingNode);\r\n    dataViewModel.getData.getExecutedNode.push(executingNode.id);\r\n\r\n    //update static Node\r\n    dataViewModel.updateStaticNode();\r\n\r\n    if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n      makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], executingNode.id);\r\n    }\r\n  }\r\n\r\n  dataViewModel.getData.getPointsMap.forEach((node: NodeType) => {\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(node.id)) {\r\n      console.log(dataViewModel.getData.getPointDetails.get(node.id));\r\n      const roots = dataViewModel.getData.getPointDetails.get(node.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(node.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[node.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n        dataViewModel.updateCoordinate(node.id, coordinate);\r\n      }\r\n    }\r\n  });\r\n\r\n  return dataViewModel.getData.getPointsMap.map((node) => ({\r\n    id: node.id,\r\n    coordinate: node.coordinate\r\n  }));\r\n}\r\n\r\nfunction executeRelations(node: NodeType) {\r\n  const executingNodeRelations = _makeUniqueNodeRelation(node.dependentNodes);\r\n\r\n  executingNodeRelations.forEach((relation) => {\r\n    let relationEquation;\r\n    if (relation.outputType === 'shape') {\r\n      shapeName = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n      shapeType = mappingShapeType[relation.type] || 'normal';\r\n      shape = relation[shapeName];\r\n      if (circleType.includes(shapeType)) {\r\n        let data = null;\r\n        console.log(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n        );\r\n        switch (shapeType) {\r\n          case 'nội tiếp':\r\n            data = calculateInCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'ngoại tiếp':\r\n            data = calculateCircumCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        if (data) {\r\n          dataViewModel.circlesData[relation.point[0]] = data;\r\n          dataViewModel.updateCoordinate(relation.point[0], data.center);\r\n        } else {\r\n          ErrorService.ErrorMessage('400');\r\n        }\r\n      } else if (!dataViewModel.isExecutedRelation(relation)) {\r\n        generateGeometry(relation[shapeName], shapeName, relation.type);\r\n        setPointsDirection(relation[shapeName]);\r\n      }\r\n      if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n        makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], node.id);\r\n      }\r\n    }\r\n    relationEquation = readRelation(relation, node.id);\r\n    if (relationEquation) {\r\n      if (Array.isArray(relationEquation)) {\r\n        relationEquation = relationEquation[getRandomValue(0, relationEquation.length)];\r\n      }\r\n      dataViewModel.executePointDetails(node.id, relationEquation);\r\n    }\r\n    if (!dataViewModel.isExecutedRelation(relation)) {\r\n      dataViewModel.getData.getExecutedRelations.push(relation);\r\n    }\r\n  });\r\n}\r\n\r\nfunction setPointsDirection(shape: string) {\r\n  shape.split('').forEach((point, index) => {\r\n    if (index > 0) {\r\n      const pointCoordinate = dataViewModel.getNodeInPointsMapById(point).coordinate;\r\n      const rootCoordinate = dataViewModel.getNodeInPointsMapById(shape[index - 1]).coordinate;\r\n\r\n      dataViewModel.getData.getPointDirectionMap[point] = {\r\n        root: shape[index - 1],\r\n        isRight: pointCoordinate.x > rootCoordinate.x,\r\n        isUp: pointCoordinate.y < rootCoordinate.y\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\nexport function _makeUniqueNodeRelation(dependentNodes: Array<NodeRelationType>): Array<any> {\r\n  let result: Array<NodeRelationType> = [];\r\n\r\n  for (let index = 0; index < dependentNodes.length; index++) {\r\n    let temp = true;\r\n\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (dependentNodes[index].relation === result[i]) {\r\n        temp = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (temp) result.push(dependentNodes[index].relation);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction makeCorrectShape(shape: string, shapeName: string, rules: string, executePoint: string) {\r\n  const staticPointCountRequire = TwoStaticPointRequireShape.includes(shapeName) ? 2 : 1;\r\n  let staticPoints = shape.replace(executePoint, '').split('');\r\n  // check other points are static\r\n  let count = 0;\r\n  for (let i = 0; i < staticPoints.length; i++) {\r\n    if (dataViewModel.isStaticNodeById(staticPoints[i])) {\r\n      count++;\r\n    }\r\n  }\r\n\r\n  if (count < staticPointCountRequire) {\r\n    return;\r\n  }\r\n\r\n  // get node information\r\n  let arrayRules = rules.split(new RegExp('&', 'g'));\r\n\r\n  const executePointIndex = shape.indexOf(executePoint);\r\n  let nodeSetEquations = [];\r\n  if (arrayRules.length > 0) {\r\n    arrayRules.forEach((rule) => {\r\n      const relationType = rule[2];\r\n      if (rule.includes(executePointIndex)) {\r\n        let equation;\r\n        // eslint-disable-next-line default-case\r\n        switch (relationType) {\r\n          case '|':\r\n            equation = getLinearEquationByParallelRule(rule, shape, executePointIndex);\r\n            break;\r\n          case '^':\r\n            if (rule[1] === rule[3]) {\r\n              equation = getLinearEquationByPerpendicularRule(rule, shape, executePointIndex);\r\n            } else {\r\n              updateCoordinateBySpecialPerpendicularRule(rule, shape, executePointIndex);\r\n            }\r\n            break;\r\n          case '=':\r\n            equation = getLinearEquationsByEqualRule(rule, shape, executePointIndex);\r\n            break;\r\n        }\r\n        if (equation) {\r\n          nodeSetEquations = nodeSetEquations.concat(equation);\r\n        }\r\n      }\r\n    });\r\n    if (executePoint === 'C') console.log(nodeSetEquations);\r\n    nodeSetEquations.forEach((equation) => {\r\n      dataViewModel.executePointDetails(executePoint, equation);\r\n    });\r\n  }\r\n}\r\n\r\nfunction updateCoordinateBySpecialPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  let includeLine, nonIncludeLine;\r\n  const staticLines = rule\r\n    .split('^')\r\n    .filter(\r\n      (line: string): boolean =>\r\n        dataViewModel.isStaticNodeById(shape[line[0]]) && dataViewModel.isStaticNodeById(shape[line[1]])\r\n    );\r\n\r\n  rule.split('^').forEach((line: string) => {\r\n    if (line.includes(executePointIndex)) {\r\n      includeLine = line;\r\n    } else {\r\n      nonIncludeLine = line;\r\n    }\r\n  });\r\n\r\n  const shapePoints = shape\r\n    .split('')\r\n    .map((point: string): CoordinateType => dataViewModel.getNodeInPointsMapById(point).coordinate);\r\n\r\n  if (staticLines.length === 1) {\r\n    const intersectPoint = calculateMiddlePoint(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]]);\r\n    const nonStaticLine = staticLines[0] === nonIncludeLine ? includeLine : nonIncludeLine;\r\n\r\n    const staticPointIndex = nonStaticLine.split('').filter((pointIndex: string): boolean => {\r\n      return dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n    if (shape[nonIncludeLine.replace(staticPointIndex, '')]) {\r\n      const calculatedCoordinate = calculateSymmetricalPoint(shapePoints[staticPointIndex], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[nonIncludeLine.replace(staticPointIndex, '')], calculatedCoordinate);\r\n    }\r\n  } else if (staticLines.length === 0) {\r\n    //line perpendicular with line include 1 static point\r\n    const intersectPoint = calculateIntersectionByLineAndLine(\r\n      calculatePerpendicularLineByPointAndLine(\r\n        shapePoints[executePointIndex],\r\n        getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n      ),\r\n      getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n    );\r\n    let calculatedCoordinate;\r\n    //update coordinate\r\n    const otherPointInIncludeLine = includeLine.replace(executePointIndex, '');\r\n    if (!dataViewModel.isStaticNodeById(shape[otherPointInIncludeLine])) {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[executePointIndex], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[otherPointInIncludeLine], calculatedCoordinate);\r\n    } else {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[otherPointInIncludeLine], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[executePointIndex], calculatedCoordinate);\r\n    }\r\n    const nonStaticPointIndex = nonIncludeLine.split('').filter((pointIndex: string): boolean => {\r\n      return !dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n\r\n    calculatedCoordinate = calculateSymmetricalPoint(\r\n      shapePoints[nonIncludeLine.replace(nonStaticPointIndex, '')],\r\n      intersectPoint\r\n    );\r\n\r\n    dataViewModel.updateCoordinate(shape[nonStaticPointIndex], calculatedCoordinate);\r\n  }\r\n}\r\n\r\nfunction getLinearEquationsByEqualRule(rule: string, shape: string, executePointIndex: number): Array<EquationType> {\r\n  const lines = rule.split('=');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  console.log(staticLine, nonStaticLine);\r\n  if (staticLine) {\r\n    const count = staticLine.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n\r\n    if (count < 2) {\r\n      return [];\r\n    }\r\n\r\n    const otherPoint = shape[nonStaticLine.replace(executePointIndex, '')];\r\n\r\n    const radius = calculateDistanceTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n    );\r\n\r\n    //point is outside static line\r\n    if (staticLine.includes(nonStaticLine.replace(executePointIndex, ''))) {\r\n      return [\r\n        calculateCircleEquationByCenterPoint(dataViewModel.getNodeInPointsMapById(otherPoint).coordinate, radius)\r\n      ];\r\n    }\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByParallelRule(rule: string, shape: string, executePointIndex: number): EquationType {\r\n  const lines = rule.split('|');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  if (\r\n    staticLine &&\r\n    nonStaticLine.includes(executePointIndex) &&\r\n    dataViewModel.isStaticNodeById(shape[nonStaticLine.replace(executePointIndex, '')])\r\n  ) {\r\n    return [\r\n      calculateParallelLineByPointAndLine(\r\n        //point\r\n        dataViewModel.getNodeInPointsMapById(shape[nonStaticLine.replace(executePointIndex, '')]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  const lines = rule.split('^');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n\r\n  if (staticLine && nonStaticLine.includes(executePointIndex) && !staticLine.includes(executePointIndex)) {\r\n    return [\r\n      calculatePerpendicularLineByPointAndLine(\r\n        //Common point\r\n        dataViewModel.getNodeInPointsMapById(shape[rule[1]]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n","import type { CoordinateType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateInternalBisectLineEquation,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionEquationTypeWithCircleEquation,\r\n  calculateLinesByAnotherLineAndAngle,\r\n  calculateMiddlePoint,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  calculateSymmetricalPoint,\r\n  getAngleFromTwoLines,\r\n  getLineFromTwoPoints,\r\n  getMiddlePointFromThreePointsInALine,\r\n  isIn,\r\n  calculateIntersectionTwoCircleEquations,\r\n  isVectorInSameLine,\r\n  calculateExternalBisectLineEquation,\r\n  calculateVector,\r\n  calculateTangentEquation,\r\n  calculateTangentIntersectPointsByPointOutsideCircle\r\n} from '../math/Math2D';\r\nimport {\r\n  generatePointAlignmentInside,\r\n  generatePointAlignmentOutside,\r\n  generatePointMiddleTwoPoints,\r\n  getRandomPointInEquation,\r\n  getRandomValue\r\n} from '../math/Generation.js';\r\nimport ErrorService from '../../utils/ErrorHandleService';\r\nimport { ShapeAffectBySegmentChange, TwoStaticPointRequireShape } from '../definition/define';\r\n\r\nexport function readRelation(relation: mixed, point: string) {\r\n  let equationResults;\r\n\r\n  dataViewModel.executingRelation = relation;\r\n  if (relation.operation) {\r\n    equationResults = analyzeOperationType(relation, point);\r\n  } else if (relation.relation) {\r\n    const relationType = relation.relation;\r\n    switch (relationType) {\r\n      case 'trung điểm':\r\n      case 'thuộc':\r\n      case 'không thuộc':\r\n      case 'song song':\r\n      case 'vuông góc':\r\n      case 'phân giác':\r\n      case 'phân giác ngoài':\r\n      case 'phân giác trong':\r\n      case 'thẳng hàng':\r\n        equationResults = analyzeRelationType(relation, point);\r\n        break;\r\n      case 'cắt':\r\n        equationResults = analyzeIntersectRelation(relation, point);\r\n        break;\r\n      case 'tiếp tuyến':\r\n        equationResults = analyzeTangentRelation(relation, point);\r\n        break;\r\n      default:\r\n        equationResults = null;\r\n    }\r\n  } else if (relation.outputType === 'shape') {\r\n    const shapeType = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n    switch (shapeType) {\r\n      case 'triangle':\r\n        equationResults = getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate\r\n        );\r\n        break;\r\n      case 'quadrilateral':\r\n      case 'rectangle':\r\n      case 'square':\r\n      case 'rhombus':\r\n      case 'trapezoid':\r\n      case 'parallelogram':\r\n        if (shapeType !== 'quadrilateral') {\r\n          let count = 0;\r\n          relation[shapeType].split('').forEach((point) => {\r\n            if (dataViewModel.isStaticNodeById(point)) {\r\n              count++;\r\n            }\r\n          });\r\n          const limit = TwoStaticPointRequireShape.includes(shapeType) ? 1 : 2;\r\n          if (count > limit) {\r\n            return;\r\n          }\r\n        }\r\n        let index = relation[shapeType].indexOf(point);\r\n        if (index === relation[shapeType].length - 1) {\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate\r\n          );\r\n        } else {\r\n          index = index === 0 ? relation[shapeType].length - 1 : index - 1;\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(point).coordinate\r\n          );\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  //TODO\r\n  if (equationResults) {\r\n    if (equationResults.coefficientX !== undefined) {\r\n      // equationResults is linear\r\n      return {\r\n        a: 0,\r\n        b: 0,\r\n        c: equationResults.coefficientX,\r\n        d: equationResults.coefficientY,\r\n        e: equationResults.constantTerm\r\n      };\r\n    } else {\r\n      // equationResults is circle\r\n      return equationResults;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction analyzeRelationType(relation: mixed, point: string): LinearEquation {\r\n  let segmentIncludePoint, segmentNotIncludePoint;\r\n  if (relation.segment) {\r\n    relation.segment.forEach((segment: string) => {\r\n      if (segment.includes(point)) {\r\n        segmentIncludePoint = segment;\r\n      } else {\r\n        segmentNotIncludePoint = segment;\r\n      }\r\n    });\r\n  }\r\n\r\n  //points = [...new Set(points)].filter((point: string): boolean => !nonStaticPoints.includes(point));\r\n  const relationType = relation.relation;\r\n\r\n  if (\r\n    relationType === 'trung điểm' ||\r\n    relationType === 'thuộc' ||\r\n    relationType === 'không thuộc' ||\r\n    relationType === 'thẳng hàng'\r\n  ) {\r\n    let calculatedPoint;\r\n    if (relation.circle) {\r\n      calculatedPoint = getRandomPointInEquation(dataViewModel.getCircleEquation(relation.circle[0]));\r\n      dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n      return dataViewModel.getCircleEquation(relation.circle[0]);\r\n    }\r\n    if (segmentIncludePoint) {\r\n      const otherStaticPoint = relation.point[0];\r\n      const otherStaticNodeInSegment = dataViewModel.getNodeInPointsMapById(segmentIncludePoint.replace(point, ''));\r\n\r\n      if (!otherStaticNodeInSegment.coordinate.x && !otherStaticNodeInSegment.coordinate.y) {\r\n        return null;\r\n      }\r\n\r\n      if (relationType === 'trung điểm') {\r\n        calculatedPoint = calculateSymmetricalPoint(\r\n          otherStaticNodeInSegment.coordinate,\r\n          dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n          segmentIncludePoint.indexOf(point) === 1\r\n        );\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n    } else if (segmentNotIncludePoint) {\r\n      switch (relationType) {\r\n        case 'trung điểm':\r\n          calculatedPoint = calculateMiddlePoint(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'thuộc':\r\n          calculatedPoint = generatePointAlignmentInside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'không thuộc':\r\n          calculatedPoint = generatePointAlignmentOutside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate,\r\n            getRandomValue(0, 2) === 1\r\n          );\r\n\r\n          dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else {\r\n      const points = relation.point;\r\n      const index = points.indexOf(point);\r\n      if (index === 1) {\r\n        calculatedPoint = generatePointAlignmentInside(\r\n          dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[2]).coordinate\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedPoint = generatePointAlignmentOutside(\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 0 : 1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 1 : 2]).coordinate,\r\n          index === 2\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(points[1]).coordinate\r\n      );\r\n    }\r\n\r\n    return getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n  } else if (relationType === 'song song' || relationType === 'vuông góc') {\r\n    if (!segmentNotIncludePoint) {\r\n      return;\r\n    }\r\n    const otherStaticPoint = segmentIncludePoint.replace(point, '');\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint) && !dataViewModel.isValidCoordinate(point)) {\r\n      const point = generatePointMiddleTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n      );\r\n      if (point) {\r\n        dataViewModel.updateCoordinate(otherStaticPoint, point);\r\n      }\r\n    }\r\n    //undefined point\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(segmentNotIncludePoint[i])) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const staticLineEquation = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n    );\r\n\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint)) {\r\n      return;\r\n    }\r\n\r\n    let calculatedLineEquation;\r\n    if (relationType === 'vuông góc') {\r\n      calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const isInStaticLine = isIn(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n      const calculatedPoint = isInStaticLine\r\n        ? getRandomPointInEquation(calculatedLineEquation)\r\n        : calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n\r\n      if (!isInStaticLine) {\r\n        dataViewModel.getData.pushAdditionSegment(`${point}${segmentNotIncludePoint[1]}`);\r\n        dataViewModel.getData.pushAdditionSegment(`${point}${segmentNotIncludePoint[0]}`);\r\n      }\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    if (relationType === 'song song') {\r\n      calculatedLineEquation = calculateParallelLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    return calculatedLineEquation;\r\n  } else if (relationType.includes('phân giác')) {\r\n    const isExternal = relationType === 'phân giác ngoài';\r\n\r\n    if (relation.angle) {\r\n      const angle = relation.angle[0];\r\n      if (angle.includes(point)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n      );\r\n      let calculatedLineEquation;\r\n      if (isExternal) {\r\n        calculatedLineEquation = calculateExternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedLineEquation = calculateInternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return calculatedLineEquation;\r\n    }\r\n  }\r\n}\r\n\r\nfunction analyzeIntersectRelation(relation: mixed, point: string): CoordinateType {\r\n  for (let index in relation.segment) {\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(relation.segment[index][i])) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if (relation.segment.length === 2) {\r\n    const calculatedLineEquationOne = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n    const calculatedLineEquationTwo = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][1]).coordinate\r\n    );\r\n\r\n    relation.segment.forEach((segment: string) => {\r\n      dataViewModel.getData.pushAdditionSegment(`${relation.point[0]}${segment[0]}`);\r\n      dataViewModel.getData.pushAdditionSegment(`${relation.point[0]}${segment[1]}`);\r\n    });\r\n\r\n    const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquationOne, calculatedLineEquationTwo);\r\n\r\n    dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n  } else if (relation.circle.length === 2) {\r\n    const roots = calculateIntersectionTwoCircleEquations(\r\n      dataViewModel.getCircleEquation(relation.circle[0]),\r\n      dataViewModel.getCircleEquation(relation.circle[1])\r\n    );\r\n\r\n    roots.forEach((root: CoordinateType, index: number) => {\r\n      if (!relation.point[index]) {\r\n        ErrorService.showError('500');\r\n      } else {\r\n        dataViewModel.updateCoordinate(relation.point[index], root);\r\n      }\r\n    });\r\n  } else {\r\n    const pointOne = dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate;\r\n    const pointTwo = dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate;\r\n    let roots = calculateIntersectionTwoCircleEquations(\r\n      getLineFromTwoPoints(pointOne, pointTwo),\r\n      dataViewModel.getCircleEquation(relation.circle[0])\r\n    );\r\n\r\n    roots = roots.filter(\r\n      (root: CoordinateType): boolean =>\r\n        JSON.stringify(root) !== JSON.stringify(pointOne) && JSON.stringify(root) !== JSON.stringify(pointTwo)\r\n    );\r\n    if (relation.point.length === 2) {\r\n      roots.forEach((root: CoordinateType, index: number) => {\r\n        if (!relation.point[index]) {\r\n          ErrorService.showError('200');\r\n        } else {\r\n          dataViewModel.updateCoordinate(relation.point[index], root);\r\n        }\r\n      });\r\n    } else {\r\n      dataViewModel.updateCoordinate(relation.point[0], roots[getRandomValue(0, roots.length - 1)]);\r\n    }\r\n  }\r\n}\r\n\r\n//chỉ xử lý : = , *\r\nfunction analyzeOperationType(relation: mixed, point: string): any {\r\n  const objectType = relation.segment ? 'segment' : 'angle';\r\n  const valueData = {};\r\n\r\n  const objectsIncludePoint = [];\r\n\r\n  for (let index in relation[objectType]) {\r\n    const object = relation[objectType][index];\r\n    if (object.includes(point)) {\r\n      objectsIncludePoint.push(object);\r\n    }\r\n    let isStatic = true;\r\n    object.split('').forEach((objPoint) => {\r\n      if (objPoint !== point && !dataViewModel.isStaticNodeById(objPoint)) {\r\n        isStatic = false;\r\n      }\r\n    });\r\n\r\n    if (!isStatic) {\r\n      return;\r\n    }\r\n\r\n    valueData[object] =\r\n      objectType === 'segment'\r\n        ? calculateDistanceTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n          )\r\n        : getAngleFromTwoLines(\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n            ),\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[2]).coordinate\r\n            )\r\n          );\r\n  }\r\n\r\n  //điểm cần tính phụ thuộc 1 điểm duy nhất\r\n  if (objectsIncludePoint.length === 1) {\r\n    const index = relation[objectType].indexOf(objectsIncludePoint[0]);\r\n    const staticObject = relation[objectType][index === 0 ? 1 : 0];\r\n    let staticValue;\r\n    if (relation[objectType].length > 1) {\r\n      staticValue = index === 0 ? relation.value * valueData[staticObject] : valueData[staticObject] / relation.value;\r\n    } else {\r\n      staticValue = relation.value[0];\r\n    }\r\n\r\n    if (objectType === 'segment') {\r\n      return calculateCircleEquationByCenterPoint(\r\n        dataViewModel.getNodeInPointsMapById(objectsIncludePoint[0].replace(point, '')).coordinate,\r\n        staticValue\r\n      );\r\n    }\r\n\r\n    return calculateLineEquationByAngleRelation(objectsIncludePoint[0], staticValue);\r\n  }\r\n  if (objectsIncludePoint.length === 2) {\r\n    if (objectType === 'segment') {\r\n      const staticPointOne = objectsIncludePoint[0].replace(point, '');\r\n      const staticPointTwo = objectsIncludePoint[1].replace(point, '');\r\n      //cần check thêm loại shape\r\n      if (!dataViewModel.isStaticNodeById(staticPointOne) || !dataViewModel.isStaticNodeById(staticPointTwo)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const staticDistance = calculateDistanceTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const isAlign = isIn(dataViewModel.getNodeInPointsMapById(point).coordinate, {\r\n        a: 0,\r\n        b: 0,\r\n        c: staticLineEquation.coefficientX,\r\n        d: staticLineEquation.coefficientY,\r\n        e: staticLineEquation.constantTerm\r\n      });\r\n\r\n      const ratio = +relation.value[0];\r\n      if (isAlign) {\r\n        let calculatedPoint;\r\n        const betweenPoint = getMiddlePointFromThreePointsInALine(\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n        );\r\n\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(point).coordinate) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio + 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === p) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate && ratio < 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (1 - ratio)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate && ratio > 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio - 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n\r\n        return staticLineEquation;\r\n      } else {\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateLineEquationByAngleRelation(angleName: string, angleValue: number): EquationType {\r\n  const modifiedAngleName = renameAngle(angleName);\r\n  const staticPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[0]).coordinate;\r\n  const rootPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[1]).coordinate;\r\n  const changedPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[2]).coordinate;\r\n  const calculatedEquation = calculateLinesByAnotherLineAndAngle(rootPoint, staticPoint, changedPoint, angleValue);\r\n\r\n  const intersectPoint = calculateIntersectionByLineAndLine(\r\n    calculatedEquation,\r\n    getLineFromTwoPoints(staticPoint, rootPoint)\r\n  );\r\n  const newRootPoint = calculateIntersectionTwoCircleEquations(\r\n    calculatedEquation,\r\n    calculateCircleEquationByCenterPoint(changedPoint, calculateDistanceTwoPoints(changedPoint, rootPoint))\r\n  ).sort((rootOne: CoordinateType, rootTwo: CoordinateType): number => {\r\n    return calculateDistanceTwoPoints(intersectPoint, rootOne) - calculateDistanceTwoPoints(intersectPoint, rootTwo);\r\n  })[0];\r\n\r\n  //move newRoot to oldRoot\r\n  const transitionVector = calculateVector(newRootPoint, rootPoint, false);\r\n\r\n  if (modifiedAngleName === angleName) {\r\n    dataViewModel.updateCoordinate(modifiedAngleName[2], {\r\n      x: changedPoint.x + transitionVector.x,\r\n      y: changedPoint.y + transitionVector.y\r\n    });\r\n\r\n    dataViewModel.replaceSetOfEquation(\r\n      modifiedAngleName[2],\r\n      getLineFromTwoPoints(rootPoint, changedPoint),\r\n      calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  dataViewModel.updateCoordinate(modifiedAngleName[0], {\r\n    x: staticPoint.x - transitionVector.x,\r\n    y: staticPoint.y - transitionVector.y\r\n  });\r\n\r\n  dataViewModel.replaceSetOfEquation(\r\n    modifiedAngleName[1],\r\n    getLineFromTwoPoints(rootPoint, changedPoint),\r\n    calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n  );\r\n\r\n  return null;\r\n}\r\n\r\nfunction getShapeAffectList(): Array<string> {\r\n  const shapeList = [];\r\n\r\n  //get list of shape name\r\n  dataViewModel.getData.relationsResult.shapes.forEach((shapeData: Object): boolean => {\r\n    const shapeType = Object.keys(shapeData).filter((key: string): boolean => key !== 'outputType')[0];\r\n    if (ShapeAffectBySegmentChange.includes(shapeType)) {\r\n      shapeList.push(shapeData[shapeType]);\r\n    }\r\n  });\r\n\r\n  return shapeList;\r\n}\r\n\r\nfunction renameAngle(angle: string): string {\r\n  const shapeList = getShapeAffectList();\r\n\r\n  const secondLine = `${angle[1]}${angle[2]}`;\r\n\r\n  for (let i = 0; i < shapeList.length; i++) {\r\n    const shape = shapeList[i];\r\n    const secondLineVector = calculateVector(\r\n      dataViewModel.getNodeInPointsMapById(secondLine[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(secondLine[1]).coordinate\r\n    );\r\n\r\n    if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      return angle\r\n        .split('')\r\n        .reverse()\r\n        .join('');\r\n    }\r\n  }\r\n  return angle;\r\n}\r\n\r\nfunction analyzeTangentRelation(relation: mixed, point: string): any {\r\n  const otherPointInSegment = relation.segment[0].replace(point, '');\r\n  if (!dataViewModel.isStaticNodeById(otherPointInSegment)) {\r\n    return;\r\n  }\r\n\r\n  const tangentPointCoordinate = dataViewModel.getNodeInPointsMapById(otherPointInSegment).coordinate;\r\n  const circleEquation = dataViewModel.getCircleEquation(relation.circle[0]);\r\n  let tangentEquation;\r\n  if (isIn(tangentPointCoordinate, circleEquation)) {\r\n    tangentEquation = calculateTangentEquation(circleEquation, tangentPointCoordinate);\r\n    dataViewModel.updateCoordinate(point, getRandomPointInEquation(tangentEquation));\r\n  } else {\r\n    const roots = calculateTangentIntersectPointsByPointOutsideCircle(circleEquation, tangentPointCoordinate);\r\n    const result = filterTangentPoint(roots, circleEquation);\r\n    tangentEquation = result.tangentEquation;\r\n    dataViewModel.updateCoordinate(point, result.point);\r\n  }\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nfunction filterTangentPoint(\r\n  roots: Array<CoordinateType>,\r\n  circleEquation: EquationType\r\n): { equation: EquationType, point: CoordinateType } {\r\n  const filterRoots = roots.filter((root: CoordinateType): boolean => !dataViewModel.isCoordinateDuplicated(root));\r\n\r\n  return filterRoots.map((root: CoordinateType): { equation: EquationType, point: CoordinateType } => {\r\n    return {\r\n      equation: calculateTangentEquation(circleEquation, root),\r\n      point: root\r\n    };\r\n  })[getRandomValue(0, filterRoots.length - 1)];\r\n}\r\n","// @flow\r\n\r\nimport { objectWithPoint } from '../definition/define.js';\r\nimport type { DrawingDataType, NodeRelationType, NodeType } from '../../utils/types.js';\r\nimport dataViewModel from '../../ViewModel/DataViewModel';\r\nimport { readPointsMap } from './ReadPointsMap';\r\nimport { makeRoundCoordinate } from '../math/Math2D.js';\r\n\r\nlet RelationPointsMap: Array<NodeType> = [];\r\n\r\nexport function analyzeResult(validatedResult): DrawingDataType {\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    createPointsMapByShape(shape);\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n  relations.forEach((relation) => {\r\n    createPointsMapByRelation(relation).forEach((node) => {\r\n      updateMap(node, dataViewModel.getData.getPointsMap);\r\n    });\r\n  });\r\n\r\n  trimPointsMap();\r\n\r\n  let result = {};\r\n\r\n  readPointsMap();\r\n  result.points = dataViewModel.getData.getPointsMap.map((node: NodeType) => ({\r\n    id: node.id,\r\n    coordinate: makeRoundCoordinate(node.coordinate, 3)\r\n  }));\r\n\r\n  result.segments = [...getArraySegments(validatedResult), ...dataViewModel.getData.getAdditionSegment];\r\n  return result;\r\n}\r\n\r\nfunction getArraySegments(validatedResult): Array<string> {\r\n  let result: Array<string> = [];\r\n\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    result = result.concat(getShapeSegments(shape));\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n\r\n  relations.forEach((relation) => {\r\n    if (relation.segment) {\r\n      result = result.concat(relation.segment);\r\n    }\r\n  });\r\n\r\n  return result.filter((item, index, array) => array.indexOf(item) === index);\r\n}\r\n\r\nfunction getShapeSegments(shape: any): Array<string> {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  const result = [];\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    if (i === points.length - 1) {\r\n      result.push(points[0] + points[i]);\r\n    } else {\r\n      result.push(points[i] + points[i + 1]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction trimPointsMap() {\r\n  dataViewModel.getData.setPointsMap = dataViewModel.getData.getPointsMap.map((node: NodeType): NodeType => ({\r\n    ...node,\r\n    dependentNodes: unique(node.dependentNodes)\r\n  }));\r\n}\r\n\r\nfunction unique(dependentNodes: Array<NodeRelationType>): Array<NodeRelationType> {\r\n  let result = [];\r\n\r\n  dependentNodes.forEach((node) => {\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (JSON.stringify(node) === JSON.stringify(result[i])) return;\r\n    }\r\n    result.push(node);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction sortPriority(points) {\r\n  return points.sort((el1: string, el2: string): number => {\r\n    const index1 = findIndexByNodeId(el1, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(el2, dataViewModel.getData.getPointsMap);\r\n\r\n    if (index1 === -1 && index2 === -1) {\r\n      return 1;\r\n    }\r\n    if (index1 >= 0 && index2 >= 0) return 1;\r\n    return index2 - index1;\r\n  });\r\n}\r\n\r\nfunction createPointsMapByShape(shape: any) {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  points = sortPriority([...points]);\r\n\r\n  if (dataViewModel.getData.getPointsMap.length === 0) {\r\n    const shouldStaticPoint = getFirstStaticPointInShape(shape[shapeName]);\r\n    points = [shouldStaticPoint].concat(points.filter((point) => point !== shouldStaticPoint));\r\n  }\r\n\r\n  let objectPointsMap;\r\n  // đường tròn ngoại tiếp, nội tiếp\r\n  if (shape.point) {\r\n    objectPointsMap = points.map((point: string) => {\r\n      return createNode(shape.point[0], [{ id: point, relation: shape }]);\r\n    });\r\n  } else {\r\n    objectPointsMap = points.map((point: string, index: number) => {\r\n      return index !== 0 ? createNode(point, [{ id: points[0], relation: shape }]) : createNode(point);\r\n    });\r\n  }\r\n  objectPointsMap.forEach((node: NodeType) => {\r\n    updateMap(node, dataViewModel.getData.getPointsMap);\r\n  });\r\n}\r\n\r\nfunction getFirstStaticPointInShape(shape: string): string {\r\n  const angles = [];\r\n  if (dataViewModel.getData.getRelationsResult.relations) {\r\n    dataViewModel.getData.getRelationsResult.relations.forEach((relation) => {\r\n      if (!relation.angle) {\r\n        return;\r\n      }\r\n      angles.push(relation.angle[0]);\r\n    });\r\n\r\n    const shapePointCount = {};\r\n\r\n    angles.forEach((angle: string): void => {\r\n      angle.split('').forEach((point, index) => {\r\n        //don't check middle point\r\n        if (index !== 1) {\r\n          if (shapePointCount[point]) {\r\n            shapePointCount[point] += 1;\r\n          } else {\r\n            shapePointCount[point] = 1;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    let minCountPoint = shape[0];\r\n    Object.keys(shapePointCount).forEach((point) => {\r\n      if (shapePointCount[point] < shapePointCount[minCountPoint]) {\r\n        minCountPoint = point;\r\n      }\r\n    });\r\n\r\n    return minCountPoint;\r\n  }\r\n  return shape[0];\r\n}\r\n\r\nfunction createPointsMapByRelation(relation: any) {\r\n  RelationPointsMap = [];\r\n  objectWithPoint.forEach((objectType: string) => {\r\n    if (relation[objectType]) {\r\n      relation[objectType].forEach((object) => {\r\n        let points = object.split('').filter((point) => point === point.toUpperCase());\r\n\r\n        points = sortPriority([...points]);\r\n\r\n        const objectPointsMap = points.map((point: string, index: number) => {\r\n          return index === points.length - 1\r\n            ? createNode(point, createDependentNodeOfObject(objectType, object, points))\r\n            : createNode(point);\r\n        });\r\n\r\n        objectPointsMap.forEach((node: NodeType) => {\r\n          updateMap(node, RelationPointsMap);\r\n        });\r\n      });\r\n    }\r\n  });\r\n\r\n  RelationPointsMap = [...RelationPointsMap].sort((nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const index1 = findIndexByNodeId(nodeOne.id, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(nodeTwo.id, dataViewModel.getData.getPointsMap);\r\n    if (index1 === -1 && index2 === -1) return 1;\r\n    if (index1 >= 0 && index2 >= 0) return index1 - index2;\r\n    return index2 - index1;\r\n  });\r\n\r\n  let lastObjectPoints;\r\n\r\n  if (relation.angle && relation.outputType === 'define' && !!relation.value) {\r\n    const index1 = findIndexByNodeId(relation.angle[0][0], dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(relation.angle[0][2], dataViewModel.getData.getPointsMap);\r\n    lastObjectPoints = [index1 > index2 ? relation.angle[0][0] : relation.angle[0][2]];\r\n  } else {\r\n    lastObjectPoints = getDependentObject();\r\n  }\r\n  if (lastObjectPoints.length === RelationPointsMap.length) {\r\n    lastObjectPoints = [lastObjectPoints[0]];\r\n  }\r\n  if (relation.relation === 'song song' || relation.relation === 'vuông góc') {\r\n    lastObjectPoints = lastObjectPoints.filter(\r\n      (point: string): boolean => !dataViewModel.getNodeInPointsMapById(point)\r\n    );\r\n  }\r\n  lastObjectPoints.forEach((point) => {\r\n    const index = findIndexByNodeId(point, RelationPointsMap);\r\n    const currentNode = RelationPointsMap[index];\r\n    RelationPointsMap.forEach((node) => {\r\n      if (node.id !== point) {\r\n        RelationPointsMap[index] = {\r\n          ...currentNode,\r\n          dependentNodes: [\r\n            ...currentNode.dependentNodes,\r\n            ...createDependentNodeOfRelation(node.id, relation, lastObjectPoints)\r\n          ]\r\n        };\r\n      }\r\n    });\r\n  });\r\n\r\n  return RelationPointsMap;\r\n}\r\n\r\nfunction getDependentObject(): Array<string> {\r\n  let result: Array = [];\r\n  const lastNode = RelationPointsMap[RelationPointsMap.length - 1];\r\n  if (lastNode) {\r\n    result.push(lastNode.id);\r\n\r\n    lastNode.dependentNodes.forEach((node) => {\r\n      const nodeIndex = findIndexByNodeId(node.id, dataViewModel.getData.getPointsMap);\r\n      if (!result.includes(node.id) && nodeIndex !== -1 && !dataViewModel.getData.getPointsMap[nodeIndex].isStatic)\r\n        result.push(node.id);\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction findIndexByNodeId(id: string, map: Array<NodeType | NodeRelationType>): number {\r\n  for (let i = 0; i < map.length; i++) {\r\n    if (map[i].id === id) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction createDependentNodeOfRelation(\r\n  point: string,\r\n  relation: any,\r\n  exception: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  RelationPointsMap.forEach((node: NodeType) => {\r\n    if (exception.includes(node.id)) return;\r\n    result.push({ id: node.id, relation });\r\n  });\r\n\r\n  console.log(result);\r\n\r\n  return result;\r\n}\r\n\r\nfunction createDependentNodeOfObject(\r\n  objectType: string,\r\n  objectName: string,\r\n  points: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  let relation = {};\r\n  relation[objectType] = objectName;\r\n\r\n  points.forEach((point: string, index: number) => {\r\n    if (index === points.length - 1) return;\r\n    result.push({ id: point, relation });\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction createNode(id: string, dependentNodes?: Array<NodeRelationType>): any {\r\n  const node = { id, coordinate: { x: undefined, y: undefined, z: 0 }, isStatic: false };\r\n  const _dependentNodes = dependentNodes ? { dependentNodes } : { dependentNodes: [] };\r\n\r\n  return { ...node, ..._dependentNodes };\r\n}\r\n\r\nfunction updateMap(node: NodeType, map: Array<NodeType>) {\r\n  const index = findIndexByNodeId(node.id, map);\r\n  if (index !== -1) {\r\n    //merge dependentNodes\r\n    const oldNode = map[index];\r\n    map[index] = {\r\n      ...oldNode,\r\n      dependentNodes: [...oldNode.dependentNodes, ...node.dependentNodes]\r\n    };\r\n  } else {\r\n    map.push(node);\r\n    if (dataViewModel.getData.getPointsMap.length === 1) map[0].isStatic = true;\r\n  }\r\n}\r\n","// @flow\r\nimport { observable } from 'mobx';\r\nimport GConst from '../utils/values';\r\n\r\nexport default class RelationInputModel {\r\n  @observable\r\n  value: string = '';\r\n\r\n  @observable\r\n  status: string = GConst.InputStatus.NORMAL;\r\n\r\n  constructor(value: string) {\r\n    this.value = value;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport appData from '../Model/AppData';\r\nimport type { EquationType, PointDetailsType } from '../utils/types';\r\nimport { NodeType } from '../utils/types';\r\nimport GConst from '../utils/values.js';\r\nimport { calculateIntersectionTwoCircleEquations, isIn, makeRoundCoordinate } from '../core/math/Math2D.js';\r\nimport { isQuadraticEquation } from '../utils/checker.js';\r\nimport { defineSentences } from '../core/definition/define';\r\nimport { defineInformation } from '../core/definition';\r\nimport { analyzeResult } from '../core/analysis/Analysis';\r\nimport RelationInputModel from '../Model/RelationInputModel';\r\nimport { observable, action, computed } from 'mobx';\r\nimport ErrorService from '../utils/ErrorHandleService';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { isTwoEquationEqual } from '../core/math/Math2D';\r\nimport { getRandomValue } from '../core/math/Generation';\r\n\r\nconst NOT_FOUND = GConst.Number.NOT_FOUND;\r\nconst NOT_ENOUGH_SET = GConst.String.NOT_ENOUGH_SET;\r\n\r\nclass DataViewModel {\r\n  @observable\r\n  circlesData = {};\r\n\r\n  @observable\r\n  relationsInput: Array<RelationInputModel>;\r\n\r\n  inputData: Array<mixed> = [];\r\n\r\n  executedInputIndex: number;\r\n\r\n  @observable\r\n  executingRelation: mixed;\r\n\r\n  constructor(appData) {\r\n    this.data = appData;\r\n    this.relationsInput = [\r\n      new RelationInputModel()\r\n    ];\r\n  }\r\n\r\n  @computed\r\n  get RelationsInput() {\r\n    return this.relationsInput;\r\n  }\r\n\r\n  @computed\r\n  get isInputEmpty(): boolean {\r\n    if (this.relationsInput.length === 1 && !this.relationsInput[0].value) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @action\r\n  resetInputsStatus() {\r\n    this.relationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.NORMAL;\r\n    });\r\n  }\r\n\r\n  @action\r\n  onInputChange(value: string, index: number) {\r\n    const newRelationInput = { ...this.relationsInput[index] };\r\n    newRelationInput.value = value;\r\n    this.relationsInput[index] = newRelationInput;\r\n    this.resetInputsStatus();\r\n  }\r\n\r\n  @action\r\n  addNewInput() {\r\n    this.relationsInput.push(new RelationInputModel(''));\r\n  }\r\n\r\n  @action\r\n  removeInput(index: number) {\r\n    this.relationsInput.splice(index, 1);\r\n  }\r\n\r\n  clear() {\r\n    this.data.clear();\r\n  }\r\n\r\n  get getData() {\r\n    return this.data;\r\n  }\r\n\r\n  createPointDetails() {\r\n    this.data.getPointsMap.forEach((node) => {\r\n      const roots = this.isValidCoordinate(node.coordinate) ? [node.coordinate] : [];\r\n      this._updatePointDetails(node.id, {\r\n        setOfEquation: [],\r\n        roots: roots,\r\n        exceptedCoordinates: []\r\n      });\r\n    });\r\n  }\r\n\r\n  isNeedRandomCoordinate = (pointId: string): boolean => {\r\n    const roots = this.data.getPointDetails.get(pointId).roots;\r\n    if (roots) {\r\n      for (let i = 0; i < roots.length; i++) {\r\n        if (\r\n          this.data.getPointDirectionMap[pointId] ||\r\n          JSON.stringify(makeRoundCoordinate(roots[i])) ===\r\n            JSON.stringify(makeRoundCoordinate(this.getNodeInPointsMapById(pointId).coordinate))\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  updateCoordinate = (nodeId: string, coordinate: CoordinateType, f: number = 3): void => {\r\n    const index = this.getIndexOfNodeInPointsMapById(nodeId);\r\n    if (!coordinate) {\r\n      ErrorService.showError('200');\r\n    }\r\n    const _coordinate = {};\r\n    Object.keys(coordinate)\r\n      .sort()\r\n      .forEach((key: string) => {\r\n        _coordinate[key] = coordinate[key];\r\n      });\r\n    if (index !== NOT_FOUND) {\r\n      this.data.getPointsMap[index].coordinate = makeRoundCoordinate(_coordinate, f);\r\n    }\r\n  };\r\n\r\n  isStaticNode = (node: NodeType): boolean => {\r\n    if (node.isStatic) return true;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (!this.isExecutedRelation(node.dependentNodes[i].relation)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return this.data.getExecutedNode.includes(node.id);\r\n  };\r\n\r\n  isExecutedRelation = (relation: any): boolean => {\r\n    for (let i = 0; i < this.data.getExecutedRelations.length; i++) {\r\n      if (JSON.stringify(relation) === JSON.stringify(this.data.getExecutedRelations[i])) return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  updateStaticNode = () => {\r\n    const pointsMap = this.data.getPointsMap.map((node: NodeType): NodeType => {\r\n      node.isStatic = this.isStaticNode(node);\r\n      return node;\r\n    });\r\n    this.data.setPointsMap = pointsMap;\r\n  };\r\n\r\n  updatePointsMap = (node: NodeType) => {\r\n    let index = this.getIndexOfNodeInPointsMapById(node.id);\r\n    this.data.getPointsMap[index] = node;\r\n  };\r\n\r\n  isPointsMapStatic = (): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (!this.data.getPointsMap[i].isStatic) return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  isValidCoordinate = (nodeId: string) => {\r\n    if (nodeId) {\r\n      const node = this.getNodeInPointsMapById(nodeId);\r\n      if (node) {\r\n        return node.coordinate.x !== undefined && node.coordinate.y !== undefined;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  getNextExecuteNode = (): NodeType => {\r\n    const clonePointsMap = this.data.pointsMap\r\n      .filter((node) => !this.data.executedNode.includes(node.id) && !this.isStaticNode(node))\r\n      .sort(this.sortNodeByPriority);\r\n\r\n    if (clonePointsMap.length > 0) return clonePointsMap[0];\r\n    return null;\r\n  };\r\n\r\n  sortNodeByPriority = (nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const staticNodeOneCount = this.getDependentStaticNodeCount(nodeOne);\r\n    const nodeOneData = {\r\n      static: staticNodeOneCount,\r\n      nonStatic: nodeOne.dependentNodes.length - staticNodeOneCount,\r\n      dependence: nodeOne.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeOne),\r\n      index: this.getIndexOfNodeInPointsMap(nodeOne)\r\n    };\r\n\r\n    const staticNodeTwoCount = this.getDependentStaticNodeCount(nodeTwo);\r\n    const nodeTwoData = {\r\n      static: staticNodeTwoCount,\r\n      nonStatic: nodeTwo.dependentNodes.length - staticNodeTwoCount,\r\n      dependence: nodeTwo.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeTwo),\r\n      index: this.getIndexOfNodeInPointsMap(nodeTwo)\r\n    };\r\n\r\n    //get Max\r\n    const rankingOrderDesc = ['static', 'dependence'];\r\n\r\n    //get Min\r\n    const rankingOrderAsc = ['nonStatic', 'minRelationIndex', 'index'];\r\n\r\n    let rankOne = nodeOneData.static === nodeOneData.dependence ? '1' : '0';\r\n    let rankTwo = nodeTwoData.static === nodeTwoData.dependence ? '1' : '0';\r\n\r\n    rankingOrderDesc.forEach((key) => {\r\n      if (nodeOneData[key] > nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    rankingOrderAsc.forEach((key) => {\r\n      if (nodeOneData[key] < nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    return parseInt(rankTwo) - parseInt(rankOne);\r\n  };\r\n\r\n  getMinIndexOfDependentNodeInRelationsList = (node: NodeType) => {\r\n    const indexArray = [];\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      indexArray.push(this.getIndexOfRelationInRelationsList(node.dependentNodes[i]));\r\n    }\r\n\r\n    return Math.min(...indexArray);\r\n  };\r\n\r\n  getIndexOfRelationInRelationsList = (relation: any): number => {\r\n    const list = this.data.getRelationsResult.shapes.concat(this.data.getRelationsResult.relations);\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (relation === list[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getDependentStaticNodeCount = (node: NodeType): number => {\r\n    let count = 0;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (this.isStaticNodeById(node.dependentNodes[i].id)) count++;\r\n    }\r\n\r\n    return count;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMap = (node): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (node === this.data.getPointsMap[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMapById = (id: string): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getNodeInPointsMapById = (id: string): NodeType | null => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return this.data.getPointsMap[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  isStaticNodeById = (id: string): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) {\r\n        return this.isStaticNode(this.data.getPointsMap[i]);\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  _calculateSet = (equations: Array<EquationType>) => {\r\n    if (equations.length === 2) {\r\n      return calculateIntersectionTwoCircleEquations(equations[0], equations[1]);\r\n    } else return NOT_ENOUGH_SET;\r\n  };\r\n\r\n  replaceSetOfEquation(pointId: string, searchEquation: EquationType, replaceEquation: EquationType) {\r\n    const pointDetail = this.data.getPointDetails.get(pointId);\r\n    const setOfEquation = pointDetail.setOfEquation;\r\n    let isReplaceComplete = false;\r\n    setOfEquation.forEach((equation: EquationType, index: numer) => {\r\n      if (isTwoEquationEqual(equation, searchEquation)) {\r\n        setOfEquation[index] = replaceEquation;\r\n        isReplaceComplete = true;\r\n      }\r\n    });\r\n    if (!isReplaceComplete) {\r\n      setOfEquation.push(replaceEquation);\r\n    }\r\n    if (setOfEquation.length === 1) {\r\n      return;\r\n    }\r\n    const roots = this._calculateSet(setOfEquation);\r\n\r\n    this.data.getPointDetails.set(pointId, {\r\n      ...pointDetail,\r\n      setOfEquation,\r\n      roots\r\n    });\r\n\r\n    if (roots.length > 0) {\r\n      let coordinate;\r\n      if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n        coordinate = roots[getRandomValue(0, roots.length)];\r\n      } else {\r\n        const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n        const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n        if (roots.length > 1 && typeof roots !== 'string') {\r\n          const rootsDirection = roots.map((root) => ({\r\n            coordinate: root,\r\n            isRight: root.x > staticPointCoordinate.x,\r\n            isUp: root.y < staticPointCoordinate.y\r\n          }));\r\n\r\n          const coordinateMatch = rootsDirection\r\n            .map((directionInfo) => {\r\n              let matchCount = 0;\r\n              if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                matchCount++;\r\n              }\r\n              if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                matchCount++;\r\n              }\r\n              return {\r\n                coordinate: directionInfo.coordinate,\r\n                matchCount\r\n              };\r\n            })\r\n            .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n          coordinate = coordinateMatch.coordinate;\r\n        } else {\r\n          if (typeof roots === 'string') {\r\n            return;\r\n          }\r\n          coordinate = roots[0];\r\n        }\r\n      }\r\n      dataViewModel.updateCoordinate(pointId, coordinate);\r\n    }\r\n  }\r\n\r\n  _updatePointDetails(pointId: string, pointDetails: PointDetailsType) {\r\n    this.data.getPointDetails.set(pointId, {\r\n      setOfEquation: pointDetails.setOfEquation,\r\n      roots: pointDetails.roots,\r\n      exceptedCoordinates: pointDetails.exceptedCoordinates\r\n    });\r\n  }\r\n\r\n  uniqueSetOfEquation(equations: any[]): any[] {\r\n    let result = [];\r\n\r\n    equations.forEach((equation) => {\r\n      for (let i = 0; i < result.length; i++) {\r\n        if (JSON.stringify(equation) === JSON.stringify(result[i])) return;\r\n      }\r\n      result.push(equation);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  executePointDetails(pointId: string, equation: EquationType) {\r\n    let isFirst = false;\r\n    if (!this.data.getPointDetails.has(pointId)) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [],\r\n        roots: [],\r\n        exceptedCoordinates: []\r\n      });\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length <= 1) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [...this.data.getPointDetails.get(pointId).setOfEquation, equation],\r\n        roots: this.data.getPointDetails.get(pointId).roots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n      isFirst = true;\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length === 2) {\r\n      if (isQuadraticEquation(equation) && !isFirst) {\r\n        for (let i = 0; i < 2; i++) {\r\n          if (!isQuadraticEquation(this.data.getPointDetails.get(pointId).setOfEquation[i])) {\r\n            this.data.getPointDetails.get(pointId).setOfEquation[i] = equation;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const roots = this._calculateSet(this.data.getPointDetails.get(pointId).setOfEquation);\r\n      const currentRoots = this.data.getPointDetails.get(pointId).roots;\r\n\r\n      const finalRoots = typeof roots === 'string' ? currentRoots : currentRoots.concat(roots);\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: finalRoots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n    }\r\n\r\n    let temp = this.data.getPointDetails.get(pointId).roots;\r\n\r\n    if (typeof temp === 'string') {\r\n      ErrorService.showError('500');\r\n      return;\r\n    }\r\n\r\n    temp = temp.filter((root) => {\r\n      return isIn(root, equation);\r\n    });\r\n\r\n    if (temp.length > 0) {\r\n      // TODO: Add exception\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: temp,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n\r\n      if (temp.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n          coordinate = temp[getRandomValue(0, temp.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (temp.length > 1) {\r\n            const rootsDirection = temp.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = temp[0];\r\n          }\r\n        }\r\n        console.log(coordinate);\r\n        dataViewModel.updateCoordinate(pointId, coordinate);\r\n      }\r\n    }\r\n  }\r\n\r\n  getInformation(string: string): mixed {\r\n    const _string = '_ '.concat(string.concat(' _'));\r\n    let isMatching = false;\r\n    let preProgress = [];\r\n    Object.keys(defineSentences).forEach((key) => {\r\n      defineSentences[key].forEach((sentence) => {\r\n        sentence = '_ '.concat(sentence.concat(' _'));\r\n\r\n        if (isMatching) return;\r\n        const value = this.getBasicInformation(_string, sentence, key);\r\n        if (Object.keys(value).length > 0) {\r\n          isMatching = true;\r\n          preProgress = value;\r\n          preProgress['outputType'] = key;\r\n        }\r\n      });\r\n    });\r\n    const type = preProgress.outputType;\r\n\r\n    const result = defineInformation(preProgress);\r\n    if (result.Error || !result.outputType) {\r\n      ErrorService.showError('300');\r\n      return;\r\n    }\r\n    if (result.point && result.point.length > 3) {\r\n      ErrorService.showError('301');\r\n      return;\r\n    }\r\n\r\n    // add operation for define type\r\n    if (type === 'define') {\r\n      GConst.Others.OPERATIONS.forEach((operation) => {\r\n        if (result.operation) return;\r\n        if (string.includes(operation)) {\r\n          result.operation = operation;\r\n          if (operation === '=' && !result.value) {\r\n            result.value = '1';\r\n            result.operation = '*';\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getBasicInformation(string, _defineSentence, type) {\r\n    let others = _defineSentence.match(new RegExp(GConst.Regex.OTHER, 'g'));\r\n    let params = _defineSentence.match(new RegExp(GConst.Regex.KEY, 'g'));\r\n\r\n    let result = {};\r\n\r\n    params.forEach((key) => {\r\n      result[key] = [];\r\n    });\r\n\r\n    for (let i = 0; i < params.length; i++) {\r\n      let start =\r\n        others[i]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n      let end =\r\n        others[i + 1]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n\r\n      let param = string.match(new RegExp(start + '(.*)' + end));\r\n\r\n      if (param) result[params[i]].push(param[1]);\r\n\r\n      if (i === others.length - 1) {\r\n        let lastParam = string.match(new RegExp(end + '(.*)'));\r\n        if (lastParam) result[params[i + 1]].push(lastParam[1]);\r\n      }\r\n    }\r\n\r\n    if (this.getLength(result) === params.length) {\r\n      if (type === 'relation') result[type] = others[1].replace('_', '').trim();\r\n      return result;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  getLength(dictionary) {\r\n    let count = 0;\r\n    Object.keys(dictionary).forEach((key) => {\r\n      count += dictionary[key].length;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  getCircleEquation(centerId: string): EquationType {\r\n    return this.circlesData[centerId].equation;\r\n  }\r\n\r\n  getCircleCenterCoordinate(centerId: string): CoordinateType {\r\n    return this.circlesData[centerId].coordinate;\r\n  }\r\n\r\n  isCoordinateDuplicated(coordinate: CoordinateType): boolean {\r\n    const stringifyCoordinate = JSON.stringify(coordinate);\r\n    let result = false;\r\n    this.getData.pointsMap.forEach((node: NodeType) => {\r\n      const key = node.id;\r\n      if (result) {\r\n        return;\r\n      }\r\n      if (JSON.stringify(stringifyCoordinate) === JSON.stringify(this.getNodeInPointsMapById(key).coordinate)) {\r\n        result = true;\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  analyzeInput() {\r\n    this.circlesData = {};\r\n    const data = this.RelationsInput.map((relationsInput: RelationInputModel): string => relationsInput.value)\r\n      // eslint-disable-next-line no-control-getBasicInformation\r\n      .filter((sentence) => !!sentence)\r\n      .map((sentence: string, index: number) => {\r\n        this.executedInputIndex = index;\r\n        const result = this.getInformation(sentence);\r\n        this.relationsInput[index].status = GConst.InputStatus.SUCCESS;\r\n        this.inputData.push(result);\r\n        return result;\r\n      });\r\n\r\n    let result = {\r\n      shapes: [],\r\n      relations: []\r\n    };\r\n    for (let i = 0; i < data.length; i++) {\r\n      let item = data[i];\r\n\r\n      if (item.outputType === 'shape') {\r\n        result.shapes.push(item);\r\n      } else {\r\n        result.relations.push(item);\r\n      }\r\n    }\r\n\r\n    this.data.setRelationsResult = result;\r\n\r\n    this.RelationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.SUCCESS;\r\n    });\r\n    return analyzeResult(result);\r\n  }\r\n}\r\n\r\nconst dataViewModel = new DataViewModel(appData);\r\n\r\nexport default dataViewModel;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport './InputItem.scss';\r\nimport { Icon } from '../index';\r\nimport color from '../../../utils/color.scss';\r\nimport autobind from 'autobind-decorator';\r\ntype PropsType = {\r\n  value: string,\r\n  status: string,\r\n  onValueChange: void,\r\n  onSubmit: void,\r\n  onBackspace: void\r\n};\r\n\r\ntype StateType = {\r\n  shouldRemove: boolean\r\n};\r\n\r\nconst KEYCODE = Object.freeze({\r\n  BACKSPACE: 8,\r\n  ENTER: 13\r\n});\r\n\r\nclass InputItem extends React.Component<PropsType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    this.state = {\r\n      shouldRemove: true,\r\n      isEmpty: true\r\n    };\r\n  }\r\n  inputRef: ReactRefs = React.createRef();\r\n\r\n  focus() {\r\n    if (this.inputRef.current) {\r\n      this.inputRef.current.focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onChange(e: React.FormEvent<HTMLInputElement>) {\r\n    const value = e.currentTarget.value;\r\n    const { onValueChange } = this.props;\r\n\r\n    if (value.length === 0) {\r\n      if (!this.state.isEmpty) {\r\n        this.setState({ isEmpty: true });\r\n      }\r\n    } else {\r\n      this.setState({\r\n        isEmpty: false,\r\n        shouldRemove: false\r\n      });\r\n    }\r\n    if (onValueChange) {\r\n      onValueChange(value);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onKeyUp(e: React.KeyboardEvent<FormControl>) {\r\n    const { onBackspace, onSubmit, value } = this.props;\r\n\r\n    if (e.keyCode === KEYCODE.ENTER) {\r\n      if (onSubmit) {\r\n        onSubmit();\r\n      }\r\n    } else if (e.keyCode === KEYCODE.BACKSPACE) {\r\n      if (this.state.isEmpty && !this.state.shouldRemove) {\r\n        this.setState({\r\n          shouldRemove: true\r\n        });\r\n        return;\r\n      }\r\n      if (onBackspace) {\r\n        onBackspace();\r\n      }\r\n    }\r\n  }\r\n\r\n  render(): React.Node {\r\n    const { status, value } = this.props;\r\n    return (\r\n      <div className=\"input-item\">\r\n        <div className=\"input-group input-container\">\r\n          <div className=\"input-group-prepend input-status\">\r\n            <span className={`input-group-text ${status.toLowerCase()}`} id=\"basic-addon1\">\r\n              <Icon width={15} height={15} name={`input${status}`} color={color[`input${status}`]} />\r\n            </span>\r\n          </div>\r\n          <input\r\n            type=\"text\"\r\n            ref={this.inputRef}\r\n            onChange={this.onChange}\r\n            onKeyUp={this.onKeyUp}\r\n            value={value}\r\n            className={`form-control ${status.toLowerCase()}`}\r\n            aria-describedby=\"basic-addon1\"\r\n          />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default InputItem;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport { inputSuccess, inputError, inputNormal, icInformation, icRemove, icEdit, icAdd } from './Svg';\r\n\r\ntype PropsType = {\r\n  name: string,\r\n  color: string,\r\n  width: number,\r\n  height: number\r\n};\r\n\r\nconst iconList = {\r\n  inputSuccess,\r\n  inputError,\r\n  inputNormal,\r\n  icInformation,\r\n  icRemove,\r\n  icEdit,\r\n  icAdd\r\n};\r\n\r\nexport default class Icon extends React.Component<PropsType> {\r\n  render(): React.Node {\r\n    const { name, width, height, color } = this.props;\r\n    const icon = iconList[name];\r\n    return (\r\n      <svg width={width} height={height} viewBox={icon.viewBox}>\r\n        {icon.svg({ color })}\r\n      </svg>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\n\r\nexport const inputSuccess = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M337.222 22.952c-15.912-8.568-33.66 7.956-44.064 17.748-23.867 23.256-44.063 50.184-66.708 74.664-25.092 26.928-48.348 53.856-74.052 80.173-14.688 14.688-30.6 30.6-40.392 48.96-22.032-21.421-41.004-44.677-65.484-63.648C28.774 167.385-.602 157.593.01 190.029c1.224 42.229 38.556 87.517 66.096 116.28 11.628 12.24 26.928 25.092 44.676 25.704 21.42 1.224 43.452-24.48 56.304-38.556 22.645-24.48 41.005-52.021 61.812-77.112 26.928-33.048 54.468-65.485 80.784-99.145 16.524-20.808 68.544-72.217 27.54-94.248zM26.937 187.581c-.612 0-1.224 0-2.448.611-2.448-.611-4.284-1.224-6.732-2.448 1.836-1.224 4.896-.612 9.18 1.837z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const inputError = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M285.368 234.691L459.36 60.697c13.895-13.88 13.895-36.395 0-50.275-13.881-13.895-36.38-13.895-50.275 0L235.091 184.416 61.082 10.421c-13.866-13.895-36.395-13.895-50.275 0-13.88 13.881-13.88 36.395 0 50.275l174.01 173.995L10.421 409.085c-13.895 13.895-13.895 36.395 0 50.275 6.94 6.955 16.043 10.425 25.145 10.425 9.088 0 18.19-3.47 25.132-10.425L235.09 284.967l173.995 173.995c6.955 6.94 16.043 10.425 25.145 10.425 9.088 0 18.19-3.485 25.131-10.425 13.895-13.88 13.895-36.38 0-50.275L285.367 234.691z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 469.785 469.785'\r\n};\r\n\r\nexport const inputNormal = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M370.59 250.973c-5.524 0-10 4.476-10 10v88.789c-.02 16.562-13.438 29.984-30 30H50c-16.563-.016-29.98-13.438-30-30V89.172c.02-16.559 13.438-29.98 30-30h88.79c5.523 0 10-4.477 10-10 0-5.52-4.477-10-10-10H50c-27.602.031-49.969 22.398-50 50v260.594c.031 27.601 22.398 49.968 50 50h280.59c27.601-.032 49.969-22.399 50-50v-88.793c0-5.524-4.477-10-10-10zm0 0\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M376.629 13.441c-17.574-17.574-46.067-17.574-63.64 0L134.581 191.848a9.997 9.997 0 0 0-2.566 4.402l-23.461 84.7a9.997 9.997 0 0 0 12.304 12.308l84.7-23.465a9.997 9.997 0 0 0 4.402-2.566l178.402-178.41c17.547-17.587 17.547-46.055 0-63.641zM156.37 198.348L302.383 52.332l47.09 47.09-146.016 146.016zm-9.406 18.875l37.62 37.625-52.038 14.418zM374.223 74.676L363.617 85.28l-47.094-47.094 10.61-10.605c9.762-9.762 25.59-9.762 35.351 0l11.739 11.734c9.746 9.774 9.746 25.59 0 35.36zm0 0\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const icInformation = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M194 142.8c.8 1.6 1.6 3.2 2.4 4.4.8 1.2 2 2.4 2.8 3.6 1.2 1.2 2.4 2.4 4 3.6 1.2.8 2.8 2 4.8 2.4 1.6.8 3.2 1.2 5.2 1.6 2 .4 3.6.4 5.2.4s3.6 0 5.2-.4 3.2-.8 4.4-1.6h.4c1.6-.8 3.2-1.6 4.8-2.8 1.2-.8 2.4-2 3.6-3.2l.4-.4c1.2-1.2 2-2.4 2.8-3.6s1.6-2.4 2-4c0-.4 0-.4.4-.8.8-1.6 1.2-3.6 1.6-5.2.4-1.6.4-3.6.4-5.2s0-3.6-.4-5.2-.8-3.2-1.6-5.2c-1.2-2.8-2.8-5.2-4.8-7.2l-.8-.8c-1.2-1.2-2.4-2-4-3.2-1.6-.8-2.8-1.6-4.4-2.4-1.6-.8-3.2-1.2-4.8-1.6-2-.4-3.6-.4-5.2-.4s-3.6 0-5.2.4-3.2.8-4.8 1.6h-.4c-1.6.8-3.2 1.6-4.4 2.4-1.6 1.2-2.8 2-4 3.2-1.2 1.2-2.4 2.4-3.2 3.6-.8 1.2-1.6 2.8-2.4 4.4-.8 1.6-1.2 3.2-1.6 4.8-.4 2-.4 3.6-.4 5.2s0 3.6.4 5.2c.4 3.2 1.2 4.8 1.6 6.4zM249.6 289.2h-9.2v-98c0-5.6-4.4-10.4-10.4-10.4h-42c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h8.4v66.4H188c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h61.6c5.6 0 10.4-4.4 10.4-10.4V300c0-6-4.8-10.8-10.4-10.8z\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M218.8 0C98 0 0 98 0 218.8s98 218.8 218.8 218.8 218.8-98 218.8-218.8S339.6 0 218.8 0zm0 408.8c-104.8 0-190-85.2-190-190s85.2-190 190-190 190 85.2 190 190-85.2 190-190 190z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 437.6 427.6'\r\n};\r\n\r\nexport const icEdit = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M328.883 89.125l107.59 107.589-272.34 272.34L56.604 361.465l272.279-272.34zm189.23-25.948l-47.981-47.981c-18.543-18.543-48.653-18.543-67.259 0l-45.961 45.961 107.59 107.59 53.611-53.611c14.382-14.383 14.382-37.577 0-51.959zM.3 512.69c-1.958 8.812 5.998 16.708 14.811 14.565l119.891-29.069L27.473 390.597.3 512.69z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 528.899 528.899'\r\n};\r\n\r\nexport const icRemove = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M465.167 211.613H26.69c-8.424 0-26.69 11.439-26.69 34.316s18.267 34.316 26.69 34.316H465.169c8.421 0 26.689-11.439 26.689-34.316s-18.268-34.316-26.691-34.316z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 491.858 491.858'\r\n};\r\n\r\nexport const icAdd = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fillRule=\"evenodd\"\r\n        clipRule=\"evenodd\"\r\n        d=\"M34.525 19.11l.398.038a17.705 17.705 0 000-3.296l-.398.037-.398.038a16.903 16.903 0 010 3.146l.398.038zm-.333-5.342l.39-.087a17.364 17.364 0 00-1.017-3.133l-.367.16-.367.158c.413.954.74 1.953.97 2.989l.39-.087zm-1.97-4.974l.343-.203a17.556 17.556 0 00-1.938-2.664l-.3.265-.3.264a16.76 16.76 0 011.85 2.542l.344-.204zm-3.414-4.121l.265-.3a17.551 17.551 0 00-2.663-1.938l-.204.344-.204.344a16.755 16.755 0 012.542 1.85l.264-.3zm-4.515-2.87l.159-.368c-1-.433-2.047-.775-3.133-1.017l-.087.39-.087.39c1.036.231 2.035.558 2.989.971l.159-.367zM19.11.474l.037-.398a17.718 17.718 0 00-3.296 0l.037.398.038.398a16.919 16.919 0 013.146 0l.038-.398zm-5.343.333l-.087-.39a17.365 17.365 0 00-3.133 1.017l.16.367.158.367c.954-.413 1.953-.74 2.989-.97l-.087-.39zm-4.974 1.97l-.203-.343c-.95.562-1.841 1.212-2.664 1.938l.265.3.264.3a16.756 16.756 0 012.542-1.85l-.204-.344zM4.673 6.193l-.3-.265a17.556 17.556 0 00-1.938 2.664l.344.203.344.204a16.756 16.756 0 011.85-2.542l-.3-.264zm-2.87 4.515l-.368-.159c-.433 1-.775 2.047-1.017 3.133l.39.087.39.087c.231-1.036.558-2.036.971-2.989l-.367-.159zM0 17.5c0-.556.026-1.105.077-1.648l.398.037.398.038a16.919 16.919 0 000 3.146l-.398.038-.398.037A17.718 17.718 0 010 17.5zm.808 3.732l-.39.087a17.365 17.365 0 001.017 3.133l.367-.16.367-.158a16.565 16.565 0 01-.97-2.989l-.39.087zm1.97 4.974l-.343.204a17.55 17.55 0 001.938 2.663l.3-.265.3-.264a16.755 16.755 0 01-1.85-2.542l-.344.204zm3.414 4.121l-.265.3a17.556 17.556 0 002.664 1.938l.203-.344.204-.344a16.76 16.76 0 01-2.542-1.85l-.264.3zm4.515 2.87l-.159.368c1 .433 2.047.775 3.133 1.017l.087-.39.087-.39a16.563 16.563 0 01-2.989-.971l-.159.367zm5.182 1.328l-.037.398a17.705 17.705 0 003.296 0l-.037-.398-.038-.398a16.903 16.903 0 01-3.146 0l-.038.398zm5.343-.333l.087.39a17.364 17.364 0 003.133-1.017l-.16-.367-.158-.367c-.954.413-1.953.74-2.989.97l.087.39zm4.974-1.97l.204.343c.949-.562 1.84-1.212 2.663-1.938l-.265-.3-.264-.3a16.76 16.76 0 01-2.542 1.85l.204.344zm4.121-3.414l.3.265a17.552 17.552 0 001.938-2.663l-.344-.204-.344-.204a16.76 16.76 0 01-1.85 2.542l.3.264zm2.87-4.515l.368.159c.433-1 .775-2.047 1.017-3.133l-.39-.087-.39-.087a16.563 16.563 0 01-.971 2.989l.367.159zM17.7 9.723a.5.5 0 01.5.5V17h7a.5.5 0 010 1h-7v6.778a.5.5 0 01-1 0V18h-7a.5.5 0 010-1h7v-6.778a.5.5 0 01.5-.5z\"\r\n        fill={props.color || '#dcdcdc'}\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 35 35'\r\n};\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport Toggle from 'react-bootstrap-toggle';\r\nimport { Button, Dropdown, DropdownButton } from 'react-bootstrap';\r\nimport autobind from 'autobind-decorator';\r\nimport { Icon } from '../index';\r\nimport type { DrawingSegmentType } from '../../../utils/types';\r\nimport './SegmentSetting.scss';\r\n\r\ntype PropsType = {\r\n  value?: DrawingSegmentType,\r\n  data: Array<string>,\r\n  onDone: void,\r\n  onDelete: void,\r\n  onVisibleChange: void\r\n};\r\n\r\ntype StateType = {\r\n  start: string,\r\n  end: string,\r\n  visible: boolean,\r\n  isEditMode: boolean,\r\n  isCreateMode: boolean,\r\n  isMouseHoverEdition: boolean,\r\n  isMouseHoverDeletion: boolean,\r\n};\r\n\r\nclass SegmentSetting extends React.Component<PropsType, StateType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    const start = props.value ? props.value.name[0] : '';\r\n    const end = props.value ? props.value.name[1] : '';\r\n    this.state = {\r\n      start,\r\n      end,\r\n      visible: true,\r\n      isEditMode: !props.value,\r\n      isCreateMode: !props.value,\r\n      isMouseHoverEdition: false,\r\n      isMouseHoverDeletion: false,\r\n    };\r\n  }\r\n\r\n  @autobind\r\n  onDone() {\r\n    const {start, end} = this.state;\r\n    const {onDone} = this.props;\r\n\r\n    if (onDone) {\r\n      onDone({name: [start, end].sort().join(''), visible: true});\r\n    }\r\n    this.setState({isEditMode: false});\r\n  }\r\n\r\n  @autobind\r\n  onDelete() {\r\n    const {onDelete} = this.props;\r\n    if (onDelete) {\r\n      onDelete();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onVisibleChange(visible: boolean) {\r\n    const {onVisibleChange, value} = this.props;\r\n    if (onVisibleChange) {\r\n      onVisibleChange({name: value.name, visible: !value.visible});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  getIndexInData(dropdownIndex: string, filterValue: string): number {\r\n    const {data} = this.props;\r\n    const filterValueIndex = data.indexOf(filterValue);\r\n    if (filterValueIndex < 0) {\r\n      return dropdownIndex;\r\n    }\r\n    return filterValueIndex > dropdownIndex ? dropdownIndex : parseInt(dropdownIndex) + 1;\r\n  }\r\n\r\n  @autobind\r\n  onStartPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    const {start, end} = this.state;\r\n    const newStartValue = data[index];\r\n    if (newStartValue === end) {\r\n      this.setState({start: newStartValue, end: start});\r\n    } else {\r\n      this.setState({start: newStartValue});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onEndPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    this.setState({end: data[this.getIndexInData(index, this.state.start)]});\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverEdition() {\r\n    this.setState({isMouseHoverEdition: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveEdition() {\r\n    this.setState({isMouseHoverEdition: false})\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverDeletion() {\r\n    this.setState({isMouseHoverDeletion: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveDeletion() {\r\n    this.setState({isMouseHoverDeletion: false})\r\n  }\r\n\r\n  @autobind\r\n  onChangeContentState() {\r\n    const {isEditMode, start, end} = this.state;\r\n    if (!start || !end) {\r\n      return;\r\n    }\r\n    this.setState({isEditMode: !isEditMode});\r\n  }\r\n\r\n  @autobind\r\n  renderDropdown(value: string, data: Array<string>, onSelect: void): React.Node {\r\n    return (\r\n      <DropdownButton title={value || 'Chọn điểm'} id={`segment-dropdown`} onSelect={onSelect}>\r\n        {data.map((item: string, index: number): React.Node => (\r\n          <Dropdown.Item key={`Drop-item-${index}`} eventKey={`${index}`}>\r\n            {item}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderEditContent(): React.Node {\r\n    const {data} = this.props;\r\n    const {start, end, isCreateMode} = this.state;\r\n    return (\r\n      <div className=\"content-edit\">\r\n        <div className=\"drop-down-container\">\r\n          <div className={\"col-6 p-0\"}>\r\n            {this.renderDropdown(start, data, this.onStartPointSelect)}\r\n          </div>\r\n          <div className=\"col-6 p-0 right-drop-down\">\r\n            {this.renderDropdown(end, data.filter((item) => item !== this.state.start), this.onEndPointSelect)}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"button-container mt-1\">\r\n          <div className={\"col-6 p-0 d-flex justify-content-between\"}>\r\n            <Button className={\"btn-cancel\"} onClick={isCreateMode ? this.onDelete : this.onChangeContentState}>\r\n              HỦY\r\n            </Button>\r\n            <Button className={\"btn-update\"} variant={`${isCreateMode ? 'link' : 'success'}`} disabled={!(start && end)}\r\n                    onClick={this.onDone}>\r\n              {isCreateMode ? 'THÊM' : 'CẬP NHẬT'}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderShowContent(): React.Node {\r\n    const {\r\n      value: {name, visible}\r\n    } = this.props;\r\n    return (\r\n      <div className=\"content-show\">\r\n        <div className=\"content\">\r\n          <div className={\"segment-edit-name col-8\"}>\r\n            <p>{name}</p>\r\n          </div>\r\n\r\n          <div className={\"segment-edit-controller col-4\"}>\r\n            <Toggle\r\n              onstyle=\"success\"\r\n              offstyle=\"danger\"\r\n              handleClassName=\"toggle-handler\"\r\n              onClick={this.onVisibleChange}\r\n              off=\"HIỆN\"\r\n              on=\"ẨN\"\r\n              active={visible}\r\n            />\r\n\r\n            <div onClick={this.onChangeContentState}\r\n                 onMouseLeave={this.mouseLeaveEdition}\r\n                 onMouseOver={this.mouseHoverEdition}\r\n                 onMouseDown={this.mouseLeaveEdition}>\r\n              {\r\n                this.state.isMouseHoverEdition ?\r\n                  <Icon name={'icEdit'} color={'#218838'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icEdit'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n\r\n            <div onClick={this.onDelete}\r\n                 onMouseOver={this.mouseHoverDeletion}\r\n                 onMouseLeave={this.mouseLeaveDeletion}\r\n                 onMouseDown={this.mouseLeaveDeletion}>\r\n              {\r\n                this.state.isMouseHoverDeletion ?\r\n                  <Icon name={'icRemove'} color={'#dc3545'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icRemove'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderContent(): React.Node {\r\n    const {isEditMode} = this.state;\r\n    if (isEditMode) {\r\n      return this.renderEditContent();\r\n    }\r\n\r\n    return this.renderShowContent();\r\n  }\r\n\r\n  render(): React.Node {\r\n    const {style} = this.props;\r\n    const {isEditMode, isCreateMode} = this.state;\r\n\r\n    return (\r\n      <div className=\"segment-setting\" style={{...style}}>\r\n        <div className=\"container\">\r\n          {isEditMode && (\r\n            <div className=\"title\">\r\n              <p>{`${isCreateMode ? 'Thêm' : 'Cập nhật'} đoạn thẳng :`}</p>\r\n            </div>\r\n          )}\r\n          {this.renderContent()}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SegmentSetting;\r\n","class Geom {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  toString() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nexport { Geom };\r\n","import { Geom } from './geom';\r\n\r\nclass Point extends Geom {\r\n  constructor(name, x, y) {\r\n    if (typeof y === 'undefined') {\r\n      y = x;\r\n      x = name;\r\n      name = null;\r\n    }\r\n    super(name);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.free = true;\r\n  }\r\n\r\n  toString() {\r\n    return super.toString() + '(' + this.x + ',' + this.y + ')';\r\n  }\r\n\r\n  /* shorthand function for constructing a point from coodinates */\r\n  static P(name, x, y) {\r\n    return new Point(name, x, y);\r\n  }\r\n}\r\n\r\nexport { Point };\r\n","export { distance, distanceSquared };\r\n\r\n/* returns the Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distance(p1, p2) {\r\n  return Math.sqrt(distanceSquared(p1, p2));\r\n}\r\n\r\n/* returns the squared Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distanceSquared(p1, p2) {\r\n  let dx = p1.x - p2.x,\r\n    dy = p1.y - p2.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n","import { Geom } from './geom';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nclass Circle extends Geom {\r\n  constructor(name, center, a) {\r\n    if (typeof a === 'undefined') {\r\n      a = center;\r\n      center = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    this.center = center;\r\n    if (a instanceof Point) {\r\n      this._fromCenterAndBoundaryPoint(center, a);\r\n    } else if (typeof a === 'number') {\r\n      this._fromCenterAndRadius(center, a);\r\n    }\r\n  }\r\n\r\n  _fromCenterAndRadius(center, radius) {\r\n    this.radius = radius;\r\n    Object.defineProperties(this, {\r\n      radiussq: {\r\n        get() {\r\n          return this.radius * this.radius;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _fromCenterAndBoundaryPoint(center, boundaryPoint) {\r\n    this.boundaryPoint = boundaryPoint;\r\n    Object.defineProperties(this, {\r\n      radius: {\r\n        get() {\r\n          return distance(this.boundaryPoint, this.center);\r\n        }\r\n      },\r\n      radiussq: {\r\n        get() {\r\n          return distanceSquared(this.boundaryPoint, this.center);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    var w = Math.abs(x - this.center.x);\r\n    if (w > this.radius) return null;\r\n    if (w === this.radius) return new Point(x, this.center.y);\r\n\r\n    var h = Math.sqrt(this.radius * this.radius - w * w);\r\n    return [this.center.y + h, this.center.y - h];\r\n  }\r\n\r\n  contains(p) {\r\n    return distanceSquared(p, this.center) === this.radiussq;\r\n  }\r\n\r\n  toString() {\r\n    return 'Circle' + super.toString() + '[' + this.center.toString() + ';' + this.radius + ']';\r\n  }\r\n}\r\n\r\nexport { Circle };\r\n","import { Geom } from './geom';\r\n\r\nclass Line extends Geom {\r\n  constructor(name, p1, p2) {\r\n    if (typeof p2 === 'undefined') {\r\n      p2 = p1;\r\n      p1 = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    if (!p2) {\r\n      this._p = p1.slice(0);\r\n    } else {\r\n      this._p = [p1, p2];\r\n    }\r\n\r\n    this._clip = false;\r\n\r\n    Object.defineProperties(this, {\r\n      // TODO: I don't like dx and dy on the line class...\r\n      dx: {\r\n        get() {\r\n          return this._p[1].x - this._p[0].x;\r\n        }\r\n      },\r\n      dy: {\r\n        get() {\r\n          return this._p[1].y - this._p[0].y;\r\n        }\r\n      },\r\n      theta: {\r\n        get() {\r\n          return Math.atan2(this.dy, this.dx);\r\n        }\r\n      },\r\n      m: {\r\n        get() {\r\n          if (this.dx === 0) return null;\r\n          else return this.dy / this.dx;\r\n        }\r\n      },\r\n\r\n      left: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      right: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      top: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      },\r\n      bottom: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    if (this.dx === 0 || (this._clip && (this.left > x || this.right < x))) return null;\r\n    else return this._p[0].y + ((x - this._p[0].x) * this.dy) / this.dx;\r\n  }\r\n\r\n  x(y) {\r\n    if (this.dy === 0 || (this._clip && (this.top > y || this.bottom < y))) return null;\r\n    else return this._p[0].x + ((y - this._p[0].y) * this.dx) / this.dy;\r\n  }\r\n\r\n  contains(p) {\r\n    let onLine = this.dx !== 0 ? this.y(p.x) === p.y : this.x(p.y) === p.x;\r\n    return (\r\n      onLine && (!this._clip || (this.left <= p.x && p.x <= this.right && (this.top <= p.y && p.y <= this.bottom)))\r\n    );\r\n  }\r\n\r\n  toString() {\r\n    return 'Line' + super.toString() + '[' + this._p[0].toString() + ';' + this._p[1].toString() + ']';\r\n  }\r\n}\r\n\r\nexport { Line };\r\n","import { Line } from './line';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nconst P = Point.P;\r\n\r\nclass Segment extends Line {\r\n  constructor(name, p1, p2) {\r\n    super(name, p1, p2);\r\n    this._clip = true;\r\n\r\n    Object.defineProperties(this, {\r\n      p: {\r\n        // TODO: clone point themselves?\r\n        get() {\r\n          return [].concat(this._p);\r\n        }\r\n      },\r\n\r\n      lengthsq: {\r\n        get() {\r\n          return distanceSquared(this._p[0], this._p[1]);\r\n        }\r\n      },\r\n\r\n      length: {\r\n        get() {\r\n          return distance(this._p[0], this._p[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  toString() {\r\n    return 'Segment' + super.toString();\r\n  }\r\n\r\n  /*\r\n  clip the given line (or line segment) to the given bounding box, where `bounds`\r\n  must have `left`, `right`, `top`, and `bottom` properties.\r\n  */\r\n  static clip(bounds, line) {\r\n    var [p1, p2] = line._p;\r\n\r\n    var left = line.y(bounds.left),\r\n      right = line.y(bounds.right),\r\n      top = line.x(bounds.top),\r\n      bottom = line.x(bounds.bottom);\r\n\r\n    if (p1.x > p2.x) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (left && left >= bounds.top && left <= bounds.bottom) {\r\n      // intersects left wall\r\n      p1 = P(bounds.left, left);\r\n    }\r\n    if (right && right >= bounds.top && right <= bounds.bottom) {\r\n      // intersects right wall\r\n      p2 = P(bounds.right, right);\r\n    }\r\n\r\n    if (p1.y > p2.y) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (top && top >= bounds.left && top <= bounds.right) {\r\n      // intersects top wall\r\n      p1 = P(top, bounds.top);\r\n    }\r\n    if (bottom && bottom >= bounds.left && bottom <= bounds.right) {\r\n      // intersects bottom wall\r\n      p2 = P(bottom, bounds.bottom);\r\n    }\r\n\r\n    let clipped = new Segment(null, p1, p2);\r\n    clipped.parent = line;\r\n    return clipped;\r\n  }\r\n}\r\n\r\nexport { Segment };\r\n","import { Point } from './model/point';\r\nimport { Line } from './model/line';\r\nimport { Segment } from './model/segment';\r\nimport { Circle } from './model/circle';\r\nimport { distanceSquared as dd } from './calc';\r\n\r\nimport uniq from 'uniq';\r\n\r\nlet P = Point.P;\r\n\r\n/* helpers */\r\nfunction comparePoints(p, q) {\r\n  return p.x === q.x && p.y === q.y ? 0 : 1;\r\n}\r\n\r\nfunction sq(a) {\r\n  return a * a;\r\n}\r\n\r\nfunction between(x, a, b) {\r\n  let left = Math.min(a, b),\r\n    right = Math.max(a, b);\r\n  return left <= x && x <= right;\r\n}\r\n\r\n/*\r\n  Intersection of two objects; returns an array, possibly empty, of \r\n  intersection points.\r\n*/\r\n\r\n/**\r\n * intersect - Find the intersection(s) of the given two objects.\r\n *\r\n * @param  {Geom} o1 first object\r\n * @param  {Geom} o2 second object\r\n * @return {Array.<Point>}    Points of intersection between the two objects.\r\n */\r\nfunction intersect(o1, o2) {\r\n  if (o1 instanceof Circle && o2 instanceof Circle)\r\n    // circle-circle\r\n    return intersectCircleCircle(o1, o2);\r\n  // if only one is a circle, it should be first.\r\n  else if (o2 instanceof Circle) return intersect(o2, o1);\r\n  else if (o1 instanceof Circle && o2 instanceof Segment)\r\n    // circle-segment\r\n    return intersectCircleLine(o1, o2, true);\r\n  else if (o1 instanceof Circle && o2 instanceof Line)\r\n    // circle-line\r\n    return intersectCircleLine(o1, o2, false);\r\n  else if (o1 instanceof Segment && o2 instanceof Segment)\r\n    // segment-segment\r\n    return intersectLineLine(o1, o2, true);\r\n  // if only one is a segment, it should be first.\r\n  else if (o2 instanceof Segment) return intersect(o2, o1);\r\n  else if (o1 instanceof Line && o2 instanceof Line)\r\n    // line-line\r\n    return intersectLineLine(o1, o2, false);\r\n  // TODO: circle-point, segment-point, point-point\r\n  else if (o2 instanceof Point || o1 instanceof Point) return [];\r\n  else throw new Error('Cannot intersect ' + o1.constructor.name + ' and ' + o2.constructor.name);\r\n}\r\n\r\nfunction intersectCircleCircle(c1, c2) {\r\n  let dsq = dd(c1.center, c2.center);\r\n  let d = Math.sqrt(dsq);\r\n\r\n  if (d > c1.radius + c2.radius) {\r\n    return [];\r\n  } else if (d < c1.radius - c2.radius) {\r\n    return [];\r\n  } else if (dsq === 0) {\r\n    return [];\r\n  }\r\n\r\n  let a = (c1.radiussq - c2.radiussq + dsq) / (2 * d);\r\n  let h = Math.sqrt(Math.max(c1.radiussq - sq(a), 0));\r\n  let cx = c1.center.x + (a * (c2.center.x - c1.center.x)) / d;\r\n  let cy = c1.center.y + (a * (c2.center.y - c1.center.y)) / d;\r\n\r\n  let nx = (h * (c1.center.y - c2.center.y)) / d;\r\n  let ny = (h * (c1.center.x - c2.center.x)) / d;\r\n\r\n  return uniq([P(0, cx + nx, cy - ny), P(1, cx - nx, cy + ny)], comparePoints);\r\n}\r\n\r\nfunction intersectLineLine(s1, s2, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s1._p;\r\n  let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = s2._p;\r\n  let s = (-s1.dy * (x1 - x3) + s1.dx * (y1 - y3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n  let t = (s2.dx * (y1 - y3) - s2.dy * (x1 - x3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n\r\n  if (!clip || (between(s, 0, 1) && between(t, 0, 1))) return [P(0, x1 + t * s1.dx, y1 + t * s1.dy)];\r\n  else return []; // no collision\r\n}\r\n\r\n/* http://mathworld.wolfram.com/Circle-LineIntersection.html */\r\nfunction intersectCircleLine(c, s, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s._p;\r\n  let { x: x0, y: y0 } = c.center;\r\n\r\n  // note the translation (x0, y0)->(0,0).\r\n  let D = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0);\r\n  let Dsq = sq(D);\r\n\r\n  let lensq = sq(s.dx) + sq(s.dy);\r\n  let disc = Math.sqrt(sq(c.radius) * lensq - Dsq);\r\n  if (disc < 0) {\r\n    return [];\r\n  }\r\n\r\n  let cx = (D * s.dy) / lensq,\r\n    cy = (-D * s.dx) / lensq;\r\n  let nx = ((s.dy < 0 ? -1 * s.dx : s.dx) * disc) / lensq,\r\n    ny = (Math.abs(s.dy) * disc) / lensq;\r\n\r\n  // translate (0,0)->(x0, y0).\r\n  return uniq([P(0, cx + nx + x0, cy + ny + y0), P(1, cx - nx + x0, cy - ny + y0)], comparePoints).filter((p) =>\r\n    clip ? between(p.x, x1, x2) && between(p.y, y1, y2) : true\r\n  );\r\n}\r\n\r\nexport { intersect, intersectCircleCircle, intersectCircleLine, intersectLineLine };\r\n","import { Point } from './point';\r\nimport { Geom } from './geom';\r\n\r\nimport { intersect } from '../intersection';\r\n\r\nclass Intersection extends Point {\r\n  /**\r\n   * @param {string} name\r\n   * @param {...Geom} objects to be intersected\r\n   * @param {number|Geom~boolean} [which] optional array index or filter callback in case there are multiple intersections.\r\n   */\r\n  constructor(name, ...objects) {\r\n    if (name instanceof Geom) {\r\n      objects.shift(name);\r\n      name = null;\r\n    }\r\n    super(name, null, null);\r\n\r\n    this.which = /function|number/.test(typeof objects[objects.length - 1]) ? objects.pop() : 0;\r\n    this.objects = objects;\r\n    this.free = false;\r\n  }\r\n\r\n  update() {\r\n    let result = intersect.apply(null, this.objects);\r\n    if (typeof this.which === 'function') result = result.filter(this.which)[0];\r\n    else result = result[this.which];\r\n\r\n    if (result) {\r\n      ({ x: this.x, y: this.y } = result);\r\n    } else {\r\n      this.x = this.y = null;\r\n    }\r\n  }\r\n\r\n  toString(verbose) {\r\n    let pstr = super.toString();\r\n    return !verbose ? pstr : pstr + '; intersection of: ' + this.objects.map((o) => o.toString()).join(',');\r\n  }\r\n}\r\n\r\nexport { Intersection };\r\n","import { Point } from './point';\r\nimport { Circle } from './circle';\r\nimport { Line } from './line';\r\nimport { Segment } from './segment';\r\nimport { Intersection } from './intersection';\r\n\r\nconst P = Point.P;\r\nexport { P, Point, Circle, Segment, Line, Intersection };\r\n\r\n/* return a deep-equality test function that checks for geometric object\r\n   equality using the given distance threshold for point equality; i.e., if \r\n   two points are closer than `threshold`, consider them equal. */\r\nexport function equalWithin(threshold) {\r\n  threshold = threshold || 0;\r\n  return function equal(o1, o2) {\r\n    if (Array.isArray(o1) && Array.isArray(o2)) {\r\n      return o1.every((obj, index) => equal(obj, o2[index]));\r\n    }\r\n    if (typeof o1 === 'number' && typeof o2 === 'number') {\r\n      return Math.abs(o1 - o2) < threshold;\r\n    }\r\n    if (o1 instanceof Point && o2 instanceof Point) {\r\n      if (o1.x === null || o2.x === null || o1.y === null || o2.y === null) return false;\r\n      else return equal(Math.abs(o1.x - o2.x) + Math.abs(o1.y - o2.y), 0);\r\n    }\r\n    if (o1 instanceof Circle && o2 instanceof Circle) {\r\n      return equal(o1.radius, o2.radius) && equal(o1.center, o2.center);\r\n    }\r\n    if (o1 instanceof Segment && o2 instanceof Segment) {\r\n      var p1 = [].concat(o1.p),\r\n        p2 = [].concat(o2.p);\r\n      // ensure points from both segments are in the same order\r\n      // (left to right or right to left).\r\n      if (p1[0].x > p1[1].x && p2[0].x < p2[0].x) p1.reverse();\r\n      // then delegate to point equality\r\n      return equal(p1, p2);\r\n    }\r\n    if (o1 instanceof Line && o2 instanceof Line) {\r\n      return equal(o1.m, o2.m) && equal(o1.y(0), o2.y(0)) && equal(o1.x(0), o2.x(0));\r\n    }\r\n\r\n    // fallback to object equality\r\n    return o1 === o2;\r\n  };\r\n}\r\n","import * as d3 from 'd3';\r\nimport { Circle, equalWithin, Intersection, Line, Point, Segment } from './model';\r\n\r\nfunction addClass(obj, klass) {\r\n  obj.classes = obj.classes || d3.set();\r\n  obj.classes.add(klass);\r\n}\r\n\r\nclass Scene {\r\n  constructor(bounds) {\r\n    this.bounds = bounds;\r\n    this.bounds.width = this.bounds.right - this.bounds.left;\r\n    this.bounds.height = this.bounds.bottom - this.bounds.top;\r\n\r\n    this._last = null; // hack -- should be keeping objects in ordered structure anyway.\r\n    this._objects = d3.map();\r\n    this.equal = equalWithin(Math.sqrt(2));\r\n    this.log = [];\r\n  }\r\n\r\n  /* return an array of all Points in the scene */\r\n  points() {\r\n    return this._objects.values().filter((o) => o instanceof Point);\r\n  }\r\n\r\n  /* return an array of all objects in the scene */\r\n  objects() {\r\n    return this._objects.values();\r\n  }\r\n\r\n  /* find the given object is in the scene using geometric\r\n  (i.e. deep) equality rather than reference ===. */\r\n  find(obj) {\r\n    let objects = this._objects.values();\r\n    for (let i = 0; i < objects.length; i++) {\r\n      if (this.equal(objects[i], obj)) return objects[i];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * is - Get an equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is geometrically equal to obj.\r\n   */\r\n  is(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && this.equal(obj, secondObj);\r\n  }\r\n\r\n  /**\r\n   * is - Get an NON-equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is NOT geometrically equal to obj.\r\n   */\r\n  isnt(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && !this.equal(obj, secondObj);\r\n  }\r\n\r\n  last() {\r\n    return this._last;\r\n  }\r\n\r\n  get(name) {\r\n    return this._objects.get(name);\r\n  }\r\n\r\n  point(name, x, y) {\r\n    return this.add(new Point(name, x, y));\r\n  }\r\n\r\n  circle(name, centerId, radius) {\r\n    return this.add(new Circle(name, this.get(centerId), radius));\r\n  }\r\n\r\n  segment(name, id1, id2) {\r\n    return this.add(new Segment(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  line(name, id1, id2) {\r\n    return this.add(new Line(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  intersection(name, id1, id2, which) {\r\n    if (typeof id2 === 'undefined') {\r\n      id2 = id1;\r\n      id1 = name;\r\n      name = null;\r\n    }\r\n\r\n    let o1 = this.get(id1),\r\n      o2 = this.get(id2);\r\n    if (!o1) throw new Error(\"Can't find object \" + id1);\r\n    if (!o2) throw new Error(\"Can't find object \" + id2);\r\n\r\n    return this.add(new Intersection(name, o1, o2, which));\r\n  }\r\n\r\n  group(tag) {\r\n    this._currentTag = tag;\r\n    return this;\r\n  }\r\n\r\n  add(object) {\r\n    // if we already have this object, and it's the same type, then update the\r\n    // existing one in place.\r\n    let existing = this._objects.get(object.name);\r\n    if (existing && existing.constructor.name === object.constructor.name) {\r\n      for (let prop in object) existing[prop] = object[prop];\r\n      object = existing;\r\n    }\r\n    // if an object of the same name but different type or an object that is\r\n    // geometrically equivalent already exists in the scene, do nothing.\r\n    else if (existing || (existing = this.find(object))) {\r\n      return this;\r\n    }\r\n    // add a new object to the scene.\r\n    else {\r\n      object.name = object.name || this.freeName();\r\n      this._objects.set(object.name, object);\r\n    }\r\n\r\n    if (this._currentTag) addClass(object, this._currentTag);\r\n    if (object.free) addClass(object, 'free-point');\r\n\r\n    this.update(object);\r\n\r\n    this._last = object;\r\n    return this;\r\n  }\r\n\r\n  freeName() {\r\n    let keys = this._objects.keys(),\r\n      id = 0;\r\n    for (; keys.indexOf('object' + id) >= 0; id++);\r\n    return 'object' + id;\r\n  }\r\n\r\n  /**\r\n   * update - Update objects to reflect changes in dependent objects. (E.g.,\r\n   * update Intersection coordinates when the intersected objects have changed.)\r\n   *\r\n   * @param {Geom} root The object from which to start walking the dependency graph.\r\n   */\r\n  // TODO: respect `root` parameter, and do an actual DAG walk.\r\n  update(root) {\r\n    this._objects\r\n      .values()\r\n      .filter((obj) => obj instanceof Intersection)\r\n      .forEach((obj) => obj.update());\r\n  }\r\n\r\n  logState(label) {\r\n    let self = this;\r\n    let objects = this._objects.values();\r\n    let points = this.points();\r\n\r\n    let state = {\r\n      label,\r\n      time: new Date().toString(),\r\n      objects: objects.map((o) => o.toString())\r\n    };\r\n    this.log.push(state);\r\n  }\r\n}\r\n\r\nexport { Scene };\r\n","import * as d3 from 'd3';\r\nimport { Circle, Line, Point, Segment } from './model';\r\n\r\nfunction klasses() {\r\n  let init = Array.prototype.slice.call(arguments, 0);\r\n  return (d) => init.concat(d.classes ? d.classes.values() : []).join(' ');\r\n}\r\n\r\nfunction renderGeometry(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* circles */\r\n  let circles = svg.selectAll('g.circle').data(scene.objects().filter((d) => d instanceof Circle));\r\n\r\n  let circleGroup = circles\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('circle'));\r\n  circleGroup.append('circle').attr('class', 'handle');\r\n  circleGroup.append('circle').attr('class', 'visible');\r\n\r\n  circles\r\n    .attr('class', klasses('circle'))\r\n    .selectAll('circle')\r\n    .attr('cx', (d) => d.center.x)\r\n    .attr('cy', (d) => d.center.y)\r\n    .attr('r', (d) => d.radius);\r\n\r\n  circles.exit().remove();\r\n\r\n  /* lines */\r\n  let lines = svg.selectAll('g.line').data(scene.objects().filter((d) => d instanceof Line));\r\n\r\n  let lineGroup = lines\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('line'));\r\n  lineGroup.filter((d) => d instanceof Segment).attr('class', klasses('line', 'segment'));\r\n  lineGroup.append('line').attr('class', 'handle');\r\n  lineGroup.append('line').attr('class', 'visible');\r\n\r\n  // TODO: this is grossly inefficient\r\n  function endpoint(index, coord) {\r\n    return (d) => {\r\n      let s = d instanceof Segment ? d : Segment.clip(scene.bounds, d);\r\n      return s.p[index][coord];\r\n    };\r\n  }\r\n\r\n  lines\r\n    .attr('class', klasses('line'))\r\n    .selectAll('line')\r\n    .attr('x1', endpoint(0, 'x'))\r\n    .attr('y1', endpoint(0, 'y'))\r\n    .attr('x2', endpoint(1, 'x'))\r\n    .attr('y2', endpoint(1, 'y'));\r\n\r\n  lines.exit().remove();\r\n}\r\n\r\nfunction renderPoints(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* points */\r\n  let points = svg.selectAll('circle.point').data(scene.objects().filter((d) => d instanceof Point));\r\n\r\n  points\r\n    .enter()\r\n    .append('circle')\r\n    .attr('class', klasses('point'))\r\n    .attr('cx', (d) => d.x)\r\n    .attr('cy', (d) => d.y)\r\n    .attr('r', (d) => 5);\r\n\r\n  points\r\n    .enter()\r\n    .append('text')\r\n    .attr('class', klasses('point-name'))\r\n    .attr('x', (d) => d.x + 10)\r\n    .attr('y', (d) => d.y - 15)\r\n    .attr('id', (d) => `point-${d.name}`);\r\n\r\n  points.enter()._groups[0].forEach((node) => {\r\n    const name = node.__data__.name;\r\n    document.getElementById(`point-${name}`).appendChild(document.createTextNode(name));\r\n  });\r\n\r\n  points.exit().remove();\r\n}\r\n\r\nexport { renderGeometry, renderPoints };\r\n","import * as React from 'react';\r\nimport { Scene } from '../../../vendor/euclid';\r\nimport { renderGeometry, renderPoints } from '../../../vendor/euclid/render';\r\nimport type { DrawingDataType } from '../../../utils/types';\r\nimport './DrawingPanel.scss';\r\ntype PropsType = {\r\n  drawingData: DrawingDataType\r\n};\r\n\r\nclass DrawingPanel extends React.Component<PropsType> {\r\n  componentDidMount() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  renderGeometry(drawingData: DrawingDataType) {\r\n    const svg = document.getElementById('geometry');\r\n\r\n    while (svg.firstChild) {\r\n      svg.firstChild.remove();\r\n    }\r\n    const pointElements = document.getElementById('points');\r\n    while (pointElements.firstChild) {\r\n      pointElements.firstChild.remove();\r\n    }\r\n\r\n    const { points, segments, circles } = drawingData;\r\n    const viewBox = svg.viewBox.baseVal;\r\n    const width = viewBox.width;\r\n    const height = viewBox.height;\r\n\r\n    const scene = new Scene({\r\n      left: viewBox.x,\r\n      top: viewBox.y,\r\n      right: viewBox.x + width,\r\n      bottom: viewBox.y + height\r\n    });\r\n\r\n    const arrX = [];\r\n    const arrY = [];\r\n    points.forEach((point) => {\r\n      arrX.push(point.coordinate.x);\r\n      arrY.push(point.coordinate.y);\r\n    });\r\n\r\n    const disparityX = Math.max(...arrX) - Math.min(...arrX);\r\n    const disparityY = Math.max(...arrY) - Math.min(...arrY);\r\n    let ratio = 0;\r\n    const ODD = 15;\r\n    if (disparityX / disparityY >= 1) {\r\n      // scale theo width\r\n      // giá trị ước lượng (ODD): nhằm tránh điểm render ngay cạnh của viewBox sẽ làm mất tên điểm\r\n      ratio = Math.floor(width / disparityX) - ODD;\r\n    } else {\r\n      ratio = Math.floor(height / disparityY) - ODD;\r\n    }\r\n\r\n    const anchorX = Math.min(...arrX) + disparityX / 2;\r\n    const anchorY = Math.min(...arrY) + disparityY / 2;\r\n    points.forEach((point) => {\r\n      scene.point(\r\n        point.id,\r\n        point.coordinate.x * ratio + width / 2 - ratio * anchorX,\r\n        point.coordinate.y * ratio + height / 2 - ratio * anchorY\r\n      );\r\n    });\r\n\r\n    segments.forEach((segment) => {\r\n      if (segment && segment.visible) {\r\n        scene.segment(segment.name, segment.name[0], segment.name[1]);\r\n      }\r\n    });\r\n\r\n    if (circles) {\r\n      Object.keys(circles).forEach((point) => {\r\n        scene.point(\r\n          point,\r\n          circles[point].center.x * ratio + width / 2 - ratio * anchorX,\r\n          circles[point].center.y * ratio + height / 2 - ratio * anchorY\r\n        );\r\n        scene.circle(`circle-${point}`, point, circles[point].radius * ratio);\r\n      });\r\n    }\r\n\r\n    scene.update();\r\n    renderGeometry(scene, svg);\r\n    renderGeometry(scene, svg);\r\n    renderPoints(scene, pointElements);\r\n  }\r\n\r\n  render(): React.Node {\r\n    return (\r\n      <div className=\"geometry-container\">\r\n        <svg id=\"geometry\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n        <svg id=\"points\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DrawingPanel;\r\n","import React from 'react';\r\nimport './css/MainView.scss';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';\r\n\r\nimport DataViewModel from '../ViewModel/DataViewModel';\r\n\r\nimport { Icon, InputItem, SegmentSetting } from './components';\r\nimport { DrawingPanel } from './components/DrawingPanel';\r\nimport { calculateDistanceTwoPoints, calculateVector, isVectorSameDirection } from '../core/math/Math2D';\r\nimport type { DrawingSegmentType, SegmentDataType } from '../utils/types';\r\nimport GConst from '../utils/values';\r\n\r\n@observer\r\nclass MainView extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.inputRefs = [];\r\n    this.state = {\r\n      focusIndex: 0,\r\n      points: [\r\n        { id: 'A', coordinate: { x: 0, y: 0, z: 0 } },\r\n        { id: 'B', coordinate: { y: 5, x: -7 } },\r\n        { id: 'C', coordinate: { x: -9, y: 4.0901353661613005 } },\r\n        { id: 'H', coordinate: { x: -3.0849364905389067, y: 6.781088913245535 } },\r\n        { id: 'D', coordinate: { x: -5.250000000000003, y: 3.7500000000000018 } },\r\n        { id: 'E', coordinate: { x: -8, y: 9.794855240493977 } }\r\n      ],\r\n      segments: [\r\n        'AB',\r\n        'BC',\r\n        'AC',\r\n        'AH',\r\n        'DH',\r\n        'DE',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA'\r\n      ],\r\n      drawingSegments: []\r\n    };\r\n    this.scrollView = React.createRef();\r\n  }\r\n\r\n  componentWillMount() {\r\n    const { points, segments } = this.state;\r\n    this.setState({\r\n      drawingSegments: this.trimDrawingData({ points, segments }).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  scrollToBottom() {\r\n    if (this.scrollView.current) {\r\n      setTimeout(() => {\r\n        this.scrollView.current.firstChild.scrollIntoView(false);\r\n      }, 250);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  trimDrawingData(data) {\r\n    const { points, segments } = data;\r\n\r\n    //change to DataViewModel.getNodeInPointsMapById.coordinate when refactor done\r\n    const pointData = {};\r\n    points.forEach((point) => {\r\n      pointData[point.id] = point.coordinate;\r\n    });\r\n\r\n    const segmentsData = {};\r\n    let result = [];\r\n    points.forEach((point) => {\r\n      segmentsData[point.id] = segments\r\n        .map((segment: string): string =>\r\n          segment\r\n            .split('')\r\n            .sort()\r\n            .join('')\r\n        )\r\n        .filter((segment: string): boolean => segment.includes(point.id))\r\n        .map((segment: string): SegmentDataType => {\r\n          const firstPoint = pointData[segment[0]];\r\n          const secondPoint = pointData[segment[1]];\r\n          return {\r\n            name: segment,\r\n            vector: calculateVector(firstPoint, secondPoint),\r\n            length: calculateDistanceTwoPoints(firstPoint, secondPoint)\r\n          };\r\n        });\r\n    });\r\n\r\n    const removeSegments = [];\r\n\r\n    Object.keys(segmentsData).forEach((point) => {\r\n      if (segmentsData[point].length > 0) {\r\n        const segments = this.uniqueSegmentData(segmentsData[point], removeSegments);\r\n        result = result.concat(segments);\r\n      }\r\n    });\r\n\r\n    result = [...new Set(result)].filter((segment: string): boolean => segment[0] !== segment[1]);\r\n\r\n    return result;\r\n  }\r\n\r\n  uniqueSegmentData(data: Array<SegmentDataType>, removeSegments: Array<string>): Array<string> {\r\n    let result = [data[0]];\r\n    for (let i = 1; i < data.length; i++) {\r\n      const segmentData = data[i];\r\n\r\n      const length = result.length;\r\n      let replaceIndex = -1;\r\n      for (let j = 0; j < length; j++) {\r\n        if (isVectorSameDirection(segmentData.vector, result[j].vector)) {\r\n          if (segmentData.length >= result[j].length) {\r\n            replaceIndex = j;\r\n          } else {\r\n            removeSegments.push(segmentData.name);\r\n          }\r\n        }\r\n      }\r\n      if (replaceIndex >= 0) {\r\n        result[replaceIndex] = segmentData;\r\n      } else {\r\n        if (!removeSegments.includes(segmentData.name)) {\r\n          result.push(segmentData);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result.map((segmentData: SegmentDataType): string => segmentData.name);\r\n  }\r\n\r\n  @autobind\r\n  onValueChange(value: string, index: number) {\r\n    DataViewModel.RelationsInput[index].value = value;\r\n    this.setState({ focusIndex: index });\r\n  }\r\n\r\n  @autobind\r\n  onSubmit(index: number) {\r\n    if (index === DataViewModel.RelationsInput.length - 1 && DataViewModel.RelationsInput[index].value.length > 2) {\r\n      DataViewModel.addNewInput();\r\n    }\r\n\r\n    this.setState({ focusIndex: index + 1 });\r\n  }\r\n\r\n  @autobind\r\n  onBackspace(index: number) {\r\n    const value = DataViewModel.RelationsInput[index].value;\r\n    if (value.length === 0 && DataViewModel.RelationsInput.length > 1) {\r\n      DataViewModel.removeInput(index);\r\n      this.inputRefs.splice(index, 1);\r\n      this.setState({ focusIndex: index - 1 });\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onClickDrawing() {\r\n    DataViewModel.getData.clear();\r\n\r\n    const data = DataViewModel.analyzeInput();\r\n    if (data.points.length === 0 && data.segments.length === 0) {\r\n      DataViewModel.resetInputsStatus();\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      points: data.points,\r\n      segments: data.segments,\r\n      drawingSegments: this.trimDrawingData(data).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    const { focusIndex } = this.state;\r\n    if (this.inputRefs[focusIndex]) {\r\n      this.inputRefs[focusIndex].focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  renderRelationInput(): React.Node {\r\n    return DataViewModel.RelationsInput.map((model, index) => {\r\n      return (\r\n        <InputItem\r\n          key={`input-${index}`}\r\n          ref={(ref) => {\r\n            this.inputRefs[index] = ref;\r\n          }}\r\n          onValueChange={(value: string) => {\r\n            this.onValueChange(value, index);\r\n          }}\r\n          onSubmit={() => {\r\n            this.onSubmit(index);\r\n          }}\r\n          onBackspace={() => {\r\n            this.onBackspace(index);\r\n          }}\r\n          value={model.value}\r\n          status={model.status}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onDoneSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n    if (JSON.stringify(data) === JSON.stringify(drawingSegments[index])) {\r\n      return;\r\n    }\r\n\r\n    const isAddSegment = !!drawingSegments[index];\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments }, () => {\r\n      if (isAddSegment) {\r\n        if (drawingSegments.map((segment: SegmentDataType): string => segment.name).includes(data.name)) {\r\n          this.onDeleteSegmentSetting(index);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onChangeSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  onDeleteSegmentSetting(index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments.splice(index, 1);\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  addNewSegmentSetting() {\r\n    if (this.state.drawingSegments.includes(undefined)) {\r\n      return;\r\n    }\r\n    this.scrollToBottom();\r\n    this.setState((prevState) => ({\r\n      drawingSegments: prevState.drawingSegments.concat([undefined])\r\n    }));\r\n  }\r\n\r\n  @autobind\r\n  renderSegmentSettings(): React.Node {\r\n    const { drawingSegments } = this.state;\r\n    const points = this.state.points.map((point: NodeType): number => point.id);\r\n\r\n    return drawingSegments.map((segment: DrawingSegmentType, index: number): React.Node => {\r\n      return (\r\n        <SegmentSetting\r\n          key={`segment-setting-${index}`}\r\n          data={points}\r\n          value={segment}\r\n          onDone={(value) => {\r\n            this.onDoneSegmentSetting(value, index);\r\n          }}\r\n          onVisibleChange={(value) => {\r\n            this.onChangeSegmentSetting(value, index);\r\n          }}\r\n          onDelete={() => {\r\n            this.onDeleteSegmentSetting(index);\r\n          }}\r\n          style={index === 0 ? { marginTop: '1rem' } : {}}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { points, drawingSegments, segments } = this.state;\r\n    return (\r\n      <div className={'container-fluid'}>\r\n        <div className={'app-header'}>\r\n          <div className={'app-name'}>\r\n            <p>Gemath</p>\r\n          </div>\r\n\r\n          <div className={'app-description'}>\r\n            <p>app description</p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"app-body\">\r\n          <div className=\"app-controller\">\r\n            <div className=\"accordion\" id=\"accordionExample\">\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingOne\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewOne\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseOne\">\r\n                  <p>1. Nhập đề</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <div>{GConst.TutorialString.STEP_ONE}</div>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div\r\n                  id=\"viewOne\"\r\n                  className=\"collapse show\"\r\n                  aria-labelledby=\"headingOne\"\r\n                  data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\">\r\n                    <div>\r\n                      {this.renderRelationInput()}\r\n                      <Button\r\n                        type=\"button\"\r\n                        className=\"btn btn-success w-100\"\r\n                        onClick={this.onClickDrawing}\r\n                        disabled={DataViewModel.isInputEmpty}>\r\n                        Vẽ hình\r\n                      </Button>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingTwp\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewTwo\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseTwp\">\r\n                  <p>2. Chỉnh sửa hình</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <span>\r\n                          Thêm/Xóa các doạn thẳng\r\n                        </span>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div id=\"viewTwo\" className=\"collapse \" aria-labelledby=\"headingOne\" data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\" ref={this.scrollView}>\r\n                    <div>\r\n                      {this.renderSegmentSettings()}\r\n                      <div className={'add-row-container'} onClick={this.addNewSegmentSetting}>\r\n                        <Icon name={'icAdd'} width={35} height={35} color={'#757575'} />\r\n                        <p>Thêm đoạn thẳng</p>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className={'app-drawing-panel'}>\r\n            <DrawingPanel drawingData={{ points, segments: drawingSegments, circles: DataViewModel.circlesData }} />\r\n          </div>\r\n        </div>\r\n\r\n        <div className={'app-footer'}>\r\n          <p>abc</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MainView;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainView from './View/MainView';\r\n\r\nReactDOM.render(<MainView />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};"],"sourceRoot":""}