{"version":3,"sources":["serviceWorker.js","Model/AppData.js","core/definition/define.js","core/config/values.js","core/utils/isNum.js","core/utils/isValid.js","core/utils/isFunction.js","core/error/ErrorHandleService.js","core/math/MathOperation.js","core/math/Converter.js","core/math/Generation.js","core/config/GConfig.js","core/config/GLog.js","core/math/Math2D.js","utils/checker.js","core/definition/defineObjType.js","core/validation/validation.js","core/definition/index.js","core/definition/defineShapeType.js","core/definition/definePointType.js","core/math/GenerateGeometry.js","core/analysis/ReadPointsMap.js","core/analysis/ReadRelation.js","core/analysis/Analysis.js","Model/RelationInputModel.js","ViewModel/DataViewModel.js","ViewModel/ContextMenuViewModel.js","View/components/InputItem/InputItem.js","View/components/Icon/Icon.js","View/components/Icon/Svg.js","View/components/SegmentSetting/SegmentSetting.js","vendor/euclid/model/geom.js","vendor/euclid/model/point.js","vendor/euclid/calc.js","vendor/euclid/model/circle.js","vendor/euclid/model/line.js","vendor/euclid/model/segment.js","vendor/euclid/intersection.js","vendor/euclid/model/intersection.js","vendor/euclid/model/index.js","vendor/euclid/scene.js","vendor/euclid/render.js","View/components/DrawingPanel/DrawingPanel.js","View/MainView.js","index.js","utils/color.scss","View/components/InputItem/InputItem.scss"],"names":["Boolean","window","location","hostname","match","appData","AppData","Object","classCallCheck","this","additionSegment","relationsResult","pointsMap","pointsDirectionMap","executedRelations","executedNode","__pointDetails__","Map","clear","segment","push","newPointsMap","value","defineSentences","define","relation","shape","reversedDependentObjRelation","RankingObjectContain","objectWithPoint","validate","object","point","length","format","ray","line","angle","triangle","quadrilateral","trapezoid","parallelogram","rectangle","rhombus","square","circle","shapeType","shapeRules","right","isosceles","right_isosceles","equilateral","normal","mappingShapeType","vuông","cân","vuông cân","đều","nội tiếp","ngoại tiếp","bàng tiếp","circleType","TwoStaticPointRequireShape","ShapeAffectBySegmentChange","GConst","Number","freeze","MIN_RANDOM_NUMBER","MAX_RANDOM_NUMBER","MIN_RANDOM_GENERATION","MAX_RANDOM_GENERATION","NOT_FOUND","String","INFINITY","IMPOSSIBLE","TOO_SHORT","NOT_ENOUGH_SET","NOT_BE_IN_LINE","Regex","KEY","OTHER","Others","OPERATIONS","Errors","UNDEFINED_ERROR","WRONG_FORMAT","MAXIMUM_POINT_ERROR","InputStatus","SUCCESS","NORMAL","ERROR","TutorialString","STEP_ONE","isNum","rs","undefined","Array","isArray","Infinity","isNaN","isValid","r","toString","prototype","isFunction","type","isObject","tag","call","getTag","ErrorCode","200","300","301","400","401","500","501","502","ErrorService","message","code","errorRelation","index","dataViewModel","inputData","forEach","data","i","executedInputIndex","filter","executingRelation","RelationsInput","status","alert","console","error","instance","Parenthesis","element","concat","Sub","elementOne","elementTwo","parseFloat","Math","abs","Round","f","arguments","calculatedValue","evaluate","myF","pow","round","Add","parseInt","Multiply","isNegative","result","Divide","Sqrt","showError","Pow","exponent","isEqual","Compare","calculatedValueOne","calculatedValueTwo","isZero","Abs","isSmallerThanZero","Max","_len","values","_key","max","maxValue","evaluatedValue","MathOperation","Operation","convertLinearToEquation","l","c","d","e","a","b","convertEquationToLineType","convertLineTypeToEquation","MIN","MAX","getRandomValue","min","floor","random","getRandomPointInEquation","equation","tempX","x","y","centerPoint","radius","sqrt","randomValueX","solvedValueY","calculateQuadraticEquation","secondRoot","firstRoot","generatePointAlignmentInside","firstPoint","secondPoint","getLineFromTwoPoints","generatePointAlignmentOutside","isRight","tempXRight","tempXLeft","env","isDev","isOffLog","GConfig","GLog","moduleName","constructor","_console","args","info","apply","name","msg","offThis","log","_len2","msgs","_key2","join","_makeRound","num","logError","calculateVector","isMakeRound","isVectorSameDirection","firstVector","secondVector","isVectorInSameLine","calculateMiddlePoint","calculateSymmetricalPoint","p1","p2","directionVector","normalVector","calculateDistanceTwoPoints","squareX","squareY","calculateDistanceFromPointToLine","numerator","denominator","calculateParallelLineByPointAndLine","lineEquation","parLine","calculatePerpendicularLineByPointAndLine","perpendicularLine","perLine","calculateIntersectionByLineAndLine","lineOne","lineTwo","calculateSetOfEquationTypeAndQuadraticEquation","calculateCircleEquationByCenterPoint","calculateInternalBisectLineEquation","pointOne","pointTwo","results","_calculateBisectLineEquation","firstLine","secondLine","getAngleFromTwoLines","set","_getInternalBisectLineEquation","calculateExternalBisectLineEquation","internalLine","JSON","stringify","resultOne","resultTwo","coefficient","firstEquation","secondEquation","calculateIntersectionEquationTypeWithCircleEquation","q","A","B","distanceFromCenterPointToLine","logMsgWithLineBreaks","delta","isIn","p","temp","C","D","E","F","G","H","root","r1","r2","calculateIntersectionTwoCircleEquations","q1","q2","Z","_D","_E","_G","roots","d1","d2","logMsg","tempY","calculateSetOfEquationTypes","calculateLinesByAnotherLineAndAngle","rootPoint","staticPoint","dynamicPoint","equations","cosine","_calculateLinesByAnotherLineAndAngle","map","newRootPoint","vectorOne","vectorTwo","calculateIntegratedDirection","calculateVectorLength","calculateAngleTwoVector","vector","makeRoundCoordinate","a1","a2","b1","b2","getMiddlePointFromThreePointsInALine","p3","dis_p1_p2","dis_p2_p3","dis_p1_p3","calculateTangentEquation","tangentPoint","tangentEquation","center","isTwoEquationEqual","equationOne","equationTwo","isIsosceles","isNumber","isObjectLike","isQuadraticEquation","checkFormatString","str","split","char","toLowerCase","defineObject","slice","includes","validateObject","validateValue","_validateName","validateType","validateGeometryType","key","validateShape","keys","validateShapeFormat","validateShapeType","shapeFormatCheck","shapeTypeCheck","checkObjectRelationship","obj1","obj2","check","toConsumableArray","Set","indexOf","string","item","array","validateInformation","outputType","j","indexOfRankingLevel","indexOfObjectCurrentLevel","indexOfObjectNextLevel","validateDataRelationship","defineInformation","splitter","shapeName","pop","otherData","replace","trim","defineShapeType","definePointType","reverse","sortString","toUpperCase","sort","Error","geometricObj","z","updateCoordinate","distance_From_A_To_B","linearEquation","p4","lineAB","lineAC","lineBC","lineAD","lineCD","intersection_AB_CD","intersection_AD_BC","distanceX","p4X","node","isFunc","readRelation","equationResults","operation","objectType","valueData","objectsIncludePoint","getNodeInPointsMapById","coordinate","staticValue","staticObject","angleName","angleValue","checkResult","isValidCoordinate","isChanged","shapeList","getData","shapes","shapeData","getShapeAffectList","secondLineVector","modifiedAngleName","updatePoint","reExecuteNode","checkAndModifiedAngle","changedPoint","calculatedEquation","intersectPoint","transitionVector","rootOne","rootTwo","replaceSetOfEquation","calculateLineEquationByAngleRelation","staticPointOne","staticPointTwo","isStaticNodeById","staticLineEquation","staticDistance","isAlign","coefficientX","coefficientY","constantTerm","ratio","calculatedPoint","betweenPoint","analyzeOperationType","segmentIncludePoint","segmentNotIncludePoint","relationType","getCircleEquation","otherStaticPoint","otherStaticNodeInSegment","points","getAdditionSegment","generatePointMiddleTwoPoints","calculatedLineEquation","isInStaticLine","isExternal","analyzeRelationType","calculatedLineEquationOne","calculatedLineEquationTwo","analyzeIntersectRelation","otherPointInSegment","tangentPointCoordinate","circleEquation","exceptionPoint","tempCircleCenter","tempCircleRadius","tempCircleEquation","calculateTangentIntersectPointsByPointOutsideCircle","filterRoots","isCoordinateDuplicated","filterTangentPoint","analyzeTangentRelation","count","limit","executeRelations","dependentNodes","_makeUniqueNodeRelation","relationEquation","bisectorLineOne","bisectorLineTwo","calculateInCircleEquation","midperpendicularsLineOne","midperpendicularsLineTwo","calculateCircumCircleEquation","escribedPoint","otherPoints","calculateEscribedCirclesEquation","circlesData","isExecutedRelation","generateFunc","generateGeometry","pointCoordinate","rootCoordinate","getPointDirectionMap","isUp","makeCorrectShape","id","executePointDetails","getExecutedRelations","isReCalculated","getExecutedNode","rules","executePoint","staticPointCountRequire","staticPoints","arrayRules","RegExp","executePointIndex","nodeSetEquations","rule","staticLine","nonStaticLine","getLinearEquationByParallelRule","getLinearEquationByPerpendicularRule","includeLine","nonIncludeLine","staticLines","shapePoints","staticPointIndex","pointIndex","calculatedCoordinate","otherPointInIncludeLine","nonStaticPointIndex","updateCoordinateBySpecialPerpendicularRule","otherPoint","getLinearEquationsByEqualRule","RelationPointsMap","analyzeResult","validatedResult","isHaveTriangle","segments","relationSegments","relationAngles","relations","deleteRelationList","shift","updateErrorInInput","deleteWrongRelation","objectPointsMap","el1","el2","index1","findIndexByNodeId","getPointsMap","index2","sortPriority","shouldStaticPoint","angles","getRelationsResult","shapePointCount","minCountPoint","getFirstStaticPointInShape","createNode","updateMap","createPointsMapByShape","nodeOne","nodeTwo","lastObjectPoints","lastNode","nodeIndex","isStatic","getDependentObject","currentNode","objectSpread","createDependentNodeOfRelation","createPointsMapByRelation","setPointsMap","unique","createPointDetails","table","parse","isPointsMapStatic","executingNode","getNextExecuteNode","getPointDetails","has","get","isNeedRandomCoordinate","nodeDirectionInfo","staticPointCoordinate","coordinateMatch","directionInfo","matchCount","updateStaticNode","setOfEquation","readPointsMap","_RoundObject","getShapeSegments","getRelationSegments","getArraySegments","exception","_dependentNodes","oldNode","RelationInputModel","initializerDefineProperty","_descriptor","_descriptor2","observable","DataViewModel","_this","DataViewModel_descriptor","DataViewModel_descriptor2","_descriptor3","_descriptor4","pointId","nodeId","getIndexOfNodeInPointsMapById","_coordinate","isStaticNode","arrayPoint","dependence","keepExecutedRelations","updatePointsMap","clonePointsMap","sortNodeByPriority","staticNodeOneCount","getDependentStaticNodeCount","nodeOneData","static","nonStatic","minRelationIndex","getMinIndexOfDependentNodeInRelationsList","getIndexOfNodeInPointsMap","staticNodeTwoCount","nodeTwoData","rankOne","rankTwo","indexArray","getIndexOfRelationInRelationsList","list","_calculateSet","relationsInput","input","newRelationInput","resetInputsStatus","splice","_this2","_updatePointDetails","exceptedCoordinates","searchEquation","replaceEquation","pointDetail","isReplaceComplete","pointDetails","sum","isFirst","newSetOfEquation","currentRoots","finalRoots","_this3","_string","isMatching","preProgress","sentence","getBasicInformation","_defineSentence","others","params","start","end","param","lastParam","getLength","dictionary","centerId","_this4","stringifyCoordinate","_this5","getInformation","setRelationsResult","computed","action","ViewModel_ContextMenuViewModel","isContextShow","KEYCODE","BACKSPACE","ENTER","InputItem","observer","props","possibleConstructorReturn","getPrototypeOf","inputRef","React","state","shouldRemove","isEmpty","popupX","popupY","current","focus","currentTarget","onValueChange","setState","_this$props","onBackspace","onSubmit","keyCode","ContextMenuViewModel","hideContextMenu","currentInputIndex","preventDefault","persist","setTimeout","showContextMenu","pageX","clientY","handleClose","removeInput","react","className","style","left","top","onMouseDown","onAddInputBefore","Icon_Icon","width","height","color","_this$props2","renderContextMenu","onContextMenu","onOpenContextMenu","onClick","onDeleteInput","onBlur","ref","onChange","onKeyUp","aria-describedby","autobind","iconList","inputSuccess","svg","react_default","createElement","fill","viewBox","inputError","inputNormal","icInformation","icRemove","icEdit","icAdd","fillRule","clipRule","icPlusBold","Icon","icon","SegmentSetting","visible","isEditMode","isCreateMode","isMouseHoverEdition","isMouseHoverDeletion","_this$state","onDone","onDelete","onVisibleChange","dropdownIndex","filterValue","filterValueIndex","_this$state2","newStartValue","getIndexInData","_this$state3","onSelect","DropdownButton","title","Dropdown","Item","eventKey","_this$state4","renderDropdown","onStartPointSelect","onEndPointSelect","Button","onChangeContentState","variant","disabled","_this$props$value","dist_default","onstyle","offstyle","handleClassName","off","on","active","onMouseLeave","mouseLeaveEdition","onMouseOver","mouseHoverEdition","mouseHoverDeletion","mouseLeaveDeletion","renderEditContent","renderShowContent","_this$state5","renderContent","Geom","Point","free","esm_get","distance","distanceSquared","dx","dy","Circle","_fromCenterAndBoundaryPoint","_fromCenterAndRadius","defineProperties","radiussq","boundaryPoint","w","h","Line","_p","_clip","assertThisInitialized","theta","atan2","m","bottom","P","Segment","lengthsq","bounds","_line$_p","slicedToArray","t","clipped","parent","comparePoints","sq","between","intersect","o1","o2","c1","c2","dsq","dd","cx","cy","nx","ny","uniq","intersectCircleCircle","intersectCircleLine","intersectLineLine","s1","s2","clip","_s1$_p","_s1$_p$","x1","y1","_s1$_p$2","_s2$_p","_s2$_p$","x3","y3","_s2$_p$2","s","_s$_p","_s$_p$","_s$_p$2","x2","y2","_c$center","x0","y0","Dsq","lensq","disc","Intersection","objects","which","test","_result","verbose","pstr","o","addClass","obj","klass","classes","d3","add","Scene","threshold","_last","_objects","equal","every","secondObj","id1","id2","_currentTag","existing","prop","find","freeName","update","label","time","Date","klasses","init","renderGeometry","scene","svgElement","circles","selectAll","circleGroup","enter","append","attr","exit","remove","lines","lineGroup","endpoint","coord","DrawingPanel","drawingData","document","getElementById","firstChild","pointElements","baseVal","arrX","arrY","minX","minY","disparityX","disparityY","transitionX","transitionY","_groups","__data__","appendChild","createTextNode","renderPoints","MainView","inputRefs","focusIndex","drawingSegments","scrollView","createRef","trimDrawingData","scrollIntoView","pointData","segmentsData","removeSegments","uniqueSegmentData","segmentData","replaceIndex","addNewInput","analyzeInput","model","components_InputItem_InputItem","isAddSegment","onDeleteSegmentSetting","scrollToBottom","prevState","_this6","components_SegmentSetting_SegmentSetting","onDoneSegmentSetting","onChangeSegmentSetting","marginTop","data-toggle","data-target","aria-expanded","aria-controls","OverlayTrigger","container","placement","overlay","Tooltip","aria-labelledby","data-parent","renderRelationInput","onClickDrawing","isInputEmpty","renderSegmentSettings","addNewSegmentSetting","components_DrawingPanel_DrawingPanel","Component","ReactDOM","render","View_MainView","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.7c08ee9d.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","// @flow\r\n\r\nclass AppData {\r\n  constructor() {\r\n    this.additionSegment = [];\r\n    this.relationsResult = {};\r\n    this.pointsMap = [];\r\n    this.pointsDirectionMap = {};\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__ = new Map();\r\n  }\r\n\r\n  clear() {\r\n    this.additionSegment = [];\r\n    this.relationsResult = {};\r\n    this.pointsMap = [];\r\n    this.pointsDirectionMap = {};\r\n    this.executedRelations = [];\r\n    this.executedNode = [];\r\n    this.__pointDetails__.clear();\r\n  }\r\n\r\n  set setRelationsResult(value) {\r\n    this.relationsResult = value;\r\n  }\r\n\r\n  pushAdditionSegment(segment: string) {\r\n    this.additionSegment.push(segment);\r\n  }\r\n\r\n  get getAdditionSegment() {\r\n    return this.additionSegment;\r\n  }\r\n\r\n  get getRelationsResult() {\r\n    return this.relationsResult;\r\n  }\r\n\r\n  get getPointsMap() {\r\n    return this.pointsMap;\r\n  }\r\n\r\n  setPointsMap(newPointsMap) {\r\n    this.pointsMap = newPointsMap;\r\n  }\r\n\r\n  get getPointDirectionMap() {\r\n    return this.pointsDirectionMap;\r\n  }\r\n\r\n  get getExecutedRelations() {\r\n    return this.executedRelations;\r\n  }\r\n\r\n  get getExecutedNode() {\r\n    return this.executedNode;\r\n  }\r\n\r\n  get getPointDetails() {\r\n    return this.__pointDetails__;\r\n  }\r\n}\r\n\r\nconst appData = new AppData();\r\n\r\nexport default appData;\r\n","const defineSentences = {\r\n  define: [\r\n    '{object} + {object} = {object}',\r\n    '{object} - {object} = {object}',\r\n    '{object} = {value} * {object}',\r\n    '{object} = {object}',\r\n    '{object} > {object}',\r\n    '{object} < {object}'\r\n  ],\r\n  relation: [\r\n    '{object} song song {object}',\r\n    '{object} vuông góc {object}',\r\n    '{object} cắt {object} tại {arrayPoints}',\r\n    '{object} phân giác ngoài {angle}',\r\n    '{object} phân giác trong {angle}',\r\n    '{object} phân giác {angle}',\r\n    '{arrayPoints} thẳng hàng',\r\n    '{point} trung điểm {segment}',\r\n    '{point} không thuộc {object}',\r\n    '{point} thuộc {object}',\r\n    '{segment} trung tuyến {triangle}',\r\n    '{segment} đường cao {triangle}',\r\n    '{segment} tiếp tuyến {circle}'\r\n  ],\r\n  shape: [\r\n    'tam giác {type triangle}',\r\n    'tứ giác {quadrilateral}',\r\n    'hình thang {type trapezoid}',\r\n    'hình bình hành {parallelogram}',\r\n    'hình chữ nhật {rectangle}',\r\n    'hình thoi {rhombus}',\r\n    'hình vuông {square}',\r\n    '{object type triangle} tại {escribedPoint}',\r\n    '{object type triangle}'\r\n  ]\r\n};\r\n\r\nconst shapeList = ['triangle', 'quadrilateral', 'trapezoid', 'parallelogram', 'rectangle', 'rhombus', 'square'];\r\n\r\nconst reversedDependentObjRelation = ['vuông góc', 'cắt'];\r\n\r\nconst RankingObjectContain = [['point'], ['segment', 'ray'], ['angle']];\r\n\r\nconst objectWithPoint = ['angle', 'segment', 'ray', 'point', 'circle', 'triangle'];\r\n\r\nconst validate = {\r\n  object: {\r\n    define: ['angle', 'segment'],\r\n    relation: ['ray', 'line', 'segment', 'circle']\r\n  },\r\n  point: { length: 1, format: '1' },\r\n  segment: { length: 2, format: '11' },\r\n  ray: { length: 2, format: '10' },\r\n  line: { length: 1, format: '0' },\r\n  angle: { length: 3 },\r\n  shape: {\r\n    triangle: { length: 3, format: '111' },\r\n    quadrilateral: { length: 4, format: '1111' },\r\n    trapezoid: { length: 4, format: '1111' },\r\n    parallelogram: { length: 4, format: '1111' },\r\n    rectangle: { length: 4, format: '1111' },\r\n    rhombus: { length: 4, format: '1111' },\r\n    square: { length: 4, format: '1111' },\r\n    circle: { length: 1, format: '1' }\r\n  },\r\n  shapeType: {\r\n    triangle: ['', 'vuông', 'cân', 'vuông cân', 'đều', 'nội tiếp', 'ngoại tiếp', 'bàng tiếp'],\r\n    trapezoid: ['', 'vuông', 'cân']\r\n  }\r\n};\r\n\r\n/*\r\n    | song song,\r\n    ^ vuông góc,\r\n    = cân\r\n */\r\nconst shapeRules = {\r\n  triangle: {\r\n    right: '01^02', // Ex: AB vuong goc AC\r\n    isosceles: '01=02',\r\n    right_isosceles: '01^02&01=02',\r\n    equilateral: '01=02&01=12&02=12'\r\n  },\r\n  trapezoid: {\r\n    normal: '01|23',\r\n    right: '01|23&01^03',\r\n    isosceles: '01|23&03=12'\r\n  },\r\n  parallelogram: {\r\n    normal: '01|23&03|12'\r\n  },\r\n  rectangle: {\r\n    normal: '01^12&12^23&23^30&30^01'\r\n  },\r\n  rhombus: {\r\n    normal: '02^13'\r\n  },\r\n  square: {\r\n    normal: '01|23&03|12&01^12&12^23&23^03&01=03&&01=12&12=23&&23=03'\r\n  }\r\n};\r\n\r\nconst mappingShapeType = {\r\n  vuông: 'right',\r\n  cân: 'isosceles',\r\n  'vuông cân': 'right_isosceles',\r\n  đều: 'equilateral',\r\n  'nội tiếp': 'nội tiếp',\r\n  'ngoại tiếp': 'ngoại tiếp',\r\n  'bàng tiếp': 'bàng tiếp'\r\n};\r\n\r\nconst circleType = ['nội tiếp', 'ngoại tiếp', 'bàng tiếp'];\r\n\r\nconst TwoStaticPointRequireShape = ['triangle', 'trapezoid', 'rectangle', 'square'];\r\n\r\nconst ShapeAffectBySegmentChange = ['rhombus', 'trapezoid', 'parallelogram'];\r\n\r\nexport {\r\n  validate,\r\n  TwoStaticPointRequireShape,\r\n  defineSentences,\r\n  RankingObjectContain,\r\n  objectWithPoint,\r\n  shapeList,\r\n  reversedDependentObjRelation,\r\n  shapeRules,\r\n  mappingShapeType,\r\n  circleType,\r\n  ShapeAffectBySegmentChange\r\n};\r\n","const Number = Object.freeze({\r\n  MIN_RANDOM_NUMBER: -10,\r\n  MAX_RANDOM_NUMBER: 10,\r\n  MIN_RANDOM_GENERATION: 5,\r\n  MAX_RANDOM_GENERATION: 15,\r\n  NOT_FOUND: 99\r\n});\r\n\r\nconst String = Object.freeze({\r\n  INFINITY: 'vô cực',\r\n  IMPOSSIBLE: 'vô nghiệm',\r\n  TOO_SHORT: 'quá ngắn',\r\n  NOT_ENOUGH_SET: 'không đủ phương trình tạo thành hệ',\r\n  NOT_BE_IN_LINE: 'điểm không thuộc đường'\r\n});\r\n\r\nconst Regex = Object.freeze({\r\n  KEY: '[^{\\\\}]+(?=})',\r\n  OTHER: '(^([^{]+(?={)))|((?<=})([^{]+)(?={))|(((?<=})[^}]+)$)'\r\n});\r\n\r\nconst Others = Object.freeze({\r\n  OPERATIONS: ['+', '-', '*', '<', '>', '=']\r\n});\r\n\r\nconst Errors = Object.freeze({\r\n  UNDEFINED_ERROR: 'Lỗi không xác dịnh',\r\n  WRONG_FORMAT: 'Sai định dạng',\r\n  MAXIMUM_POINT_ERROR: 'Tối đa 3 điểm thẳng háng'\r\n});\r\n\r\nconst InputStatus = Object.freeze({\r\n  SUCCESS: 'Success',\r\n  NORMAL: `Normal`,\r\n  ERROR: 'Error'\r\n});\r\nconst TutorialString = {\r\n  STEP_ONE: `\r\n  Danh sách các mẫu câu dặc trưng:\r\n    \\n__ = __\r\n    \\n__ song song/vuông góc __\r\n    \\n__ cắt __ tại __\r\n    \\n__ phân giác __\r\n    \\n__ thẳng hàng\r\n    \\n__ trung điểm __\r\n    \\n__ thuộc/không thuộc __\r\n    \\n__ tiếp tuyến (__)\r\n    \\ntam giác {loại} __\r\n    \\ntứ giác __\r\n    \\nđường tròn tâm __ ngoại tiếp/nội tiếp __\r\n\\nLưu ý:\r\n  \\n Đường tròn trong cái mối quan hệ khác sẽ nằm trong ()\r\n  \\n  Vd: AB tiếp tuyến (O)\r\n  `\r\n};\r\nconst GConst = {\r\n  Number,\r\n  String,\r\n  Regex,\r\n  Others,\r\n  Errors,\r\n  InputStatus,\r\n  TutorialString\r\n};\r\n\r\nexport default GConst;\r\n","export default function isNum(value) {\r\n  let rs = true;\r\n\r\n  if (\r\n    value === undefined ||\r\n    value === null ||\r\n    value === false ||\r\n    value === true ||\r\n    Array.isArray(value) ||\r\n    value === Infinity ||\r\n    isNaN(value)\r\n  ) {\r\n    rs = false;\r\n  }\r\n\r\n  return rs;\r\n}","export default function isValid(value) {\r\n  let r = true;\r\n\r\n  if (value === undefined || value === null || value === '') {\r\n    r = false;\r\n  }\r\n\r\n  return r;\r\n}","const toString = Object.prototype.toString;\r\n\r\nfunction isObject(value) {\r\n  const type = typeof value;\r\n  return value != null && (type === 'object' || type === 'function');\r\n}\r\n\r\nfunction getTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ?\r\n      '[object Undefined]' :\r\n      '[object Null]';\r\n  }\r\n  return toString.call(value);\r\n}\r\n\r\nexport default function isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  const tag = getTag(value);\r\n  return tag === '[object Function]' ||\r\n    tag === '[object AsyncFunction]' ||\r\n    tag === '[object GeneratorFunction]'\r\n    || tag === '[object Proxy]';\r\n}","// @flow\r\n\r\nimport GConst from '../config/values';\r\nimport dataViewModel from '../../ViewModel/DataViewModel';\r\n\r\nconst ErrorCode = {\r\n  200: GConst.Errors.UNDEFINED_ERROR,\r\n  300: GConst.Errors.WRONG_FORMAT,\r\n  301: GConst.Errors.MAXIMUM_POINT_ERROR,\r\n  400: GConst.String.IMPOSSIBLE,\r\n  401: GConst.String.INFINITY,\r\n  500: GConst.String.NOT_BE_IN_LINE,\r\n  501: GConst.String.NOT_ENOUGH_SET,\r\n  502: GConst.String.TOO_SHORT\r\n};\r\n\r\nclass ErrorHandleService {\r\n  message: string = '';\r\n\r\n  get ErrorMessage() {\r\n    return this.message;\r\n  }\r\n\r\n  showError(code: string, errorRelation?: mixed) {\r\n    let index;\r\n    if (errorRelation) {\r\n      dataViewModel.inputData.forEach((data: mixed, i: number) => {\r\n        if (data === errorRelation) {\r\n          index = i;\r\n        }\r\n      });\r\n    } else {\r\n      switch (code) {\r\n        case 300:\r\n        case 301:\r\n          index = dataViewModel.executedInputIndex;\r\n          break;\r\n        default:\r\n          index = dataViewModel.inputData.filter((data: mixed): boolean => data === dataViewModel.executingRelation)[0];\r\n      }\r\n    }\r\n    if (index >= 0) {\r\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\r\n    }\r\n\r\n    alert(ErrorCode[code]);\r\n    throw console.error('error', ErrorCode[code]);\r\n  }\r\n\r\n  updateErrorInInput(errorRelation: mixed) {\r\n    let index;\r\n    if (errorRelation) {\r\n      dataViewModel.inputData.forEach((data: mixed, i: number) => {\r\n        if (data === errorRelation) {\r\n          index = i;\r\n        }\r\n      });\r\n    }\r\n    if (index >= 0) {\r\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\r\n    }\r\n  }\r\n}\r\n\r\nconst ErrorService = new ErrorHandleService();\r\n\r\nexport default ErrorService;\r\n","//@flow\r\n\r\nimport { evaluate } from 'mathjs';\r\nimport type { CalculatedResultType } from '../../utils/types';\r\n\r\nimport ErrorService from '../error/ErrorHandleService';\r\n\r\nfunction MathOperation(): Object {\r\n  function Parenthesis(element: CalculatedResultType): string {\r\n    if (!isNaN(element)) {\r\n      return element;\r\n    }\r\n    return `(${element})`;\r\n  }\r\n  function Add(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\r\n    if (!isNaN(elementOne) || !isNaN(elementTwo)) {\r\n      if (parseInt(elementOne) === 0) {\r\n        return Parenthesis(elementTwo);\r\n      }\r\n      if (parseInt(elementTwo) === 0) {\r\n        return Parenthesis(elementOne);\r\n      }\r\n    }\r\n\r\n    if (!isNaN(elementOne) && !isNaN(elementTwo)) {\r\n      if (parseFloat(elementOne) === Round(elementOne) && parseFloat(elementTwo) === Round(elementTwo))\r\n        return parseFloat(elementOne) + parseFloat(elementTwo);\r\n    }\r\n\r\n    const result = `(${elementOne})+(${elementTwo})`;\r\n\r\n    return Parenthesis(result);\r\n  }\r\n  function Sub(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\r\n    if (!isNaN(elementOne) && !isNaN(elementTwo)) {\r\n      if (parseFloat(elementOne) === 0) {\r\n        if (parseFloat(elementTwo) < 0) {\r\n          return Math.abs(parseFloat(elementTwo));\r\n        }\r\n        return `-${elementTwo}`;\r\n      }\r\n      if (parseFloat(elementTwo) === 0) {\r\n        return elementOne;\r\n      }\r\n      return parseFloat(elementOne) - parseFloat(elementTwo);\r\n    }\r\n    const result = `(${elementOne})-(${elementTwo})`;\r\n    return Parenthesis(result);\r\n  }\r\n  function Multiply(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\r\n    if (!isNaN(elementOne) || !isNaN(elementTwo)) {\r\n      if (parseFloat(elementOne) === 0 || parseFloat(elementTwo) === 0) {\r\n        return 0;\r\n      }\r\n      if (!isNaN(elementOne) && Math.abs(elementOne) === 1) {\r\n        const calculatedValue = evaluate(elementTwo);\r\n        if (calculatedValue === Round(calculatedValue)) {\r\n          return Parenthesis(parseFloat(elementOne) * calculatedValue);\r\n        }\r\n        const isNegative = parseFloat(elementOne) / Math.abs(elementOne) < 0;\r\n        return Parenthesis(`${isNegative ? '-' : ''}(${elementTwo})`);\r\n      }\r\n      if (!isNaN(elementTwo) && Math.abs(elementTwo) === 1) {\r\n        const calculatedValue = evaluate(elementOne);\r\n        if (calculatedValue === Round(calculatedValue)) {\r\n          return Parenthesis(parseFloat(elementTwo) * calculatedValue);\r\n        }\r\n        const isNegative = parseFloat(elementTwo) / Math.abs(elementTwo) < 0;\r\n        return Parenthesis(`${isNegative ? '-' : ''}(${elementOne})`);\r\n      }\r\n    }\r\n\r\n    if (!isNaN(elementOne) && !isNaN(elementTwo)) {\r\n      return parseFloat(elementOne) * parseFloat(elementTwo);\r\n    }\r\n\r\n    const result = `(${elementOne})*(${elementTwo})`;\r\n    const calculatedValue = evaluate(result);\r\n\r\n    if (calculatedValue === Round(calculatedValue)) {\r\n      return Parenthesis(calculatedValue);\r\n    }\r\n    return Parenthesis(result);\r\n  }\r\n  function Divide(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\r\n    if (!isNaN(elementOne) || !isNaN(elementTwo)) {\r\n      if (parseFloat(elementOne) === 0) {\r\n        return 0;\r\n      }\r\n      if (!isNaN(elementTwo) && Math.abs(elementTwo) === 1) {\r\n        const calculatedValue = evaluate(elementOne);\r\n        if (calculatedValue === Round(calculatedValue)) {\r\n          return Parenthesis(parseFloat(elementTwo) * calculatedValue);\r\n        }\r\n        const isNegative = parseFloat(elementTwo) / Math.abs(elementTwo) < 0;\r\n        return Parenthesis(`${isNegative ? '-' : ''}(${elementOne})`);\r\n      }\r\n    }\r\n\r\n    const result = `(${elementOne})/(${elementTwo})`;\r\n\r\n    const calculatedValue = evaluate(result);\r\n    if (calculatedValue === Round(calculatedValue)) {\r\n      return Parenthesis(calculatedValue);\r\n    }\r\n    return Parenthesis(result);\r\n  }\r\n  function Sqrt(element: CalculatedResultType): CalculatedResultType {\r\n    const result = `(${element})^(1/2)`;\r\n\r\n    const calculatedValue = evaluate(result);\r\n    if (typeof calculatedValue !== 'number') {\r\n      if (Round(element, 8) === 0) {\r\n        return 0;\r\n      }\r\n      ErrorService.showError('200');\r\n    }\r\n    if (calculatedValue === Round(calculatedValue)) {\r\n      return calculatedValue;\r\n    }\r\n    return Parenthesis(result);\r\n  }\r\n  function Pow(element: CalculatedResultType, exponent: CalculatedResultType): CalculatedResultType {\r\n    if (!isNaN(element)) {\r\n      return parseFloat(element) * parseFloat(element);\r\n    }\r\n    const result = `(${element})^(${exponent})`;\r\n\r\n    const calculatedValue = evaluate(result);\r\n\r\n    if (calculatedValue === Round(calculatedValue)) {\r\n      return Parenthesis(calculatedValue);\r\n    }\r\n    return Parenthesis(result);\r\n  }\r\n\r\n  function isEqual(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): boolean {\r\n    const calculatedValueOne = evaluate(elementOne);\r\n    const calculatedValueTwo = evaluate(elementTwo);\r\n\r\n    return calculatedValueOne === calculatedValueTwo;\r\n  }\r\n\r\n  function Compare(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): number {\r\n    const calculatedValueOne = Round(elementOne, 3);\r\n    const calculatedValueTwo = Round(elementTwo, 3);\r\n\r\n    if (calculatedValueOne > calculatedValueTwo) {\r\n      return 1;\r\n    }\r\n    if (calculatedValueOne < calculatedValueTwo) {\r\n      return -1;\r\n    }\r\n    return 0;\r\n  }\r\n  function isZero(element: CalculatedResultType): boolean {\r\n    return Round(element, 5) === 0;\r\n  }\r\n\r\n  function isSmallerThanZero(element: CalculatedResultType): boolean {\r\n    return Round(element, 5) < 0;\r\n  }\r\n\r\n  function Abs(element: CalculatedResultType): CalculatedResultType {\r\n    const calculatedValue = evaluate(element);\r\n\r\n    if (calculatedValue >= 0) {\r\n      return element;\r\n    }\r\n\r\n    return Parenthesis(Sub(0, element));\r\n  }\r\n\r\n  function Round(element: CalculatedResultType, f?: number = 3): number {\r\n    const calculatedValue = typeof element === 'number' ? element : evaluate(element);\r\n    const myF = Math.pow(10, f);\r\n    return Math.round(calculatedValue * myF) / myF;\r\n  }\r\n\r\n  function Max(...values: Array<CalculatedResultType>): CalculatedResultType {\r\n    let max = values[0];\r\n    let maxValue = evaluate(max);\r\n    values.forEach((value: CalculatedResultType) => {\r\n      const evaluatedValue = evaluate(value);\r\n      if (evaluatedValue > maxValue) {\r\n        maxValue = evaluatedValue;\r\n        max = value;\r\n      }\r\n    });\r\n\r\n    return max;\r\n  }\r\n\r\n  return Object.freeze({\r\n    Parenthesis,\r\n    Add,\r\n    Sub,\r\n    Multiply,\r\n    Divide,\r\n    Sqrt,\r\n    Pow,\r\n    isEqual,\r\n    Compare,\r\n    isZero,\r\n    Abs,\r\n    isSmallerThanZero,\r\n    Round,\r\n    Max\r\n  });\r\n}\r\n\r\nconst instance = MathOperation();\r\n\r\nexport { instance as Operation };\r\n","import type {\r\n  EquationType,\r\n  LineType,\r\n} from '../../utils/types';\r\nimport { isValid } from '../utils/index';\r\nimport { Operation } from './MathOperation';\r\n\r\nconst {Sub, Divide, isZero} = Operation;\r\n\r\nexport function convertLinearToEquation(l: EquationType): EquationType {\r\n  if (\r\n    isValid(l) &&\r\n    isValid(l.c) &&\r\n    isValid(l.d) &&\r\n    isValid(l.e)\r\n  ) {\r\n    return {\r\n      a: 0,\r\n      b: 0,\r\n      c: l.c,\r\n      d: l.d,\r\n      e: l.e,\r\n    };\r\n  }\r\n}\r\n\r\nexport function convertEquationToLineType(line: EquationType): LineType {\r\n  if (\r\n    isValid(line) &&\r\n    isValid(line.c) &&\r\n    isValid(line.d) &&\r\n    isValid(line.e)\r\n  ) {\r\n    return {\r\n      //-line.c / (line.d === 0 ? 1 : line.d)\r\n      a: Divide(Sub(0, line.c), isZero(line.d) ?\r\n        1 :\r\n        line.d),\r\n      b: Divide(Sub(0, line.e), isZero(line.d) ?\r\n        1 :\r\n        line.d),\r\n    };\r\n  }\r\n}\r\n\r\nexport function convertLineTypeToEquation(line: LineType): EquationType {\r\n  if (\r\n    isValid(line) &&\r\n    isValid(line.a) &&\r\n    isValid(line.b)\r\n  ) {\r\n    return {\r\n      a: 0,\r\n      b: 0,\r\n      c: Sub(0, line.a),\r\n      d: 1,\r\n      e: Sub(0, line.b),\r\n    };\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport GConst from '../config/values';\r\nimport type {\r\n  CoordinateType,\r\n  EquationType,\r\n} from '../../utils/types';\r\nimport {\r\n  calculatePerpendicularLineByPointAndLine,\r\n  calculateQuadraticEquation,\r\n  getLineFromTwoPoints,\r\n} from './Math2D';\r\nimport {\r\n  isNum,\r\n  isValid,\r\n} from '../utils';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\n\r\nexport function getStartPoint(): CoordinateType {\r\n  return {\r\n    x: 0,\r\n    y: 0,\r\n  };\r\n}\r\n\r\nexport function getRandomValue(min: number, max: number): number {\r\n  if (isNum(min) && isNum(max)) {\r\n    if (max < min) {\r\n      return min;\r\n    }\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n  }\r\n}\r\n\r\nexport function getRandomPointInEquation(equation: EquationType): CoordinateType {\r\n  if (\r\n    isValid(equation) &&\r\n    isValid(equation.a) &&\r\n    isValid(equation.b) &&\r\n    isValid(equation.c) &&\r\n    isValid(equation.d) &&\r\n    isValid(equation.e)\r\n  ) {\r\n    if (!equation.a) {\r\n      equation.a = 0;\r\n    }\r\n    if (!equation.b) {\r\n      equation.b = 0;\r\n    }\r\n    if (equation.a === 0 && equation.b === 0) {\r\n      if (equation.d !== 0) {\r\n        const tempX = getRandomValue(MIN, MAX);\r\n        return {\r\n          x: tempX,\r\n          y: (-equation.e - equation.c * tempX) / equation.d,\r\n        };\r\n      }\r\n      else {\r\n        return {\r\n          x: -equation.e / equation.c,\r\n          y: getRandomValue(MIN, MAX),\r\n        };\r\n      }\r\n    }\r\n    else if (equation.a === 1 && equation.b === 1) {\r\n      const centerPoint = {\r\n        a: equation.c / -2,\r\n        b: equation.d / -2,\r\n      };\r\n\r\n      const radius = Math.sqrt(centerPoint.a * centerPoint.a + centerPoint.b * centerPoint.b - equation.e);\r\n\r\n      const randomValueX = getRandomValue(centerPoint.a - radius, centerPoint.a + radius);\r\n\r\n      let solvedValueY = undefined;\r\n      if (isValid(randomValueX)) {\r\n        solvedValueY = calculateQuadraticEquation(\r\n          equation.b,\r\n          equation.d,\r\n          randomValueX * randomValueX + equation.c * randomValueX + equation.e,\r\n        );\r\n      }\r\n\r\n      if (typeof solvedValueY === 'number') {\r\n        return {\r\n          x: randomValueX,\r\n          y: solvedValueY,\r\n        };\r\n      }\r\n      else if (typeof solvedValueY === 'object') {\r\n        return {\r\n          x: randomValueX,\r\n          y: solvedValueY.secondRoot || solvedValueY.firstRoot,\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function generatePointAlignmentInside(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  if (\r\n    isValid(firstPoint) &&\r\n    isValid(firstPoint.x) &&\r\n    isValid(secondPoint) &&\r\n    isValid(secondPoint.x)\r\n  ) {\r\n    const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n    const tempX = (firstPoint.x + secondPoint.x) / getRandomValue(2, 5);\r\n\r\n    if (\r\n      isValid(line) &&\r\n      isValid(line.c) &&\r\n      isValid(line.d) &&\r\n      isValid(line.e) &&\r\n      isValid(tempX)\r\n    ) {\r\n      return {\r\n        x: tempX,\r\n        y: (line.c * tempX + line.e) / -line.d,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport function generatePointAlignmentOutside(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true,\r\n): CoordinateType {\r\n  if (\r\n    isValid(firstPoint) &&\r\n    isValid(firstPoint.x) &&\r\n    isValid(secondPoint) &&\r\n    isValid(secondPoint.x)\r\n  ) {\r\n    const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n    const tempXRight = getRandomValue(secondPoint.x, MAX);\r\n    const tempXLeft = getRandomValue(MIN, firstPoint.x);\r\n\r\n    if (\r\n      isValid(line) &&\r\n      isValid(line.c) &&\r\n      isValid(line.d) &&\r\n      isValid(line.e) &&\r\n      isValid(tempXLeft) &&\r\n      isValid(tempXRight)\r\n    ) {\r\n      return isRight ?\r\n        {\r\n          x: tempXRight,\r\n          y: (line.c * tempXRight + line.e) / -line.d,\r\n        }\r\n        :\r\n        {\r\n          x: tempXLeft,\r\n          y: (line.c * tempXLeft + line.e) / -line.d,\r\n        };\r\n    }\r\n  }\r\n}\r\n\r\nexport function generatePointNotAlignment(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  if (isValid(firstPoint) && isValid(secondPoint)) {\r\n    let resultPoint: CoordinateType = {};\r\n    resultPoint.x = getRandomValue(MIN, MAX);\r\n    const line = getLineFromTwoPoints(firstPoint, secondPoint);\r\n    if (isValid(line) && isValid(line.c) && isValid(line.e)) {\r\n      do {\r\n        resultPoint.y = getRandomValue(MIN, MAX);\r\n      }\r\n      while (resultPoint.y === line.c * resultPoint.x + line.e);\r\n    }\r\n    return resultPoint;\r\n  }\r\n}\r\n\r\nexport function generatePointMiddleTwoPoints(p1: CoordinateType, p2: CoordinateType) {\r\n  if (isValid(p1) && isValid(p2)) {\r\n    const line = getLineFromTwoPoints(p1, p2);\r\n    const randomPoint = generatePointAlignmentInside(p1, p2);\r\n\r\n    const randomLine = calculatePerpendicularLineByPointAndLine(randomPoint, line);\r\n    return getRandomPointInEquation(randomLine);\r\n  }\r\n}\r\n","const env = {\r\n  isDev: true,\r\n};\r\n\r\nlet isOffLog = false;\r\n\r\nexport default class GConfig {\r\n  static offLog() {\r\n    isOffLog = true;\r\n  }\r\n\r\n  static onLog() {\r\n    isOffLog = false;\r\n  }\r\n\r\n  static offEnvDev() {\r\n    env.isDev = false;\r\n  }\r\n\r\n  static onEnvDev() {\r\n    env.isDev = true;\r\n  }\r\n\r\n  static get isDev() {\r\n    return env.isDev;\r\n  }\r\n\r\n  static get env() {\r\n    return env;\r\n  }\r\n  \r\n  static get isOffLog() {\r\n    return isOffLog;\r\n  }\r\n}","import GConfig from './GConfig';\r\n\r\nexport default class GLog {\r\n  static logInfo(moduleName, ...args) {\r\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor) {\r\n      console.info(`[${moduleName.constructor.name}]`, ...args);\r\n    }\r\n  }\r\n\r\n  static logMsg(moduleName, msg, offThis = false) {\r\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor && !offThis) {\r\n      console.log(`[${moduleName.constructor.name}]`, msg);\r\n    }\r\n  }\r\n\r\n  static logMsgWithLineBreaks(moduleName, ...msgs) {\r\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor) {\r\n      let msg = undefined;\r\n      if (Array.isArray(msgs)) {\r\n        msg = msgs.join('\\n ');\r\n      }\r\n      console.log(`[${moduleName.constructor.name}]`, `\\n ${msg}`);\r\n    }\r\n  }\r\n\r\n  static logError(moduleName, error, offThis = false) {\r\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor && !offThis) {\r\n      console.error(`[${moduleName.constructor.name}]`, error);\r\n    }\r\n  }\r\n}","import GConst from '../config/values';\r\nimport type { CalculatedResultType, CircleType, CoordinateType, EquationType, LineType } from '../../utils/types';\r\nimport { convertEquationToLineType, convertLinearToEquation, convertLineTypeToEquation } from './Converter';\r\nimport { getRandomPointInEquation } from './Generation';\r\nimport ErrorService from '../error/ErrorHandleService';\r\nimport { Operation } from './MathOperation';\r\nimport GLog from '../config/GLog';\r\nimport { isValid } from '../utils';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\r\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\r\nconst INFINITY = GConst.String.INFINITY;\r\nconst IMPOSSIBLE = GConst.String.IMPOSSIBLE;\r\nconst NOT_BE_IN_LINE = GConst.String.NOT_BE_IN_LINE;\r\n\r\nconst {\r\n  Add,\r\n  Sub,\r\n  Multiply,\r\n  Divide,\r\n  Sqrt,\r\n  Pow,\r\n  isEqual,\r\n  Compare,\r\n  isZero,\r\n  Abs,\r\n  isSmallerThanZero,\r\n  Round,\r\n  Max\r\n} = Operation;\r\n\r\nfunction _makeRound(num: CalculatedResultType, f: number = 3): number {\r\n  if (typeof num === 'string') {\r\n    return Round(num, f);\r\n  }\r\n  if (!isValid(num)) {\r\n    GLog.logError(this, `${num} is NaN`);\r\n    throw console.error('error', num);\r\n  }\r\n  const myF = Math.pow(10, f);\r\n  return Math.round(num * myF) / myF;\r\n}\r\n\r\nexport function calculateVector(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isMakeRound? = true\r\n): CoordinateType {\r\n  if (\r\n    isValid(firstPoint) &&\r\n    isValid(secondPoint) &&\r\n    isValid(firstPoint.x) &&\r\n    isValid(firstPoint.y) &&\r\n    isValid(secondPoint.x) &&\r\n    isValid(secondPoint.y)\r\n  ) {\r\n    const x = Operation.Sub(secondPoint.x, firstPoint.x);\r\n    const y = Operation.Sub(secondPoint.y, firstPoint.y);\r\n\r\n    if (isMakeRound) {\r\n      return {\r\n        x: _makeRound(x),\r\n        y: _makeRound(y)\r\n      };\r\n    }\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n}\r\n\r\nexport function isVectorSameDirection(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (\r\n    isValid(firstVector) &&\r\n    isValid(secondVector) &&\r\n    isValid(firstVector.x) &&\r\n    isValid(firstVector.y) &&\r\n    isValid(secondVector.x) &&\r\n    isValid(secondVector.y)\r\n  ) {\r\n    if (isZero(firstVector.x)) {\r\n      return (\r\n        isZero(secondVector.x) &&\r\n        isEqual(Divide(firstVector.y, Abs(firstVector.y)), Divide(secondVector.y, Abs(secondVector.y)))\r\n      );\r\n    }\r\n\r\n    if (isZero(firstVector.y)) {\r\n      return (\r\n        isZero(secondVector.y) &&\r\n        isEqual(Divide(firstVector.x, Abs(firstVector.x)), Divide(secondVector.x, Abs(secondVector.x)))\r\n      );\r\n    }\r\n\r\n    if (isZero(secondVector.x)) {\r\n      return (\r\n        isZero(firstVector.x) &&\r\n        isEqual(Divide(firstVector.y, Abs(firstVector.y)), Divide(secondVector.y, Abs(secondVector.y)))\r\n      );\r\n    }\r\n\r\n    if (isZero(secondVector.y)) {\r\n      return (\r\n        isZero(firstVector.y) &&\r\n        isEqual(Divide(firstVector.x, Abs(firstVector.x)), Divide(secondVector.x, Abs(secondVector.x)))\r\n      );\r\n    }\r\n\r\n    return (\r\n      isEqual(Divide(firstVector.x, Abs(firstVector.x)), Divide(secondVector.x, Abs(secondVector.x))) &&\r\n      isEqual(Divide(firstVector.y, Abs(firstVector.y)), Divide(secondVector.y, Abs(secondVector.y))) &&\r\n      isEqual(_makeRound(Multiply(firstVector.x, secondVector.y)), _makeRound(Multiply(firstVector.y, secondVector.x)))\r\n    );\r\n  }\r\n}\r\n\r\nexport function isVectorInSameLine(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\r\n  if (\r\n    isValid(firstVector) &&\r\n    isValid(secondVector) &&\r\n    isValid(firstVector.x) &&\r\n    isValid(firstVector.y) &&\r\n    isValid(secondVector.x) &&\r\n    isValid(secondVector.y)\r\n  ) {\r\n    if (isZero(firstVector.x)) {\r\n      return isZero(secondVector.x);\r\n    }\r\n\r\n    if (isZero(firstVector.y)) {\r\n      return isZero(secondVector.y);\r\n    }\r\n\r\n    if (isZero(secondVector.x)) {\r\n      return isZero(firstVector.x);\r\n    }\r\n\r\n    if (isZero(secondVector.y)) {\r\n      return isZero(firstVector.y);\r\n    }\r\n\r\n    return isEqual(\r\n      _makeRound(Multiply(firstVector.x, secondVector.y)),\r\n      _makeRound(Multiply(firstVector.y, secondVector.x))\r\n    );\r\n  }\r\n}\r\n\r\nexport function calculateMiddlePoint(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\r\n  if (\r\n    isValid(firstPoint) &&\r\n    isValid(secondPoint) &&\r\n    isValid(firstPoint.x) &&\r\n    isValid(firstPoint.y) &&\r\n    isValid(secondPoint.x) &&\r\n    isValid(secondPoint.y)\r\n  ) {\r\n    const x = Divide(Add(firstPoint.x, secondPoint.x), 2);\r\n    const y = Divide(Add(firstPoint.y, secondPoint.y), 2);\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n}\r\n\r\nexport function calculateSymmetricalPoint(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType,\r\n  isRight: boolean = true\r\n): CoordinateType {\r\n  if (\r\n    isValid(firstPoint) &&\r\n    isValid(secondPoint) &&\r\n    isValid(firstPoint.x) &&\r\n    isValid(firstPoint.y) &&\r\n    isValid(secondPoint.x) &&\r\n    isValid(secondPoint.y)\r\n  ) {\r\n    return isRight\r\n      ? {\r\n          x: Sub(Multiply(2, secondPoint.x), firstPoint.x),\r\n          y: Sub(Multiply(2, secondPoint.y), firstPoint.y)\r\n        }\r\n      : {\r\n          x: Sub(Multiply(2, firstPoint.x), secondPoint.x),\r\n          y: Sub(Multiply(2, firstPoint.y), secondPoint.y)\r\n        };\r\n  }\r\n}\r\n\r\nexport function getLineFromTwoPoints(p1: CoordinateType, p2: CoordinateType): EquationType {\r\n  if (isValid(p1) && isValid(p2) && isValid(p1.x) && isValid(p1.y) && isValid(p2.x) && isValid(p2.y)) {\r\n    const directionVector = {\r\n      a: Sub(p2.x, p1.x),\r\n      b: Sub(p2.y, p1.y)\r\n    };\r\n    const normalVector = {\r\n      a: Sub(0, directionVector.b),\r\n      b: directionVector.a\r\n    };\r\n\r\n    return {\r\n      a: 0,\r\n      b: 0,\r\n      c: normalVector.a,\r\n      d: normalVector.b,\r\n      //-normalVector.a * p1.x - normalVector.b * p1.y\r\n      e: Sub(Multiply(Sub(0, normalVector.a), p1.x), Multiply(normalVector.b, p1.y))\r\n    };\r\n  }\r\n}\r\n\r\nexport function calculateParallelEquation(equation: EquationType): EquationType {\r\n  if (isValid(equation) && isValid(equation.c) && isValid(equation.d)) {\r\n    // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n    const e = Math.floor(Math.random() * 100) - MAX;\r\n\r\n    let parallelEquation: EquationType = {};\r\n    parallelEquation.c = equation.c;\r\n    parallelEquation.d = equation.d;\r\n    parallelEquation.e = e;\r\n\r\n    return parallelEquation;\r\n  }\r\n}\r\n\r\nexport function calculatePerpendicularEquation(equation: EquationType): EquationType {\r\n  if (isValid(equation) && isValid(equation.c) && isValid(equation.d)) {\r\n    // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\r\n    const e = Math.floor(Math.random() * 100) - MIN;\r\n\r\n    let perpendicularEquation: EquationType = {};\r\n    perpendicularEquation.c = Sub(0, equation.c);\r\n    perpendicularEquation.d = equation.d;\r\n    perpendicularEquation.e = e;\r\n\r\n    return perpendicularEquation;\r\n  }\r\n}\r\n\r\nexport function calculateDistanceTwoPoints(\r\n  firstPoint: CoordinateType,\r\n  secondPoint: CoordinateType\r\n): CalculatedResultType {\r\n  if (\r\n    isValid(firstPoint) &&\r\n    isValid(secondPoint) &&\r\n    isValid(firstPoint.x) &&\r\n    isValid(firstPoint.y) &&\r\n    isValid(secondPoint.x) &&\r\n    isValid(secondPoint.y)\r\n  ) {\r\n    const squareX = Pow(Sub(secondPoint.x, firstPoint.x), 2);\r\n    const squareY = Pow(Sub(secondPoint.y, firstPoint.y), 2);\r\n    return Sqrt(Add(squareX, squareY));\r\n  }\r\n}\r\n\r\nexport function calculateDistanceFromPointToLine(point: CoordinateType, line: EquationType): CalculatedResultType {\r\n  if (\r\n    isValid(point) &&\r\n    isValid(line) &&\r\n    isValid(point.x) &&\r\n    isValid(point.y) &&\r\n    isValid(line.c) &&\r\n    isValid(line.d) &&\r\n    isValid(line.e)\r\n  ) {\r\n    let numerator = Abs(Add(Add(Multiply(line.c, point.x), Multiply(line.d, point.y)), line.e));\r\n    let denominator = Sqrt(Add(Pow(line.c, 2), Pow(line.d, 2)));\r\n\r\n    if (isZero(denominator)) {\r\n      GLog.logError(this, 'calculateDistanceFromPointToLine: mẫu số bằng 0');\r\n      ErrorService.showError(200);\r\n      return {};\r\n    }\r\n    return Divide(numerator, denominator);\r\n  }\r\n}\r\n\r\nexport function calculateParallelLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  if (isValid(point) && isValid(point.x) && isValid(point.y) && isValid(line) && isValid(line.d)) {\r\n    // parallel line has `a` coefficient equals the other line.\r\n    // parallel line's e = -ax - y with (x,y) is coordinate of the point\r\n    const lineEquation = convertEquationToLineType(line);\r\n    const parLine: LineType = {};\r\n    parLine.a = lineEquation.a;\r\n    parLine.b = Sub(point.y, Multiply(lineEquation.a, point.x));\r\n\r\n    let result = convertLineTypeToEquation(parLine);\r\n    if (isZero(line.d)) {\r\n      result.d = line.d;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nexport function calculatePerpendicularLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\r\n  if (isValid(point) && isValid(point.x) && isValid(point.y) && isValid(line) && isValid(line.c) && isValid(line.d)) {\r\n    let perpendicularLine: EquationType = {};\r\n\r\n    // perpendicular line has the direction vector is opposite pairs with the other line.\r\n    // perpendicular line's e = -ax - y with (x,y) is coordinate of the point\r\n    if (isZero(line.c)) {\r\n      perpendicularLine.c = Divide(-1, line.d);\r\n      perpendicularLine.d = 0;\r\n      perpendicularLine.e = -perpendicularLine.c * point.x;\r\n    } else if (isZero(line.d)) {\r\n      perpendicularLine.c = 0;\r\n      perpendicularLine.d = Divide(-1, line.c);\r\n      perpendicularLine.e = Multiply(Sub(0, perpendicularLine.d), point.y);\r\n    } else {\r\n      const lineEquation = convertEquationToLineType(line);\r\n      const perLine: LineType = {};\r\n      perLine.a = Divide(-1, lineEquation.a);\r\n      perLine.b = Add(point.y, Divide(point.x, lineEquation.a));\r\n      perpendicularLine = convertLineTypeToEquation(perLine);\r\n    }\r\n    return perpendicularLine;\r\n  }\r\n}\r\n\r\nexport function calculateIntersectionByLineAndLine(lineOne: EquationType, lineTwo: EquationType): CoordinateType {\r\n  if (\r\n    isValid(lineOne) &&\r\n    isValid(lineOne.c) &&\r\n    isValid(lineOne.d) &&\r\n    isValid(lineOne.e) &&\r\n    isValid(lineTwo) &&\r\n    isValid(lineTwo.c) &&\r\n    isValid(lineTwo.d) &&\r\n    isValid(lineTwo.e)\r\n  ) {\r\n    let r = calculateSetOfEquationTypeAndQuadraticEquation(\r\n      {\r\n        c: lineOne.c,\r\n        d: lineOne.d,\r\n        e: lineOne.e\r\n      },\r\n      {\r\n        a: 0,\r\n        b: 0,\r\n        c: lineTwo.c,\r\n        d: lineTwo.d,\r\n        e: lineTwo.e\r\n      }\r\n    );\r\n\r\n    if (Array.isArray(r)) {\r\n      if (r.length === 0) {\r\n        return [];\r\n      } else {\r\n        return r[0];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateCircleEquationByCenterPoint(\r\n  centerPoint: CoordinateType,\r\n  radius: CalculatedResultType\r\n): EquationType {\r\n  if (isValid(centerPoint) && isValid(centerPoint.x) && isValid(centerPoint.y) && isValid(radius)) {\r\n    //const roundedRadius = _makeRound(radius, 6);\r\n    return {\r\n      a: 1,\r\n      b: 1,\r\n      c: Multiply(-2, centerPoint.x),\r\n      d: Multiply(-2, centerPoint.y),\r\n      //centerPoint.x * centerPoint.x + centerPoint.y * centerPoint.y - radius * radius\r\n      e: Sub(Add(Pow(centerPoint.x, 2), Pow(centerPoint.y, 2)), Pow(radius, 2))\r\n    };\r\n  }\r\n}\r\n\r\nexport function calculateInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType\r\n): EquationType {\r\n  if (isValid(lineOne) && isValid(lineTwo) && isValid(pointOne) && isValid(pointTwo)) {\r\n    const results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n    const firstLine: EquationType = results[0];\r\n    const secondLine: EquationType = results[1];\r\n\r\n    // const pointInFirstLine: CoordinateType = getRandomPointInLine(lineOne);\r\n    // let pointInSecondLine: CoordinateType = { x: pointInFirstLine.x, y: undefined };\r\n    // if (lineTwo.d !== 0) {\r\n    //   pointInSecondLine.y = (-lineTwo.e - lineTwo.c * pointInSecondLine.x) / lineTwo.d;\r\n    // } else {\r\n    //   pointInSecondLine.y = getRandomValue(MIN_RANDOM_NUMBER, MAX_RANDOM_NUMBER);\r\n    // }\r\n\r\n    if (isZero(getAngleFromTwoLines(lineOne, lineTwo))) {\r\n      throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n    }\r\n    return _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n  }\r\n}\r\n\r\nexport function calculateExternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType\r\n): EquationType {\r\n  if (isValid(lineOne) && isValid(lineTwo) && isValid(pointOne) && isValid(pointTwo)) {\r\n    let results = _calculateBisectLineEquation(lineOne, lineTwo);\r\n    const firstLine: EquationType = results[0];\r\n    const secondLine: EquationType = results[1];\r\n\r\n    if (isZero(getAngleFromTwoLines(lineOne, lineTwo))) {\r\n      throw new Map().set('error', 'không hỗ trợ trường hợp này');\r\n    }\r\n\r\n    const internalLine = _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\r\n\r\n    results = results.filter((line: EquationType): boolean => JSON.stringify(line) !== JSON.stringify(internalLine));\r\n    return results[0];\r\n  }\r\n}\r\n\r\nfunction _calculateBisectLineEquation(lineOne: EquationType, lineTwo: EquationType): [EquationType, EquationType] {\r\n  if (\r\n    isValid(lineOne) &&\r\n    isValid(lineOne.c) &&\r\n    isValid(lineOne.d) &&\r\n    isValid(lineOne.e) &&\r\n    isValid(lineTwo) &&\r\n    isValid(lineTwo.c) &&\r\n    isValid(lineTwo.d) &&\r\n    isValid(lineTwo.e)\r\n  ) {\r\n    let resultOne: EquationType = {};\r\n    let resultTwo: EquationType = {};\r\n\r\n    // ax + by + c = +/- [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')] * (a'x + b'y + c)\r\n\r\n    // check if denominator equals 0\r\n    if (isZero(lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d)) {\r\n      GLog.logError(this, 'calculateDistanceFromPointToLine: mẫu số bằng 0');\r\n      ErrorService.showError(200);\r\n      return [];\r\n    }\r\n\r\n    // Represent for [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')]\r\n    //   Math.sqrt(lineOne.c * lineOne.c + lineOne.d * lineOne.d)\r\n    //  /Math.sqrt(lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d);\r\n\r\n    let coefficient = Divide(\r\n      Sqrt(Add(Multiply(lineOne.c, lineOne.c), Multiply(lineOne.d, lineOne.d))),\r\n      Sqrt(Add(Multiply(lineTwo.c, lineTwo.c), Multiply(lineTwo.d, lineTwo.d)))\r\n    );\r\n\r\n    /*\r\n     * Two results:\r\n     *    (a - coefficient*a')x + (b - coefficient*b')y + c - coefficient*c' = 0\r\n     *    (a + coefficient*a')x + (b + coefficient*b')y + c + coefficient*c' = 0\r\n     */\r\n    resultOne.c = Sub(lineOne.c, Multiply(coefficient, lineTwo.c));\r\n    resultOne.d = Sub(lineOne.d, Multiply(coefficient, lineTwo.d));\r\n    resultOne.e = Sub(lineOne.e, Multiply(coefficient, lineTwo.e));\r\n\r\n    resultTwo.c = Add(lineOne.c, Multiply(coefficient, lineTwo.c));\r\n    resultTwo.d = Add(lineOne.d, Multiply(coefficient, lineTwo.d));\r\n    resultTwo.e = Add(lineOne.e, Multiply(coefficient, lineTwo.e));\r\n\r\n    return [resultOne, resultTwo];\r\n  }\r\n}\r\n\r\n/*\r\n *   Line one and line two is 2 lines are the result of _calculateBisectLineEquation function\r\n *   Point one and point two are 2 points that each point located in each line\r\n *             which is equivalent each argument in _calculateBisectLineEquation function\r\n */\r\nfunction _getInternalBisectLineEquation(\r\n  lineOne: EquationType,\r\n  lineTwo: EquationType,\r\n  pointOne: CoordinateType,\r\n  pointTwo: CoordinateType\r\n): EquationType {\r\n  if (\r\n    isValid(lineOne) &&\r\n    isValid(lineOne.c) &&\r\n    isValid(lineOne.d) &&\r\n    isValid(lineOne.e) &&\r\n    isValid(lineTwo) &&\r\n    isValid(pointOne) &&\r\n    isValid(pointOne.x) &&\r\n    isValid(pointOne.y) &&\r\n    isValid(pointTwo) &&\r\n    isValid(pointTwo.x) &&\r\n    isValid(pointTwo.y)\r\n  ) {\r\n    //pointOne.x * lineOne.c + pointOne.y * lineOne.d + lineOne.e\r\n    let firstEquation = Add(Add(Multiply(pointOne.x, lineOne.c), Multiply(pointOne.y, lineOne.d)), lineOne.e);\r\n    let secondEquation = Add(Add(Multiply(pointTwo.x, lineOne.c), Multiply(pointTwo.y, lineOne.d)), lineOne.e);\r\n    return Compare(Multiply(firstEquation, secondEquation), 0) > 0 ? lineTwo : lineOne;\r\n  }\r\n}\r\n\r\n// TODO: Uncheck\r\nexport function calculateSetOfEquationTypes(d1: EquationType, d2: EquationType) {\r\n  if (\r\n    isValid(d1) &&\r\n    isValid(d1.c) &&\r\n    isValid(d1.d) &&\r\n    isValid(d1.e) &&\r\n    isValid(d2) &&\r\n    isValid(d2.c) &&\r\n    isValid(d2.d) &&\r\n    isValid(d2.e)\r\n  ) {\r\n    if (\r\n      (isZero(d1.c) && isZero(d2.c)) ||\r\n      (isZero(d1.d) && isZero(d2.d)) ||\r\n      (isZero(d1.c) && isZero(d1.d)) ||\r\n      (isZero(d2.c) && isZero(d2.d))\r\n    ) {\r\n      GLog.logMsg(this, d1, d2, IMPOSSIBLE);\r\n      return {};\r\n    }\r\n    if (isZero(d1.c) && isZero(d2.d)) {\r\n      return {\r\n        x: Sub(0, Divide(d2.e, d2.c)),\r\n        y: Sub(0, Divide(d1.e, d1.d))\r\n      };\r\n    }\r\n    if (isZero(d2.c) && isZero(d1.d)) {\r\n      return {\r\n        x: Sub(0, Divide(d1.e, d1.c)),\r\n        y: Sub(0, Divide(d2.e, d2.d))\r\n      };\r\n    }\r\n    if (isZero(d1.e) && isZero(d2.e)) {\r\n      return {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n    }\r\n\r\n    if (isZero(d1.c)) {\r\n      const tempY = Sub(0, Divide(d1.e, d1.d));\r\n      return {\r\n        //(-d2.e - tempY * d2.d) / d2.c\r\n        x: Sub(0, Divide(Add(d2.e, Multiply(tempY, d2.d)), d2.c)),\r\n        y: tempY\r\n      };\r\n    }\r\n\r\n    if (isZero(d1.d)) {\r\n      const tempX = Sub(0, Divide(d1.e, d1.c));\r\n      return {\r\n        x: tempX,\r\n        y: Sub(0, Divide(Add(d2.e, Multiply(tempX, d2.c)), d2.d))\r\n      };\r\n    }\r\n\r\n    if (isZero(d2.c)) {\r\n      const tempY = Sub(0, Divide(d2.e, d2.d));\r\n      return {\r\n        x: Sub(0, Divide(Add(d1.e, Multiply(tempY, d1.d)), d1.c)),\r\n        y: tempY\r\n      };\r\n    }\r\n\r\n    if (isZero(d2.d)) {\r\n      const tempX = Sub(0, Divide(d2.e, d2.c));\r\n      return {\r\n        x: tempX,\r\n        y: Sub(0, Divide(Add(d1.e, Multiply(tempX, d1.c)), d1.d))\r\n      };\r\n    }\r\n\r\n    //(d1.e * d2.c - d1.c * d2.e) / (d1.d * d2.c - d1.c * d2.d)\r\n    const tempY = Divide(\r\n      Sub(Multiply(d1.e, d2.c), Multiply(d1.c * d2.e)),\r\n      Sub(Multiply(d1.d, d2.c), Multiply(d1.c * d2.d))\r\n    );\r\n\r\n    return {\r\n      x: Sub(0, Divide(Add(d1.e, Multiply(tempY, d1.d)), d1.c)),\r\n      y: tempY\r\n    };\r\n  }\r\n}\r\n\r\n/*\r\n *  Find point(s) of intersection between a linear equation and a circle equation.\r\n *  @params:\r\n *        + d (EquationType): a line.\r\n *        + c (CircleEquation): a circle.\r\n *  @return:\r\n *        + IMPOSSIBLE: if distance from center point of the circle to the line is greater than the radius.\r\n *        + (Array<Object>): if the line intersects the circle.\r\n *          + length = 1;\r\n *          + length = 2;\r\n */\r\nexport function calculateIntersectionEquationTypeWithCircleEquation(d: EquationType, q: EquationType): Array<Object> {\r\n  if (isValid(d) && isValid(q) && isValid(q.c) && isValid(q.d) && isValid(q.e)) {\r\n    const A = Divide(q.c, -2);\r\n    const B = Divide(q.d, -2);\r\n    const centerPoint: CoordinateType = {\r\n      x: A,\r\n      y: B\r\n    };\r\n    const distanceFromCenterPointToLine = calculateDistanceFromPointToLine(centerPoint, d);\r\n\r\n    if (Compare(distanceFromCenterPointToLine, Sqrt(Sub(Add(Pow(A, 2), Pow(B, 2)), q.e))) > 0) {\r\n      GLog.logMsgWithLineBreaks(this, d, q, IMPOSSIBLE);\r\n      return [];\r\n    } else {\r\n      return calculateSetOfEquationTypeAndQuadraticEquation(d, q);\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n * Solves a quadratic equation. This equation is defined: Ax2 + Bx + C = 0.\r\n *\r\n *  @params:\r\n *        + a (number): represents x's coefficient.\r\n *        + b (number): represents y's coefficient.\r\n *        + c (number): represents constant term.\r\n * @return:\r\n *        + IMPOSSIBLE (string): if the equation is no root.\r\n *        + (number): if the equation has only ONE root.\r\n *        + x1, x2 (Object): if the equation has TWO root.\r\n */\r\nexport function calculateQuadraticEquation(\r\n  a: CalculatedResultType,\r\n  b: CalculatedResultType,\r\n  c: CalculatedResultType\r\n): CalculatedResultType {\r\n  if (isValid(a) && isValid(b) && isValid(c)) {\r\n    const delta = Sub(Pow(b, 2), Multiply(4, Multiply(a, c)));\r\n\r\n    let firstRoot,\r\n      secondRoot: CalculatedResultType = undefined;\r\n\r\n    if (isZero(a)) {\r\n      if (isZero(b)) {\r\n        return [];\r\n      }\r\n      return [Sub(0, Divide(c, b))];\r\n    } else if (isSmallerThanZero(delta)) {\r\n      return [];\r\n    } else if (isZero(delta)) {\r\n      return [Sub(0, Divide(b, Multiply(2, a)))];\r\n    } else {\r\n      firstRoot = Divide(Add(Sub(0, b), Sqrt(delta)), Multiply(2, a));\r\n      secondRoot = Divide(Sub(Sub(0, b), Sqrt(delta)), Multiply(2, a));\r\n      return [firstRoot, secondRoot];\r\n    }\r\n  }\r\n}\r\n\r\n// Ax2 + By2 + Cx + Dy + E = 0\r\nexport function isIn(p: CoordinateType, e: EquationType): boolean {\r\n  if (\r\n    isValid(p) &&\r\n    isValid(p.x) &&\r\n    isValid(p.y) &&\r\n    isValid(e) &&\r\n    isValid(e.a) &&\r\n    isValid(e.b) &&\r\n    isValid(e.c) &&\r\n    isValid(e.d) &&\r\n    isValid(e.e)\r\n  ) {\r\n    if (p.x === undefined || p.y === undefined) {\r\n      return false;\r\n    }\r\n    if (e.a === undefined) {\r\n      e = convertLinearToEquation(e);\r\n    }\r\n    const temp = Add(\r\n      Add(Add(Multiply(e.a, Pow(p.x, 2)), Multiply(e.b, Pow(p.y, 2))), Add(Multiply(e.c, p.x), Multiply(e.d, p.y))),\r\n      e.e\r\n    );\r\n    return isZero(Round(temp));\r\n  }\r\n}\r\n\r\n/*\r\n *  Solves a set of a linear equation and quadratic equation.\r\n *  Linear equation is defined:     Ax + By + C = 0.\r\n *  Quadratic equation is defined:  Ax2 + By2 + Cx + Dy + E = 0.\r\n *\r\n *  @params:\r\n *        + l (EquationType): represents a linear equation.\r\n *        + q (QuadraticEquation): represents a quadratic equation.\r\n *  @return:\r\n *        + IMPOSSIBLE (string): if the set is no root.\r\n *        + (number): if the set has only ONE root.\r\n *        + x1, x2 (Object): if the set has TWO root.\r\n */\r\nexport function calculateSetOfEquationTypeAndQuadraticEquation(l: EquationType, q: EquationType): Array<Object> {\r\n  if (\r\n    isValid(l) &&\r\n    isValid(l.c) &&\r\n    isValid(l.d) &&\r\n    isValid(l.e) &&\r\n    isValid(q) &&\r\n    isValid(q.a) &&\r\n    isValid(q.b) &&\r\n    isValid(q.c) &&\r\n    isValid(q.d) &&\r\n    isValid(q.e)\r\n  ) {\r\n    let results: Array<Object> = [];\r\n    let u, v, w;\r\n\r\n    const A = l.c;\r\n    const B = l.d;\r\n    const C = l.e;\r\n    const D = q.a;\r\n    const E = q.b;\r\n    const F = q.c;\r\n    const G = q.d;\r\n    const H = q.e;\r\n\r\n    if (!isZero(A)) {\r\n      //A * A * E + D * B * B\r\n      u = Add(Multiply(Pow(A, 2), E), Multiply(Pow(B, 2), D));\r\n      //2 * B * C * D - A * B * F + A * A * G\r\n      v = Add(Sub(Multiply(Multiply(2, B), Multiply(C, D)), Multiply(A, Multiply(B, F))), Multiply(Pow(A, 2), G));\r\n\r\n      //D * C * C - A * C * F + A * A * H\r\n      w = Sub(Add(Multiply(D, Pow(C, 2)), Multiply(H, Pow(A, 2))), Multiply(A, Multiply(C, F)));\r\n\r\n      // solves x. Unneeded check IMPOSSIBLE.\r\n      const root = calculateQuadraticEquation(u, v, w);\r\n      if (Array.isArray(root) && root.length === 1) {\r\n        results.push({\r\n          x: Divide(Sub(0, Add(C, Multiply(B, root[0]))), A),\r\n          y: root[0]\r\n        });\r\n      } else if (Array.isArray(root) && root.length === 0) {\r\n        return [];\r\n      } else {\r\n        const r1 = root[0];\r\n        const r2 = root[1];\r\n        results.push(\r\n          {\r\n            x: Divide(Sub(0, Add(C, Multiply(B, r1))), A),\r\n            y: r1\r\n          },\r\n          {\r\n            x: Divide(Sub(0, Add(C, Multiply(B, r2))), A),\r\n            y: r2\r\n          }\r\n        );\r\n      }\r\n    } else {\r\n      //q.a * l.d * l.d\r\n      u = Multiply(q.a, Pow(l.d, 2));\r\n      //q.c * l.d * l.d\r\n      v = Multiply(q.c, Pow(l.d, 2));\r\n      //q.b * l.e * l.e - q.d * l.d * l.e + q.e * l.d * l.d\r\n      w = Add(\r\n        Sub(Multiply(q.b, Pow(l.e, 2)), Multiply(Multiply(q.d, l.d), Multiply(q.e, l.e))),\r\n        Multiply(q.e, Pow(l.d, 2))\r\n      );\r\n      // solves x. Unneeded check IMPOSSIBLE.\r\n      const root = calculateQuadraticEquation(u, v, w);\r\n\r\n      if (Array.isArray(root) && root.length === 1) {\r\n        results.push({\r\n          x: root[0],\r\n          y: Divide(Sub(0, l.e), l.d)\r\n        });\r\n      } else if (Array.isArray(root) && root.length === 0) {\r\n        return [];\r\n      } else {\r\n        results.push(\r\n          {\r\n            x: root[0],\r\n            y: Divide(Sub(0, l.e), l.d)\r\n          },\r\n          {\r\n            x: root[1],\r\n            y: Divide(Sub(0, l.e), l.d)\r\n          }\r\n        );\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n}\r\n\r\nexport function calculateIntersectionTwoCircleEquations(firstEquation: EquationType, secondEquation: EquationType) {\r\n  if (isValid(firstEquation) && isValid(secondEquation)) {\r\n    let results: Array<Object> = [];\r\n    if (!firstEquation || !secondEquation) {\r\n      return [];\r\n    }\r\n    let q1, q2;\r\n    firstEquation.a === undefined ? (q1 = convertLinearToEquation(firstEquation)) : (q1 = firstEquation);\r\n    secondEquation.a === undefined ? (q2 = convertLinearToEquation(secondEquation)) : (q2 = secondEquation);\r\n\r\n    if (!isEqual(q1.a, q2.a) && !isEqual(q1.b, q2.b)) {\r\n      if (isZero(q1.a) && isZero(q1.b)) {\r\n        // q2 is a quadratic equation\r\n        return calculateIntersectionEquationTypeWithCircleEquation(q1, q2);\r\n      } else {\r\n        // q1 is a quadratic equation\r\n        return calculateIntersectionEquationTypeWithCircleEquation(q2, q1);\r\n      }\r\n    } else if (isZero(q1.a) && isZero(q1.b) && isZero(q2.a) && isZero(q2.b)) {\r\n      results.push(calculateSetOfEquationTypes(q1, q2));\r\n    } else {\r\n      // a x2 + b y2 + Ax + By + C = 0\r\n      // a'x2 + b'y2 + Dx + Ey + G = 0\r\n      const D = q2.c;\r\n      const E = q2.d;\r\n      const G = q2.e;\r\n\r\n      // Z = a - a'\r\n      const Z = Compare(q1.a, q2.a) > 0 ? q1.a : q2.a;\r\n      const _D = isEqual(Z, q1.a) ? q1.c : D;\r\n      const _E = isEqual(Z, q1.a) ? q1.d : E;\r\n      const _G = isEqual(Z, q1.a) ? q1.e : G;\r\n\r\n      const a = isEqual(Z, q1.a) ? Sub(q1.c, D) : Sub(D, q1.c);\r\n      const b = isEqual(Z, q1.a) ? Sub(q1.d, E) : Sub(E, q1.d);\r\n      const c = isEqual(Z, q1.a) ? Sub(q1.e, G) : Sub(G, q1.e);\r\n\r\n      if (isZero(a) || isZero(b)) {\r\n        GLog.logMsgWithLineBreaks(this, 'a = 0 || b = 0', firstEquation, secondEquation, IMPOSSIBLE);\r\n        return [];\r\n      } else {\r\n        const u = Multiply(Z, Add(Pow(b, 2), Pow(a, 2)));\r\n        // 2 * b * c * Z - _D * a * b + _E * a * a\r\n        const v = Sub(\r\n          Add(Multiply(Multiply(2, b), Multiply(c, Z)), Multiply(_E, Pow(a, 2))),\r\n          Multiply(_D, Multiply(a, b))\r\n        );\r\n        //Z * c * c - _D * a * c + _G * a * a\r\n        const w = Sub(Add(Multiply(Z, Pow(c, 2)), Multiply(_G, Pow(a, 2))), Multiply(_D, Multiply(a, c)));\r\n\r\n        const roots = calculateQuadraticEquation(u, v, w);\r\n        if (roots === []) {\r\n          GLog.logMsgWithLineBreaks(this, firstEquation, secondEquation, IMPOSSIBLE);\r\n          return roots;\r\n        } else if (Array.isArray(roots) && roots.length === 1) {\r\n          results.push({\r\n            x: Divide(Sub(0, Add(c, Multiply(b, roots))), a),\r\n            y: roots[0]\r\n          });\r\n        } else {\r\n          if (isValid(roots) && isValid(roots[0]) && isValid(roots[1])) {\r\n            const r1 = roots[0];\r\n            const r2 = roots[1];\r\n            results.push(\r\n              {\r\n                x: Divide(Sub(0, Add(c, Multiply(b, r1))), a),\r\n                y: r1\r\n              },\r\n              {\r\n                x: Divide(Sub(0, Add(c, Multiply(b, r2))), a),\r\n                y: r2\r\n              }\r\n            );\r\n          }\r\n        }\r\n      }\r\n      return results;\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateLinesByAnotherLineAndAngle(\r\n  rootPoint: CoordinateType,\r\n  staticPoint: CoordinateType,\r\n  dynamicPoint: CoordinateType,\r\n  angle: number\r\n): EquationType {\r\n  if (isValid(rootPoint) && isValid(staticPoint) && isValid(dynamicPoint) && isValid(angle)) {\r\n    const equations = _calculateLinesByAnotherLineAndAngle(\r\n      getLineFromTwoPoints(rootPoint, staticPoint),\r\n      dynamicPoint,\r\n      angle\r\n    );\r\n    let index = 0;\r\n    const newRootPoints = equations\r\n      .map((equation: EquationType): CoordinateType => {\r\n        return calculateIntersectionByLineAndLine(getLineFromTwoPoints(rootPoint, staticPoint), equation);\r\n      })\r\n      .filter((newRootPoint: CoordinateType, i): boolean => {\r\n        const staticVector = calculateVector(rootPoint, staticPoint, false);\r\n        const dynamicVector = calculateVector(newRootPoint, dynamicPoint, false);\r\n        const result = calculateAngleTwoVector(staticVector, dynamicVector) === parseInt(angle);\r\n        if (result) {\r\n          index = i;\r\n        }\r\n        return result;\r\n      });\r\n    if (newRootPoints[0]) {\r\n      return equations[index];\r\n    }\r\n\r\n    ErrorService.showError('500');\r\n    return {};\r\n  }\r\n}\r\n\r\nfunction calculateIntegratedDirection(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  if (\r\n    isValid(vectorOne) &&\r\n    isValid(vectorOne.x) &&\r\n    isValid(vectorOne.y) &&\r\n    isValid(vectorTwo) &&\r\n    isValid(vectorTwo.x) &&\r\n    isValid(vectorTwo.y)\r\n  ) {\r\n    return Add(Multiply(vectorOne.x, vectorTwo.x), Multiply(vectorOne.y, vectorTwo.y));\r\n  }\r\n}\r\n\r\nfunction calculateVectorLength(vector: CoordinateType): number {\r\n  if (isValid(vector) && isValid(vector.x) && isValid(vector.y)) {\r\n    return Sqrt(Add(Pow(vector.x, 2), Pow(vector.y, 2)));\r\n  }\r\n}\r\n\r\nexport function calculateAngleTwoVector(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\r\n  if (\r\n    isValid(vectorOne) &&\r\n    isValid(vectorOne.x) &&\r\n    isValid(vectorOne.y) &&\r\n    isValid(vectorTwo) &&\r\n    isValid(vectorTwo.x) &&\r\n    isValid(vectorTwo.y)\r\n  ) {\r\n    if ((isZero(vectorOne.x) && isZero(vectorOne.y)) || (isZero(vectorTwo.x) && isZero(vectorTwo.y))) {\r\n      return 0;\r\n    }\r\n    return Round(\r\n      `(acos(\r\n     ${Divide(\r\n       calculateIntegratedDirection(vectorOne, vectorTwo),\r\n       Multiply((calculateVectorLength(vectorOne), calculateVectorLength(vectorTwo)))\r\n     )})*180)/PI`,\r\n      1\r\n    );\r\n  }\r\n}\r\n\r\nexport function _calculateLinesByAnotherLineAndAngle(d: EquationType, p: CoordinateType, angle: number) {\r\n  if (isValid(d) && isValid(d.c) && isValid(d.d) && isValid(p) && isValid(p.x) && isValid(p.y) && isValid(angle)) {\r\n    let results: Array<EquationType> = [];\r\n\r\n    const cosine = `cos((${angle} * PI) / 180)`;\r\n    //d.c * d.c - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d\r\n    const A = Sub(Sub(Pow(d.c, 2), Multiply(Pow(cosine, 2), Pow(d.c, 2)), Multiply(Pow(cosine, 2), Pow(d.d, 2))));\r\n    const B = Multiply(2, Multiply(d.c, d.d));\r\n    //d.d * d.d - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\r\n    const C = Sub(Sub(Pow(d.d, 2), Multiply(Pow(cosine, 2), Pow(d.c, 2)), Multiply(Pow(cosine, 2), Pow(d.d, 2))));\r\n    const root = calculateQuadraticEquation(A, B, C);\r\n\r\n    if (Array.isArray(root) && root.length === 1) {\r\n      results.push({\r\n        c: root[0],\r\n        d: 1,\r\n        e: Sub(0, Add(Multiply(root[0], p.x), p.y))\r\n      });\r\n    } else if (root === []) {\r\n      GLog.logMsgWithLineBreaks(this, d, p, angle, IMPOSSIBLE);\r\n      return root;\r\n    } else {\r\n      if (isValid(root) && isValid(root[0]) && isValid(root[1])) {\r\n        results.push(\r\n          {\r\n            c: root[0],\r\n            d: 1,\r\n            //-root.firstRoot * p.x - p.y\r\n            e: Sub(0, Add(Multiply(root[0], p.x), p.y))\r\n          },\r\n          {\r\n            c: root[1],\r\n            d: 1,\r\n            e: Sub(0, Add(Multiply(root[1], p.x), p.y))\r\n          }\r\n        );\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n}\r\n\r\nexport function makeRoundCoordinate(point: CoordinateType, f: number = 3) {\r\n  if (isValid(point)) {\r\n    if (typeof point === 'string') {\r\n      return point;\r\n    }\r\n    if (isValid(point.x) && isValid(point.y)) {\r\n      return {\r\n        x: Round(point.x, f),\r\n        y: Round(point.y, f)\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport function getAngleFromTwoLines(d1: EquationType, d2: EquationType): number {\r\n  if (\r\n    isValid(d1) &&\r\n    isValid(d1.a) &&\r\n    isValid(d1.b) &&\r\n    isValid(d1.c) &&\r\n    isValid(d1.d) &&\r\n    isValid(d1.e) &&\r\n    isValid(d2) &&\r\n    isValid(d2.a) &&\r\n    isValid(d2.b) &&\r\n    isValid(d2.c) &&\r\n    isValid(d2.d) &&\r\n    isValid(d2.e)\r\n  ) {\r\n    if (\r\n      d1.a ||\r\n      d1.b ||\r\n      d2.a ||\r\n      d2.b ||\r\n      (isZero(d1.c) && isZero(d1.d) && isZero(d1.e)) ||\r\n      (isZero(d2.c) && isZero(d2.d) && isZero(d2.e))\r\n    ) {\r\n      return -9999;\r\n    }\r\n\r\n    const a1 = d1.c;\r\n    const a2 = d2.c;\r\n    const b1 = d1.d;\r\n    const b2 = d2.d;\r\n\r\n    const result = `acos(${Divide(\r\n      Abs(Add(Multiply(a1, a2), Multiply(b1, b2))),\r\n      Sqrt(Multiply(Add(Pow(a1, 2), Pow(b1, 2)), Add(Pow(a2, 2), Pow(b2, 2))))\r\n    )} * 180) / PI`;\r\n\r\n    // round result\r\n    return Round(result, 1);\r\n  }\r\n}\r\n\r\nexport function getMiddlePointFromThreePointsInALine(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType\r\n): CoordinateType {\r\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\r\n    const line = getLineFromTwoPoints(p1, p2);\r\n    if (\r\n      !isIn(p3, {\r\n        a: 0,\r\n        b: 0,\r\n        c: line.c,\r\n        d: line.d,\r\n        e: line.e\r\n      })\r\n    ) {\r\n      GLog.logMsgWithLineBreaks(this, p1, p2, p3, NOT_BE_IN_LINE);\r\n      return {};\r\n    }\r\n\r\n    // another way: check vector =)))~\r\n    const dis_p1_p2 = calculateDistanceTwoPoints(p1, p2);\r\n    const dis_p2_p3 = calculateDistanceTwoPoints(p2, p3);\r\n    const dis_p1_p3 = calculateDistanceTwoPoints(p1, p3);\r\n\r\n    const max = Max(dis_p1_p2, dis_p2_p3, dis_p1_p3);\r\n    if (isEqual(dis_p1_p2, max)) {\r\n      return p3;\r\n    } else if (isEqual(dis_p1_p3, max)) {\r\n      return p2;\r\n    } else {\r\n      return p1;\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateCircumCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\r\n    const midperpendicularsLineOne = calculatePerpendicularLineByPointAndLine(\r\n      calculateMiddlePoint(p1, p2),\r\n      getLineFromTwoPoints(p1, p2)\r\n    );\r\n\r\n    const midperpendicularsLineTwo = calculatePerpendicularLineByPointAndLine(\r\n      calculateMiddlePoint(p1, p3),\r\n      getLineFromTwoPoints(p1, p3)\r\n    );\r\n\r\n    if (isValid(midperpendicularsLineOne) && isValid(midperpendicularsLineTwo)) {\r\n      const center = calculateIntersectionByLineAndLine(midperpendicularsLineOne, midperpendicularsLineTwo);\r\n      const radius = calculateDistanceTwoPoints(center, p1);\r\n\r\n      if (isValid(center) && isValid(radius)) {\r\n        const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n        return {\r\n          center,\r\n          radius,\r\n          equation\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateInCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\r\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\r\n    const bisectorLineOne = calculateInternalBisectLineEquation(\r\n      getLineFromTwoPoints(p1, p3),\r\n      getLineFromTwoPoints(p1, p2),\r\n      p2,\r\n      p3\r\n    );\r\n\r\n    const bisectorLineTwo = calculateInternalBisectLineEquation(\r\n      getLineFromTwoPoints(p2, p3),\r\n      getLineFromTwoPoints(p1, p2),\r\n      p1,\r\n      p3\r\n    );\r\n\r\n    if (isValid(bisectorLineOne) && isValid(bisectorLineTwo)) {\r\n      const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n      const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(p1, p3));\r\n\r\n      if (isValid(center) && isValid(radius)) {\r\n        const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n        return {\r\n          center,\r\n          radius,\r\n          equation\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateEscribedCirclesEquation(\r\n  p1: CoordinateType,\r\n  p2: CoordinateType,\r\n  p3: CoordinateType,\r\n  escribedPoint: CoordinateType\r\n): CircleType {\r\n  if (isValid(p1) && isValid(p2) && isValid(p3) && isValid(escribedPoint)) {\r\n    const otherPoints = [p1, p2, p3].filter(\r\n      (point: CoordinateType): boolean => JSON.stringify(point) !== JSON.stringify(escribedPoint)\r\n    );\r\n\r\n    if (isValid(otherPoints)) {\r\n      if (otherPoints.length !== 2) {\r\n        ErrorService.showError('300');\r\n        return {};\r\n      }\r\n\r\n      if (isValid(otherPoints[0] && isValid(otherPoints[1]))) {\r\n        const bisectorLineOne = calculateInternalBisectLineEquation(\r\n          getLineFromTwoPoints(escribedPoint, otherPoints[0]),\r\n          getLineFromTwoPoints(escribedPoint, otherPoints[1]),\r\n          otherPoints[0],\r\n          otherPoints[1]\r\n        );\r\n\r\n        const bisectorLineTwo = calculateExternalBisectLineEquation(\r\n          getLineFromTwoPoints(escribedPoint, otherPoints[0]),\r\n          getLineFromTwoPoints(otherPoints[1], otherPoints[0]),\r\n          escribedPoint,\r\n          otherPoints[1]\r\n        );\r\n        if (isValid(bisectorLineOne) && isValid(bisectorLineTwo)) {\r\n          const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\r\n          const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(otherPoints[1], otherPoints[0]));\r\n\r\n          if (isValid(center) && isValid(radius)) {\r\n            const equation = calculateCircleEquationByCenterPoint(center, radius);\r\n            return {\r\n              center,\r\n              radius,\r\n              equation\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateTangentEquation(circle: EquationType, point?: CoordinateType = null): EquationType {\r\n  if (circle) {\r\n    const tangentPoint: CoordinateType = point || getRandomPointInEquation(circle);\r\n\r\n    const tangentEquation: EquationType = {};\r\n\r\n    const center = {\r\n      x: Divide(circle.c, 2),\r\n      y: Divide(circle.d, 2)\r\n    };\r\n\r\n    tangentEquation.a = 0;\r\n    tangentEquation.b = 0;\r\n    tangentEquation.c = Add(tangentPoint.x, center.x);\r\n    tangentEquation.d = Add(tangentPoint.y, center.y);\r\n    //circle.e + (circle.c * tangentPoint.x) / 2 + (circle.d * tangentPoint.y) / 2\r\n    tangentEquation.e = Add(circle.e, Add(Multiply(tangentPoint.x, center.x), Multiply(tangentPoint.y, center.y)));\r\n\r\n    return tangentEquation;\r\n  }\r\n}\r\n\r\nexport function calculateTangentIntersectPointsByPointOutsideCircle(\r\n  circle: EquationType,\r\n  point?: CoordinateType = null,\r\n  exceptionPoint?: CoordinateType = null\r\n): EquationType {\r\n  if (isValid(circle) && isValid(circle.c) && isValid(circle.d)) {\r\n    const center: CoordinateType = {\r\n      x: Divide(Sub(0, circle.c), 2),\r\n      y: Divide(Sub(0, circle.d), 2)\r\n    };\r\n\r\n    const tempCircleCenter = calculateMiddlePoint(center, point);\r\n    const tempCircleRadius = Divide(calculateDistanceTwoPoints(center, point), 2);\r\n\r\n    if (isValid(tempCircleCenter) && isValid(tempCircleRadius)) {\r\n      const tempCircleEquation = calculateCircleEquationByCenterPoint(tempCircleCenter, tempCircleRadius);\r\n\r\n      if (isValid(tempCircleEquation)) {\r\n        let roots = calculateIntersectionTwoCircleEquations(circle, tempCircleEquation);\r\n\r\n        if (exceptionPoint && isValid(roots)) {\r\n          roots = roots.filter(\r\n            (root: CoordinateType): boolean => JSON.stringify(root) !== JSON.stringify(exceptionPoint)\r\n          );\r\n        }\r\n\r\n        return roots;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function isTwoEquationEqual(equationOne: EquationType, equationTwo: EquationType): boolean {\r\n  if (isValid(equationOne) && isValid(equationTwo)) {\r\n    return isZero(getAngleFromTwoLines(equationOne, equationTwo, 1));\r\n  }\r\n}\r\n\r\nexport function isIsosceles(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): boolean {\r\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\r\n    let result = false;\r\n    if (calculateDistanceTwoPoints(p1, p2) === calculateDistanceTwoPoints(p1, p3)) {\r\n      result = true;\r\n    } else if (calculateDistanceTwoPoints(p2, p1) === calculateDistanceTwoPoints(p2, p3)) {\r\n      result = true;\r\n    } else if (calculateDistanceTwoPoints(p3, p2) === calculateDistanceTwoPoints(p3, p1)) {\r\n      result = true;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","export function isLowerCaseChar(char) {\r\n  if (char === char.toLowerCase()) return '0';\r\n  return '1';\r\n}\r\n\r\nexport function isNumber(value) {\r\n  return !isNaN(value) || typeof value === 'number' || (isObjectLike(value) && getTag(value) === '[object Number]');\r\n}\r\n\r\nexport function isObject(value) {\r\n  const type = typeof value;\r\n  return value !== null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport function isQuadraticEquation(equation): boolean {\r\n  if (!equation) return false;\r\n  return equation.a === 1 && equation.b === 1;\r\n}\r\n\r\nexport function isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n  const tag = getTag(value);\r\n  return (\r\n    tag === '[object Function]' ||\r\n    tag === '[object AsyncFunction]' ||\r\n    tag === '[object GeneratorFunction]' ||\r\n    tag === '[object Proxy]'\r\n  );\r\n}\r\n\r\n/* ====================================================================\r\n                          INTERNAL METHODS\r\n   ==================================================================*/\r\nfunction isObjectLike(value) {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nfunction getTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? '[object Undefined]' : '[object Null]';\r\n  }\r\n  return toString.call(value);\r\n}\r\n","import { isLowerCaseChar, isNumber } from '../../utils/checker';\r\n\r\nexport function checkFormatString(str) {\r\n  let result = '';\r\n  str.split('').forEach((element) => {\r\n    result += isLowerCaseChar(element);\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction validateObject(str) {\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (isNumber(str[i])) return false;\r\n    if (i > 0) if (str.slice(0, i - 1).includes(str[i])) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function defineObject(value) {\r\n  if (isNumber(value)) {\r\n    return 'value';\r\n  }\r\n\r\n  if (!validateObject(value)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (value.length === 3) {\r\n    if (value.includes('(') && value.includes(')')) {\r\n      return 'circle';\r\n    }\r\n    return 'angle';\r\n  }\r\n\r\n  const formatObj = checkFormatString(value);\r\n  switch (formatObj) {\r\n    case '0':\r\n      return 'line';\r\n    case '1':\r\n      return 'point';\r\n    case '10':\r\n      return 'ray';\r\n    case '11':\r\n      return 'segment';\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n","import { RankingObjectContain, validate } from '../definition/define.js';\r\nimport { checkFormatString } from '../definition/defineObjType';\r\nimport ErrorService from '../error/ErrorHandleService.js';\r\nimport { relative } from 'upath';\r\n\r\nexport function validateValue(data, type) {\r\n  if (!_validateName(data.value)) return false;\r\n\r\n  const validateGeometryType = validate.object[type];\r\n  let validateType;\r\n\r\n  if (data.key === 'triangle') {\r\n    return validateShape({ triangle: data.value });\r\n  }\r\n  if (data.key === 'value' || data.key === 'relation' || data.key === 'undefined' || data.key === 'circle') return true;\r\n  if (data.key === 'angle') if (!validateAngle(data.value)) return false;\r\n\r\n  if (validateGeometryType.includes(data.key) || data.key !== 'object') {\r\n    const format = checkFormatString(data.value);\r\n    validateType = validate[data.key];\r\n    if (validateType && format)\r\n      if (validateType.format) {\r\n        if (format === validateType.format && data.value.length === validateType.length) return true;\r\n      } else if (data.value.length === validateType.length) {\r\n        return true;\r\n      }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction validateAngle(value) {\r\n  const format = checkFormatString(value);\r\n  return format[1] === '1';\r\n}\r\n\r\nfunction validateShape(shape) {\r\n  const keys = Object.keys(shape);\r\n  const validateShapeFormat = validate.shape[keys[0]];\r\n  const validateShapeType = validate.shapeType[keys[0]] || [''];\r\n  //check format of shape value\r\n  const data = shape[keys[0]];\r\n  const format = checkFormatString(shape[keys[0]]);\r\n  const shapeFormatCheck = format === validateShapeFormat.format && data.length === validateShapeFormat.length;\r\n\r\n  //check type of shape\r\n  const type = shape.type || '';\r\n  const shapeTypeCheck = validateShapeType.includes(type);\r\n\r\n  return shapeFormatCheck && shapeTypeCheck && _validateName(shape[keys[0]]);\r\n}\r\n\r\nfunction validateDataRelationship(data) {\r\n  const keys = Object.keys(data);\r\n\r\n  for (let indexOfRankingLevel = 0; indexOfRankingLevel < RankingObjectContain.length - 1; indexOfRankingLevel++) {\r\n    for (\r\n      let indexOfObjectCurrentLevel = 0;\r\n      indexOfObjectCurrentLevel < RankingObjectContain[indexOfRankingLevel].length;\r\n      indexOfObjectCurrentLevel++\r\n    ) {\r\n      for (\r\n        let indexOfObjectNextLevel = 0;\r\n        indexOfObjectNextLevel < RankingObjectContain[indexOfRankingLevel + 1].length;\r\n        indexOfObjectNextLevel++\r\n      )\r\n        if (keys.includes(RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel])) {\r\n          if (data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]])\r\n            return checkObjectRelationship(\r\n              data[RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel]][0],\r\n              data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]][0]\r\n            );\r\n        }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction checkObjectRelationship(obj1, obj2) {\r\n  let check = obj2.split('').map((char) => {\r\n    return obj1.includes(char);\r\n  });\r\n  const result = [...new Set(check)];\r\n\r\n  if (result.length === 1) {\r\n    return !result[0];\r\n  }\r\n  if (obj2.length === 2) return check.indexOf(true) === -1;\r\n  if (obj2.length === 3) {\r\n    return !(check.indexOf(true) === 0 || check.indexOf(true) === 2);\r\n  }\r\n}\r\n\r\n// check validate name not duplicate Ex: ABB\r\nfunction _validateName(string) {\r\n  return (\r\n    string.split('').length === string.split('').filter((item, index, array) => array.indexOf(item) === index).length\r\n  );\r\n}\r\n\r\nexport function validateInformation(info) {\r\n  const type = info.outputType;\r\n\r\n  if (type === 'shape') {\r\n    return validateShape(info);\r\n  } else {\r\n    delete info.outputType;\r\n    let keys = Object.keys(info);\r\n    if (keys.includes('undefined')) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < keys.length; i++) {\r\n      let array = info[keys[i]];\r\n      let key = keys[i];\r\n      for (let j = 0; j < array.length; j++) {\r\n        let value = array[j];\r\n        const check = validateValue({ key, value }, type);\r\n        if (!check) {\r\n          console.log({ key, value }, type);\r\n\r\n          return check;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  const keys = Object.keys(info);\r\n  info.outputType = type;\r\n\r\n  if (type === 'define') {\r\n    if (keys.includes('value')) {\r\n      return keys.length === 2;\r\n    } else {\r\n      return keys.length === 1;\r\n    }\r\n  }\r\n\r\n  if (type === 'relation') {\r\n    if (info.triangle) {\r\n      return info.segment[0].split('').filter((point) => info.triangle[0].includes(point)).length > 0;\r\n    }\r\n    return validateDataRelationship(info);\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { defineObject } from './defineObjType';\r\nimport { validateInformation } from '../validation/validation';\r\nimport { definePointType } from './definePointType';\r\nimport { defineShapeType } from './defineShapeType';\r\nimport { reversedDependentObjRelation } from './define';\r\n\r\nfunction defineInformation(data) {\r\n  let result;\r\n  switch (data.outputType) {\r\n    case 'shape': {\r\n      result = defineShapeType(data);\r\n      break;\r\n    }\r\n\r\n    case 'relation': {\r\n      result = definePointType(data);\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      result = data;\r\n    }\r\n  }\r\n\r\n  if (reversedDependentObjRelation.includes(result.relation)) {\r\n    result.object = result.object.reverse();\r\n  }\r\n\r\n  Object.keys(result).forEach((key) => {\r\n    if (key === 'object') {\r\n      result[key].forEach((value) => {\r\n        const type = defineObject(value);\r\n        if (!result[type]) result[type] = [];\r\n        if (type === 'segment') {\r\n          value = sortString(value);\r\n        }\r\n        if (type === 'circle') {\r\n          value = value[1].toUpperCase();\r\n        }\r\n\r\n        if (type === 'angle') {\r\n          value = [value[0], value[2]].sort().join(value[1]);\r\n        }\r\n        result[type].push(value);\r\n      });\r\n    }\r\n    if (key === 'circle') {\r\n      result[key].forEach((value: string, index: number) => {\r\n        result[key][index] = result[key][index][1];\r\n      });\r\n    }\r\n  });\r\n\r\n  if (data.outputType === 'shape') {\r\n    const shapeName = Object.keys(result).filter((key) => key !== 'type')[0];\r\n    if (shapeName !== 'triangle') {\r\n      result[shapeName] = sortString(result[shapeName]);\r\n    }\r\n  }\r\n\r\n  delete result.object;\r\n  const validate = validateInformation(result);\r\n\r\n  if (validate) {\r\n    return result;\r\n  } else {\r\n    return { Error: result };\r\n  }\r\n}\r\n\r\nfunction sortString(str) {\r\n  const arr = str.split('');\r\n  const sorted = arr.sort();\r\n  return sorted.join('');\r\n}\r\n\r\nexport { defineInformation };\r\n","export function defineShapeType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key.includes('type')) {\r\n      const splitter = data[key].toString().split(' ');\r\n      const shape = splitter[splitter.length - 1];\r\n      const splitKey = key.split(' ');\r\n      const shapeName = splitKey.pop();\r\n      const otherData = data[key]\r\n        .toString()\r\n        .replace(shape, '')\r\n        .trim()\r\n        .split(' ');\r\n      result[shapeName] = shape;\r\n      let point = '';\r\n      if (otherData[0].length === 3 && otherData[0].includes('(') && otherData[0].includes(')')) {\r\n        result['point'] = otherData[0][1];\r\n        point = otherData[0];\r\n      }\r\n      result['type'] = otherData\r\n        .join(' ')\r\n        .replace(point, '')\r\n        .trim();\r\n    } else {\r\n      result[key] = data[key].toString();\r\n    }\r\n  });\r\n\r\n  console.log(result);\r\n\r\n  return result;\r\n}\r\n","export function definePointType(data) {\r\n  let result = {};\r\n\r\n  Object.keys(data).forEach((key) => {\r\n    if (key === 'arrayPoints') {\r\n      result['point'] = data[key].toString().split(',');\r\n    } else {\r\n      result[key] = data[key];\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n","import dataViewModel from '../../ViewModel/DataViewModel';\r\nimport type {\r\n  CoordinateType,\r\n  NodeType,\r\n} from '../../utils/types';\r\nimport {\r\n  calculateDistanceTwoPoints,\r\n  calculateIntersectionByLineAndLine,\r\n  getLineFromTwoPoints,\r\n  isIn,\r\n  isIsosceles,\r\n} from './Math2D';\r\nimport { getRandomValue } from './Generation.js';\r\nimport GConst from '../config/values';\r\nimport {\r\n  isFunc,\r\n  isValid,\r\n} from '../utils';\r\n\r\nconst MIN = GConst.Number.MIN_RANDOM_GENERATION;\r\nconst MAX = GConst.Number.MAX_RANDOM_GENERATION;\r\n\r\nconst geometricObj = {\r\n  triangle: generateTriangle,\r\n  quadrilateral: generateQuadrilateral,\r\n  trapezoid: generateTrapezoid,\r\n  parallelogram: generateParallelogram,\r\n  rectangle: generateRectangle,\r\n  rhombus: generateRhombus,\r\n  square: generateSquare,\r\n  circle: generateCircle,\r\n};\r\n\r\nexport function generateGeometry(name: string, shape: string, type?: string) {\r\n  const generateFunc = geometricObj[shape];\r\n  if (generateFunc) {\r\n    generateFunc(name, type);\r\n  }\r\n}\r\n\r\nfunction updateCoordinate(node: NodeType, point: CoordinateType) {\r\n  if (\r\n    isValid(node) &&\r\n    isValid(point) &&\r\n    dataViewModel &&\r\n    isFunc(dataViewModel.updateCoordinate)\r\n  ) {\r\n    dataViewModel.updateCoordinate(node, point);\r\n  }\r\n}\r\n\r\nfunction generateTriangle(name: string, type: string) {\r\n  if (isValid(name) && name.length === 3) {\r\n    let p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    let p2: CoordinateType = {};\r\n    let p3: CoordinateType = {};\r\n\r\n    updateCoordinate(name[0], p1);\r\n    switch (type) {\r\n      case '': {\r\n        p3.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n        p3.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        updateCoordinate(name[1], p3);\r\n        p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n        p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        while (isIn(p2, getLineFromTwoPoints(p1, p3)) || isIsosceles(p1, p2, p3)) {\r\n          p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\r\n          p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\r\n        }\r\n        updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        p2.y = getRandomValue(p1.y + MIN, p1.y + MAX);\r\n        p2.x = p1.x;\r\n        updateCoordinate(name[2], p2);\r\n        p3.x = getRandomValue(p1.x + 1, p1.x + 50);\r\n        p3.y = p1.y;\r\n        updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        /*\r\n         *            [A]\r\n         *          *    *\r\n         *        *        *\r\n         *      *            *\r\n         *    *                *\r\n         *  B  * * * * * * * *  C\r\n         */\r\n        const distance_From_A_To_B = getRandomValue(3, 6);\r\n\r\n        p3.y = getRandomValue(p1.y + 5, p1.y + 10);\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'vuông cân': {\r\n        const distance_From_A_To_B = getRandomValue(5, 10);\r\n        p3.y = p1.y + distance_From_A_To_B;\r\n        p3.x = p1.x - distance_From_A_To_B;\r\n        updateCoordinate(name[1], p3);\r\n        p2.y = p3.y;\r\n        p2.x = p1.x + distance_From_A_To_B;\r\n        updateCoordinate(name[2], p2);\r\n        break;\r\n      }\r\n\r\n      case 'đều': {\r\n        /*\r\n         *       [A]\r\n         *      *   *\r\n         *    *       *\r\n         * [B] * * * * [C]\r\n         */\r\n        p2.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n        p2.y = Math.sqrt(3) * p2.x;\r\n        updateCoordinate(name[2], p2);\r\n        const distance_From_A_To_B = calculateDistanceTwoPoints(p1, p2);\r\n        p3.y = p2.y;\r\n        p3.x = -distance_From_A_To_B + p2.x;\r\n        updateCoordinate(name[1], p3);\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Tu giac\r\nfunction generateQuadrilateral(name: string) {\r\n  if (isValid(name) && name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.y - MAX, p1.y + MAX),\r\n    };\r\n    updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {};\r\n    // prevent point C is on AB line\r\n    const linearEquation = getLineFromTwoPoints(p1, p2);\r\n    if (\r\n      isValid(linearEquation) &&\r\n      isValid(linearEquation.c) &&\r\n      isValid(linearEquation.e)\r\n    ) {\r\n      do {\r\n        p3.x = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n        p3.y = getRandomValue(p2.y + MIN, p2.y + MAX); // yC is always greater than yB\r\n      }\r\n      while (isIn(p3, linearEquation) || Math.abs(p3.y - p2.y) < 5);\r\n      updateCoordinate(name[2], p3);\r\n    }\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: undefined,\r\n      y: undefined,\r\n    };\r\n\r\n    // prevents p1, p2, p4 are straight\r\n    const lineAB = getLineFromTwoPoints(p1, p2);\r\n    const lineAC = getLineFromTwoPoints(p1, p3);\r\n    const lineBC = getLineFromTwoPoints(p2, p3);\r\n    let lineAD = undefined;\r\n    let lineCD = undefined;\r\n    let intersection_AB_CD = [];\r\n    let intersection_AD_BC = [];\r\n\r\n    if (\r\n      isValid(lineAB) &&\r\n      isValid(lineAC) &&\r\n      isValid(lineBC)\r\n    ) {\r\n      do {\r\n        p4.x = getRandomValue(p1.x - MAX, Math.min(p2.x, p3.x));\r\n        p4.y = getRandomValue(p1.x + MIN, p1.x + MAX);\r\n        lineAD = getLineFromTwoPoints(p1, p4);\r\n        lineCD = getLineFromTwoPoints(p3, p4);\r\n        if (isValid(lineAD) && isValid(lineCD)) {\r\n          intersection_AB_CD = calculateIntersectionByLineAndLine(lineAB, lineCD);\r\n          intersection_AD_BC = calculateIntersectionByLineAndLine(lineAD, lineBC);\r\n        }\r\n        if(!Array.isArray(intersection_AB_CD)) {\r\n          intersection_AB_CD = [];\r\n        }\r\n        if (!Array.isArray(intersection_AD_BC)) {\r\n          intersection_AD_BC = [];\r\n        }\r\n      }\r\n      while (\r\n        isIn(p4, lineAB) ||\r\n        isIn(p4, lineAC) ||\r\n        isIn(p4, lineBC) ||\r\n        intersection_AB_CD.length === 0 ||\r\n        intersection_AD_BC.length === 0\r\n        );\r\n      updateCoordinate(name[3], p4);\r\n    }\r\n  }\r\n}\r\n\r\n// Hinh thang\r\nfunction generateTrapezoid(name: string, type: string) {\r\n  if (isValid(name) && name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    updateCoordinate(name[0], p1);\r\n\r\n    switch (type) {\r\n      case '': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + Math.floor(MAX / 2), p1.x + MAX),\r\n          y: p1.y,\r\n        };\r\n        updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: (getRandomValue(p2.x + Math.floor(MAX / 2), p2.x + MAX)),\r\n          y: getRandomValue(p2.y + Math.floor(MAX / 2), p1.y + MAX),\r\n        };\r\n        updateCoordinate(name[2], p3);\r\n\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: getRandomValue(p1.x - Math.floor(MAX / 2), p1.x - MAX),\r\n          y: p3.y,\r\n        };\r\n        updateCoordinate(name[3], p4);\r\n        break;\r\n      }\r\n\r\n      case 'cân': {\r\n        // p2 represents point B\r\n        const p2: CoordinateType = {\r\n          x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n          y: p1.y,\r\n        };\r\n        updateCoordinate(name[1], p2);\r\n\r\n        // p3 represents point C\r\n        const p3: CoordinateType = {\r\n          x: getRandomValue(p2.x + MIN, p2.x + MAX),\r\n          y: getRandomValue(p1.y + MIN, p1.y + MAX),\r\n        };\r\n        updateCoordinate(name[2], p3);\r\n\r\n        const distanceX = Math.abs(p3.x - p2.x);\r\n        const p4X = getRandomValue(0, 2) === 1 ?\r\n          p1.x + distanceX :\r\n          p1.x - distanceX;\r\n        // p4 represents point D\r\n        const p4: CoordinateType = {\r\n          x: p4X,\r\n          y: p3.y,\r\n        };\r\n        updateCoordinate(name[3], p4);\r\n        break;\r\n      }\r\n\r\n      case 'vuông': {\r\n        // TODO: vuong tai dau?\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// hinh binh hanh\r\nfunction generateParallelogram(name: string) {\r\n  if (isValid(name) && name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    let p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    let p3: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n    };\r\n    updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    let p4: CoordinateType = {\r\n      x: p3.x - p2.x - p1.x,\r\n      y: p3.y,\r\n    };\r\n    updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateRectangle(name: string) {\r\n  if (name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: getRandomValue(p2.y + MIN, p2.y + MAX),\r\n    };\r\n    updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y,\r\n    };\r\n    updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\n// Hinh thoi\r\nfunction generateRhombus(name: string) {\r\n  if (isValid(name) && name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: -getRandomValue(p1.y + MIN, p1.y + MAX),\r\n    };\r\n    updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: 2 * Math.abs(p2.x - p1.x),\r\n      y: p1.y,\r\n    };\r\n    updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p2.x,\r\n      y: Math.abs(-p2.y - p1.y),\r\n    };\r\n    updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateSquare(name: string) {\r\n  if (isValid(name) && name.length === 4) {\r\n    // p1 represents point A\r\n    const p1: CoordinateType = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n    };\r\n    updateCoordinate(name[0], p1);\r\n\r\n    // p2 represents point B\r\n    const p2: CoordinateType = {\r\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\r\n      y: p1.y,\r\n    };\r\n    updateCoordinate(name[1], p2);\r\n\r\n    // p3 represents point C\r\n    const p3: CoordinateType = {\r\n      x: p2.x,\r\n      y: p2.y + calculateDistanceTwoPoints(p1, p2),\r\n    };\r\n    updateCoordinate(name[2], p3);\r\n\r\n    // p4 represents point D\r\n    const p4: CoordinateType = {\r\n      x: p1.x,\r\n      y: p3.y,\r\n    };\r\n    updateCoordinate(name[3], p4);\r\n  }\r\n}\r\n\r\nfunction generateCircle(name: string) {\r\n}\r\n","import type { CoordinateType, EquationType, NodeRelationType, NodeType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  getLineFromTwoPoints,\r\n  calculateInCircleEquation,\r\n  calculateCircumCircleEquation,\r\n  calculateMiddlePoint,\r\n  calculateSymmetricalPoint,\r\n  calculateEscribedCirclesEquation\r\n} from '../math/Math2D';\r\nimport { getRandomValue } from '../math/Generation';\r\nimport { mappingShapeType, shapeRules, TwoStaticPointRequireShape, circleType } from '../definition/define';\r\nimport { generateGeometry } from '../math/GenerateGeometry';\r\nimport { getRandomPointInEquation } from '../math/Generation';\r\nimport { readRelation } from './ReadRelation';\r\nimport ErrorService from '../error/ErrorHandleService';\r\nimport { isQuadraticEquation } from '../../utils/checker.js';\r\n\r\nlet shape, shapeName, shapeType;\r\n\r\nexport function readPointsMap(): Array | {} {\r\n  dataViewModel.createPointDetails();\r\n  console.table(JSON.parse(JSON.stringify(dataViewModel.getData.getPointsMap)));\r\n\r\n  while (!dataViewModel.isPointsMapStatic()) {\r\n    //get node to calculate\r\n    const executingNode = dataViewModel.getNextExecuteNode();\r\n    if (!executingNode) break;\r\n    console.log(executingNode.id);\r\n\r\n    executeRelations(executingNode);\r\n\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(executingNode.id)) {\r\n      const roots = dataViewModel.getData.getPointDetails.get(executingNode.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(executingNode.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[executingNode.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(executingNode.id, coordinate);\r\n      }\r\n    }\r\n\r\n    //update static Node\r\n    dataViewModel.updateStaticNode();\r\n\r\n    if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n      makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], executingNode.id);\r\n    }\r\n  }\r\n\r\n  dataViewModel.getData.getPointsMap.forEach((node: NodeType) => {\r\n    //Update calculated value to pointsMap\r\n    if (dataViewModel.getData.getPointDetails.has(node.id)) {\r\n      const setOfEquation = dataViewModel.getData.getPointDetails.get(node.id).setOfEquation;\r\n      if (setOfEquation.length === 1 && isQuadraticEquation(setOfEquation[0])) {\r\n        dataViewModel.updateCoordinate(node.id, getRandomPointInEquation(setOfEquation[0]));\r\n        return;\r\n      }\r\n      const roots = dataViewModel.getData.getPointDetails.get(node.id).roots;\r\n      if (typeof roots === 'string') {\r\n        ErrorService.showError('400');\r\n        return;\r\n      }\r\n      if (roots.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(node.id)) {\r\n          coordinate = roots[getRandomValue(0, roots.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[node.id];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (roots.length > 1) {\r\n            const rootsDirection = roots.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = roots[0];\r\n          }\r\n        }\r\n        dataViewModel.updateCoordinate(node.id, coordinate);\r\n      }\r\n    }\r\n  });\r\n\r\n  return dataViewModel.getData.getPointsMap.map((node) => ({\r\n    id: node.id,\r\n    coordinate: node.coordinate\r\n  }));\r\n}\r\n\r\nfunction executeRelations(node: NodeType) {\r\n  const executingNodeRelations = _makeUniqueNodeRelation(node.dependentNodes);\r\n\r\n  executingNodeRelations.forEach((relation) => {\r\n    let relationEquation;\r\n    if (relation.outputType === 'shape') {\r\n      shapeName = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n      shapeType = mappingShapeType[relation.type] || 'normal';\r\n      shape = relation[shapeName];\r\n      if (circleType.includes(shapeType)) {\r\n        let data = null;\r\n        switch (shapeType) {\r\n          case 'nội tiếp':\r\n            data = calculateInCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'ngoại tiếp':\r\n            data = calculateCircumCircleEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            );\r\n            break;\r\n          case 'bàng tiếp':\r\n            data = calculateEscribedCirclesEquation(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(relation.escribedPoint[0]).coordinate\r\n            );\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        if (data) {\r\n          dataViewModel.circlesData[relation.point[0]] = data;\r\n          dataViewModel.updateCoordinate(relation.point[0], data.center);\r\n        } else {\r\n          ErrorService.showError('400');\r\n        }\r\n      } else if (!dataViewModel.isExecutedRelation(relation)) {\r\n        generateGeometry(relation[shapeName], shapeName, relation.type);\r\n        setPointsDirection(relation[shapeName]);\r\n      }\r\n      if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\r\n        makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], node.id);\r\n      }\r\n    }\r\n\r\n    if (!dataViewModel.isExecutedRelation(relation)) {\r\n      relationEquation = readRelation(relation, node.id);\r\n      if (relationEquation) {\r\n        if (Array.isArray(relationEquation)) {\r\n          relationEquation = relationEquation[getRandomValue(0, relationEquation.length)];\r\n        }\r\n        dataViewModel.executePointDetails(node.id, relationEquation);\r\n      }\r\n      dataViewModel.getData.getExecutedRelations.push(relation);\r\n    }\r\n  });\r\n  if (dataViewModel.isReCalculated) {\r\n    dataViewModel.isReCalculated = false;\r\n    return;\r\n  }\r\n  dataViewModel.getData.getExecutedNode.push(node.id);\r\n}\r\n\r\nfunction setPointsDirection(shape: string) {\r\n  shape.split('').forEach((point, index) => {\r\n    if (index > 0) {\r\n      const pointCoordinate = dataViewModel.getNodeInPointsMapById(point).coordinate;\r\n      const rootCoordinate = dataViewModel.getNodeInPointsMapById(shape[index - 1]).coordinate;\r\n\r\n      dataViewModel.getData.getPointDirectionMap[point] = {\r\n        root: shape[index - 1],\r\n        isRight: pointCoordinate.x > rootCoordinate.x,\r\n        isUp: pointCoordinate.y < rootCoordinate.y\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\nexport function _makeUniqueNodeRelation(dependentNodes: Array<NodeRelationType>): Array<any> {\r\n  let result: Array<NodeRelationType> = [];\r\n\r\n  for (let index = 0; index < dependentNodes.length; index++) {\r\n    let temp = true;\r\n\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (dependentNodes[index].relation === result[i]) {\r\n        temp = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (temp) result.push(dependentNodes[index].relation);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction makeCorrectShape(shape: string, shapeName: string, rules: string, executePoint: string) {\r\n  const staticPointCountRequire = TwoStaticPointRequireShape.includes(shapeName) ? 2 : 1;\r\n  let staticPoints = shape.replace(executePoint, '').split('');\r\n  // check other points are static\r\n  let count = 0;\r\n  for (let i = 0; i < staticPoints.length; i++) {\r\n    if (dataViewModel.isStaticNodeById(staticPoints[i])) {\r\n      count++;\r\n    }\r\n  }\r\n\r\n  if (count < staticPointCountRequire) {\r\n    return;\r\n  }\r\n\r\n  // get node information\r\n  let arrayRules = rules.split(new RegExp('&', 'g'));\r\n\r\n  const executePointIndex = shape.indexOf(executePoint);\r\n  let nodeSetEquations = [];\r\n  if (arrayRules.length > 0) {\r\n    arrayRules.forEach((rule) => {\r\n      const relationType = rule[2];\r\n      if (rule.includes(executePointIndex)) {\r\n        let equation;\r\n        // eslint-disable-next-line default-case\r\n        switch (relationType) {\r\n          case '|':\r\n            equation = getLinearEquationByParallelRule(rule, shape, executePointIndex);\r\n            break;\r\n          case '^':\r\n            if (rule[1] === rule[3]) {\r\n              equation = getLinearEquationByPerpendicularRule(rule, shape, executePointIndex);\r\n            } else {\r\n              updateCoordinateBySpecialPerpendicularRule(rule, shape, executePointIndex);\r\n            }\r\n            break;\r\n          case '=':\r\n            equation = getLinearEquationsByEqualRule(rule, shape, executePointIndex);\r\n            break;\r\n        }\r\n        if (equation) {\r\n          nodeSetEquations = nodeSetEquations.concat(equation);\r\n        }\r\n      }\r\n    });\r\n    if (executePoint === 'C') console.log(nodeSetEquations);\r\n    nodeSetEquations.forEach((equation) => {\r\n      dataViewModel.executePointDetails(executePoint, equation);\r\n    });\r\n  }\r\n}\r\n\r\nfunction updateCoordinateBySpecialPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  let includeLine, nonIncludeLine;\r\n\r\n  const staticLines = rule\r\n    .split('^')\r\n    .filter(\r\n      (line: string): boolean =>\r\n        dataViewModel.isStaticNodeById(shape[line[0]]) && dataViewModel.isStaticNodeById(shape[line[1]])\r\n    );\r\n\r\n  rule.split('^').forEach((line: string) => {\r\n    if (line.includes(executePointIndex)) {\r\n      includeLine = line;\r\n    } else {\r\n      nonIncludeLine = line;\r\n    }\r\n  });\r\n\r\n  const shapePoints = shape\r\n    .split('')\r\n    .map((point: string): CoordinateType => dataViewModel.getNodeInPointsMapById(point).coordinate);\r\n\r\n  if (staticLines.length === 1) {\r\n    const intersectPoint = calculateMiddlePoint(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]]);\r\n    const nonStaticLine = staticLines[0] === nonIncludeLine ? includeLine : nonIncludeLine;\r\n\r\n    const staticPointIndex = nonStaticLine.split('').filter((pointIndex: string): boolean => {\r\n      return dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n    if (staticPointIndex === undefined) {\r\n      const coordinate = calculateIntersectionByLineAndLine(\r\n        calculatePerpendicularLineByPointAndLine(\r\n          intersectPoint,\r\n          getLineFromTwoPoints(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]])\r\n        ),\r\n        getLineFromTwoPoints(shapePoints[staticLines[0][0]], shapePoints[nonStaticLine[0]])\r\n      );\r\n\r\n      dataViewModel.updateCoordinate(shape[nonStaticLine[0]], coordinate);\r\n    } else if (shape[nonStaticLine.replace(staticPointIndex, '')]) {\r\n      const calculatedCoordinate = calculateSymmetricalPoint(shapePoints[staticPointIndex], intersectPoint);\r\n\r\n      dataViewModel.updateCoordinate(shape[nonStaticLine.replace(staticPointIndex, '')], calculatedCoordinate);\r\n    }\r\n  } else if (staticLines.length === 0) {\r\n    //line perpendicular with line include 1 static point\r\n    const intersectPoint = calculateIntersectionByLineAndLine(\r\n      calculatePerpendicularLineByPointAndLine(\r\n        shapePoints[executePointIndex],\r\n        getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n      ),\r\n      getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\r\n    );\r\n    let calculatedCoordinate;\r\n    //update coordinate\r\n    const otherPointInIncludeLine = includeLine.replace(executePointIndex, '');\r\n    if (!dataViewModel.isStaticNodeById(shape[otherPointInIncludeLine])) {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[executePointIndex], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[otherPointInIncludeLine], calculatedCoordinate);\r\n    } else {\r\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[otherPointInIncludeLine], intersectPoint);\r\n      dataViewModel.updateCoordinate(shape[executePointIndex], calculatedCoordinate);\r\n    }\r\n    const nonStaticPointIndex = nonIncludeLine.split('').filter((pointIndex: string): boolean => {\r\n      return !dataViewModel.isStaticNodeById(shape[pointIndex]);\r\n    })[0];\r\n\r\n    calculatedCoordinate = calculateSymmetricalPoint(\r\n      shapePoints[nonIncludeLine.replace(nonStaticPointIndex, '')],\r\n      intersectPoint\r\n    );\r\n\r\n    dataViewModel.updateCoordinate(shape[nonStaticPointIndex], calculatedCoordinate);\r\n  }\r\n}\r\n\r\nfunction getLinearEquationsByEqualRule(rule: string, shape: string, executePointIndex: number): Array<EquationType> {\r\n  const lines = rule.split('=');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  console.log(staticLine, nonStaticLine);\r\n  if (staticLine) {\r\n    const count = staticLine.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n\r\n    if (count < 2) {\r\n      return [];\r\n    }\r\n\r\n    const otherPoint = shape[nonStaticLine.replace(executePointIndex, '')];\r\n\r\n    const radius = calculateDistanceTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n    );\r\n\r\n    //point is outside static line\r\n    if (staticLine.includes(nonStaticLine.replace(executePointIndex, ''))) {\r\n      return [\r\n        calculateCircleEquationByCenterPoint(dataViewModel.getNodeInPointsMapById(otherPoint).coordinate, radius)\r\n      ];\r\n    }\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByParallelRule(rule: string, shape: string, executePointIndex: number): EquationType {\r\n  const lines = rule.split('|');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n  if (\r\n    staticLine &&\r\n    nonStaticLine.includes(executePointIndex) &&\r\n    dataViewModel.isStaticNodeById(shape[nonStaticLine.replace(executePointIndex, '')])\r\n  ) {\r\n    return [\r\n      calculateParallelLineByPointAndLine(\r\n        //point\r\n        dataViewModel.getNodeInPointsMapById(shape[nonStaticLine.replace(executePointIndex, '')]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n\r\nfunction getLinearEquationByPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\r\n  const lines = rule.split('^');\r\n  let staticLine;\r\n  let nonStaticLine;\r\n  // points with non-static point;\r\n  lines.forEach((line) => {\r\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\r\n      .length;\r\n    if (count === 2 && !staticLine) {\r\n      staticLine = line;\r\n    } else {\r\n      nonStaticLine = line;\r\n    }\r\n  });\r\n\r\n  if (staticLine && nonStaticLine.includes(executePointIndex) && !staticLine.includes(executePointIndex)) {\r\n    return [\r\n      calculatePerpendicularLineByPointAndLine(\r\n        //Common point\r\n        dataViewModel.getNodeInPointsMapById(shape[rule[1]]).coordinate,\r\n        //line\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}\r\n","import type { CoordinateType } from '../../utils/types';\r\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\r\nimport {\r\n  calculateCircleEquationByCenterPoint,\r\n  calculateDistanceTwoPoints,\r\n  calculateInternalBisectLineEquation,\r\n  calculateIntersectionByLineAndLine,\r\n  calculateIntersectionEquationTypeWithCircleEquation,\r\n  calculateLinesByAnotherLineAndAngle,\r\n  calculateMiddlePoint,\r\n  calculateParallelLineByPointAndLine,\r\n  calculatePerpendicularLineByPointAndLine,\r\n  calculateSymmetricalPoint,\r\n  getAngleFromTwoLines,\r\n  getLineFromTwoPoints,\r\n  getMiddlePointFromThreePointsInALine,\r\n  isIn,\r\n  calculateIntersectionTwoCircleEquations,\r\n  isVectorInSameLine,\r\n  isVectorSameDirection,\r\n  calculateExternalBisectLineEquation,\r\n  calculateVector,\r\n  calculateTangentEquation,\r\n  calculateTangentIntersectPointsByPointOutsideCircle\r\n} from '../math/Math2D';\r\nimport {\r\n  generatePointAlignmentInside,\r\n  generatePointAlignmentOutside,\r\n  generatePointMiddleTwoPoints,\r\n  getRandomPointInEquation,\r\n  getRandomValue\r\n} from '../math/Generation.js';\r\nimport ErrorService from '../error/ErrorHandleService';\r\nimport { ShapeAffectBySegmentChange, TwoStaticPointRequireShape } from '../definition/define';\r\nimport { Operation } from '../math/MathOperation.js';\r\n\r\nexport function readRelation(relation: mixed, point: string) {\r\n  let equationResults;\r\n\r\n  dataViewModel.executingRelation = relation;\r\n  if (relation.operation) {\r\n    equationResults = analyzeOperationType(relation, point);\r\n  } else if (relation.relation) {\r\n    const relationType = relation.relation;\r\n    switch (relationType) {\r\n      case 'trung điểm':\r\n      case 'thuộc':\r\n      case 'không thuộc':\r\n      case 'song song':\r\n      case 'vuông góc':\r\n      case 'phân giác':\r\n      case 'phân giác ngoài':\r\n      case 'phân giác trong':\r\n      case 'thẳng hàng':\r\n      case 'đường cao':\r\n      case 'trung tuyến':\r\n        equationResults = analyzeRelationType(relation, point);\r\n        break;\r\n      case 'cắt':\r\n        equationResults = analyzeIntersectRelation(relation, point);\r\n        break;\r\n      case 'tiếp tuyến':\r\n        equationResults = analyzeTangentRelation(relation, point);\r\n        break;\r\n      default:\r\n        equationResults = null;\r\n    }\r\n  } else if (relation.outputType === 'shape') {\r\n    const shapeType = Object.keys(relation).filter((key) => key !== 'type')[0];\r\n    switch (shapeType) {\r\n      case 'triangle':\r\n        equationResults = getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate\r\n        );\r\n        break;\r\n      case 'quadrilateral':\r\n      case 'rectangle':\r\n      case 'square':\r\n      case 'rhombus':\r\n      case 'trapezoid':\r\n      case 'parallelogram':\r\n        if (shapeType !== 'quadrilateral') {\r\n          let count = 0;\r\n          relation[shapeType].split('').forEach((point) => {\r\n            if (dataViewModel.isStaticNodeById(point)) {\r\n              count++;\r\n            }\r\n          });\r\n          const limit = TwoStaticPointRequireShape.includes(shapeType) ? 1 : 2;\r\n          if (count > limit) {\r\n            return;\r\n          }\r\n        }\r\n        let index = relation[shapeType].indexOf(point);\r\n        if (index === relation[shapeType].length - 1) {\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate\r\n          );\r\n        } else {\r\n          index = index === 0 ? relation[shapeType].length - 1 : index - 1;\r\n          equationResults = getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(point).coordinate\r\n          );\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  //TODO\r\n  if (equationResults) {\r\n    if (equationResults.coefficientX !== undefined) {\r\n      // equationResults is linear\r\n      return {\r\n        a: 0,\r\n        b: 0,\r\n        c: equationResults.coefficientX,\r\n        d: equationResults.coefficientY,\r\n        e: equationResults.constantTerm\r\n      };\r\n    } else {\r\n      // equationResults is circle\r\n      return equationResults;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction analyzeRelationType(relation: mixed, point: string): LinearEquation {\r\n  let segmentIncludePoint, segmentNotIncludePoint;\r\n  if (relation.segment) {\r\n    relation.segment.forEach((segment: string) => {\r\n      if (segment.includes(point)) {\r\n        segmentIncludePoint = segment;\r\n      } else {\r\n        segmentNotIncludePoint = segment;\r\n      }\r\n    });\r\n  }\r\n\r\n  //points = [...new Set(points)].filter((point: string): boolean => !nonStaticPoints.includes(point));\r\n  const relationType = relation.relation;\r\n  console.log('---', relationType);\r\n\r\n  if (\r\n    relationType === 'trung điểm' ||\r\n    relationType === 'thuộc' ||\r\n    relationType === 'không thuộc' ||\r\n    relationType === 'thẳng hàng'\r\n  ) {\r\n    let calculatedPoint;\r\n    if (relation.circle) {\r\n      calculatedPoint = getRandomPointInEquation(dataViewModel.getCircleEquation(relation.circle[0]));\r\n      dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n      return dataViewModel.getCircleEquation(relation.circle[0]);\r\n    }\r\n    if (segmentIncludePoint) {\r\n      const otherStaticPoint = relation.point[0];\r\n      const otherStaticNodeInSegment = dataViewModel.getNodeInPointsMapById(segmentIncludePoint.replace(point, ''));\r\n\r\n      if (!otherStaticNodeInSegment.coordinate.x && !otherStaticNodeInSegment.coordinate.y) {\r\n        return null;\r\n      }\r\n\r\n      if (relationType === 'trung điểm') {\r\n        calculatedPoint = calculateSymmetricalPoint(\r\n          otherStaticNodeInSegment.coordinate,\r\n          dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n          segmentIncludePoint.indexOf(point) === 1\r\n        );\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n    } else if (segmentNotIncludePoint) {\r\n      switch (relationType) {\r\n        case 'trung điểm':\r\n          calculatedPoint = calculateMiddlePoint(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'thuộc':\r\n          calculatedPoint = generatePointAlignmentInside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n          );\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        case 'không thuộc':\r\n          calculatedPoint = generatePointAlignmentOutside(\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate,\r\n            getRandomValue(0, 2) === 1\r\n          );\r\n\r\n          dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\r\n          dataViewModel.updateCoordinate(point, calculatedPoint);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else {\r\n      const points = relation.point;\r\n      const index = points.indexOf(point);\r\n      if (index === 1) {\r\n        calculatedPoint = generatePointAlignmentInside(\r\n          dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[2]).coordinate\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedPoint = generatePointAlignmentOutside(\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 0 : 1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 1 : 2]).coordinate,\r\n          index === 2\r\n        );\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(points[1]).coordinate\r\n      );\r\n    }\r\n\r\n    return getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n  } else if (relationType === 'song song' || relationType === 'vuông góc') {\r\n    if (!segmentNotIncludePoint) {\r\n      return;\r\n    }\r\n    const otherStaticPoint = segmentIncludePoint.replace(point, '');\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint) && !dataViewModel.isValidCoordinate(point)) {\r\n      const point = generatePointMiddleTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n      );\r\n      if (point) {\r\n        dataViewModel.updateCoordinate(otherStaticPoint, point);\r\n      }\r\n    }\r\n    //undefined point\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(segmentNotIncludePoint[i])) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const staticLineEquation = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\r\n    );\r\n\r\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint)) {\r\n      return;\r\n    }\r\n\r\n    let calculatedLineEquation;\r\n    if (relationType === 'vuông góc') {\r\n      calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const isInStaticLine = isIn(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n      const calculatedPoint = isInStaticLine\r\n        ? getRandomPointInEquation(calculatedLineEquation)\r\n        : calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n\r\n      if (!isInStaticLine) {\r\n        dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[1]}`);\r\n        dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\r\n      }\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    if (relationType === 'song song') {\r\n      calculatedLineEquation = calculateParallelLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\r\n        staticLineEquation\r\n      );\r\n\r\n      const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n\r\n      dataViewModel.updateCoordinate(point, calculatedPoint);\r\n    }\r\n    return calculatedLineEquation;\r\n  } else if (relationType.includes('phân giác')) {\r\n    const isExternal = relationType === 'phân giác ngoài';\r\n\r\n    if (relation.angle) {\r\n      const angle = relation.angle[0];\r\n      if (angle.includes(point)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n      );\r\n      let calculatedLineEquation;\r\n      if (isExternal) {\r\n        calculatedLineEquation = calculateExternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      } else {\r\n        calculatedLineEquation = calculateInternalBisectLineEquation(\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\r\n          ),\r\n          getLineFromTwoPoints(\r\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\r\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n          ),\r\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\r\n        );\r\n\r\n        const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n      }\r\n\r\n      return calculatedLineEquation;\r\n    }\r\n  } else if (relationType === 'đường cao' || relationType === 'trung tuyến') {\r\n    const segment = relation.segment[0];\r\n    const line = relation.triangle[0].replace(segment.replace(point, ''), '');\r\n    let calculatedPoint;\r\n    if (relationType === 'trung tuyến') {\r\n      calculatedPoint = calculateMiddlePoint(\r\n        dataViewModel.getNodeInPointsMapById(line[1]).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(line[0]).coordinate\r\n      );\r\n    }\r\n\r\n    if (relationType === 'đường cao') {\r\n      const calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\r\n        dataViewModel.getNodeInPointsMapById(segment.replace(point, '')).coordinate,\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(line[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(line[0]).coordinate\r\n        )\r\n      );\r\n\r\n      calculatedPoint = calculateIntersectionByLineAndLine(\r\n        calculatedLineEquation,\r\n        getLineFromTwoPoints(\r\n          dataViewModel.getNodeInPointsMapById(line[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(line[0]).coordinate\r\n        )\r\n      );\r\n    }\r\n\r\n    dataViewModel.updateCoordinate(point, calculatedPoint);\r\n  }\r\n}\r\n\r\nfunction analyzeIntersectRelation(relation: mixed, point: string): CoordinateType {\r\n  for (let index in relation.segment) {\r\n    for (let i = 0; i < 2; i++) {\r\n      if (!dataViewModel.isValidCoordinate(relation.segment[index][i])) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if (relation.segment && relation.segment.length === 2) {\r\n    const calculatedLineEquationOne = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\r\n    );\r\n    const calculatedLineEquationTwo = getLineFromTwoPoints(\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][1]).coordinate\r\n    );\r\n\r\n    relation.segment.forEach((segment: string) => {\r\n      dataViewModel.getData.getAdditionSegment.push(`${relation.point[0]}${segment[0]}`);\r\n      dataViewModel.getData.getAdditionSegment.push(`${relation.point[0]}${segment[1]}`);\r\n    });\r\n\r\n    const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquationOne, calculatedLineEquationTwo);\r\n\r\n    dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\r\n  } else if (relation.circle && relation.circle.length === 2) {\r\n    const roots = calculateIntersectionTwoCircleEquations(\r\n      dataViewModel.getCircleEquation(relation.circle[0]),\r\n      dataViewModel.getCircleEquation(relation.circle[1])\r\n    );\r\n\r\n    roots.forEach((root: CoordinateType, index: number) => {\r\n      if (relation.point[index]) {\r\n        dataViewModel.updateCoordinate(relation.point[index], root);\r\n      }\r\n    });\r\n  } else {\r\n    const pointOne = dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate;\r\n    const pointTwo = dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate;\r\n    let roots = calculateIntersectionTwoCircleEquations(\r\n      getLineFromTwoPoints(pointOne, pointTwo),\r\n      dataViewModel.getCircleEquation(relation.circle[0])\r\n    );\r\n    if (typeof roots === 'string') {\r\n      ErrorService.showError('200');\r\n    }\r\n\r\n    roots = roots.filter(\r\n      (root: CoordinateType): boolean =>\r\n        JSON.stringify(root) !== JSON.stringify(pointOne) && JSON.stringify(root) !== JSON.stringify(pointTwo)\r\n    );\r\n    if (relation.point.length === 2) {\r\n      roots.forEach((root: CoordinateType, index: number) => {\r\n        if (!relation.point[index]) {\r\n          ErrorService.showError('200');\r\n        } else {\r\n          dataViewModel.updateCoordinate(relation.point[index], root);\r\n        }\r\n      });\r\n    } else {\r\n      dataViewModel.updateCoordinate(relation.point[0], roots[getRandomValue(0, roots.length - 1)]);\r\n    }\r\n\r\n    relation.point.forEach((point: string) => {\r\n      dataViewModel.getData.getAdditionSegment.push(`${relation.segment[0][0]}${point}`);\r\n    });\r\n  }\r\n}\r\n\r\n//chỉ xử lý : = , *\r\nfunction analyzeOperationType(relation: mixed, point: string): any {\r\n  const objectType = relation.segment ? 'segment' : 'angle';\r\n  const valueData = {};\r\n\r\n  const objectsIncludePoint = [];\r\n  if (relation.value && relation[objectType].length === 1) {\r\n    valueData[relation[objectType][0]] = relation.value[0];\r\n    objectsIncludePoint.push(relation[objectType][0]);\r\n  } else {\r\n    for (let index in relation[objectType]) {\r\n      const object = relation[objectType][index];\r\n      if (object.includes(point)) {\r\n        objectsIncludePoint.push(object);\r\n      }\r\n\r\n      valueData[object] =\r\n        objectType === 'segment'\r\n          ? calculateDistanceTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n            )\r\n          : (getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\r\n            ),\r\n            getLineFromTwoPoints(\r\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(object[2]).coordinate\r\n            ));\r\n    }\r\n  }\r\n\r\n  //điểm cần tính phụ thuộc 1 điểm duy nhất\r\n  if (objectsIncludePoint.length === 1) {\r\n    const index = relation[objectType].indexOf(objectsIncludePoint[0]);\r\n    const staticObject = relation[objectType][index === 0 ? 1 : 0];\r\n    let staticValue;\r\n    if (relation[objectType].length > 1) {\r\n      staticValue = index === 0 ? relation.value * valueData[staticObject] : valueData[staticObject] / relation.value;\r\n    } else {\r\n      staticValue = relation.value[0];\r\n    }\r\n\r\n    if (objectType === 'segment') {\r\n      return calculateCircleEquationByCenterPoint(\r\n        dataViewModel.getNodeInPointsMapById(objectsIncludePoint[0].replace(point, '')).coordinate,\r\n        staticValue\r\n      );\r\n    }\r\n\r\n    return calculateLineEquationByAngleRelation(objectsIncludePoint[0], staticValue);\r\n  }\r\n  if (objectsIncludePoint.length === 2) {\r\n    if (objectType === 'segment') {\r\n      const staticPointOne = objectsIncludePoint[0].replace(point, '');\r\n      const staticPointTwo = objectsIncludePoint[1].replace(point, '');\r\n      //cần check thêm loại shape\r\n      if (!dataViewModel.isStaticNodeById(staticPointOne) || !dataViewModel.isStaticNodeById(staticPointTwo)) {\r\n        return;\r\n      }\r\n\r\n      const staticLineEquation = getLineFromTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const staticDistance = calculateDistanceTwoPoints(\r\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n      );\r\n\r\n      const isAlign = isIn(dataViewModel.getNodeInPointsMapById(point).coordinate, {\r\n        a: 0,\r\n        b: 0,\r\n        c: staticLineEquation.coefficientX,\r\n        d: staticLineEquation.coefficientY,\r\n        e: staticLineEquation.constantTerm\r\n      });\r\n\r\n      const ratio = +relation.value[0];\r\n      if (isAlign) {\r\n        let calculatedPoint;\r\n        const betweenPoint = getMiddlePointFromThreePointsInALine(\r\n          dataViewModel.getNodeInPointsMapById(point).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n        );\r\n\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(point).coordinate) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio + 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === p) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate && ratio < 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (1 - ratio)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate && ratio > 1) {\r\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\r\n            staticLineEquation,\r\n            calculateCircleEquationByCenterPoint(\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              (ratio * staticDistance) / (ratio - 1)\r\n            )\r\n          );\r\n\r\n          [...calculatedPoint].forEach((p) => {\r\n            const result = getMiddlePointFromThreePointsInALine(\r\n              p,\r\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\r\n            );\r\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate) {\r\n              calculatedPoint = p;\r\n            }\r\n          });\r\n        }\r\n\r\n        dataViewModel.updateCoordinate(point, calculatedPoint);\r\n\r\n        return staticLineEquation;\r\n      } else {\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateLineEquationByAngleRelation(angleName: string, angleValue: number): EquationType {\r\n  const checkResult = checkAndModifiedAngle(angleName);\r\n  const modifiedAngleName = checkResult.angle;\r\n  const staticPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[0]).coordinate;\r\n  const rootPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[1]).coordinate;\r\n  const changedPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[2]).coordinate;\r\n  const calculatedEquation = calculateLinesByAnotherLineAndAngle(rootPoint, staticPoint, changedPoint, angleValue);\r\n\r\n  const intersectPoint = calculateIntersectionByLineAndLine(\r\n    calculatedEquation,\r\n    getLineFromTwoPoints(staticPoint, rootPoint)\r\n  );\r\n  const newRootPoint = calculateIntersectionTwoCircleEquations(\r\n    calculatedEquation,\r\n    calculateCircleEquationByCenterPoint(changedPoint, calculateDistanceTwoPoints(changedPoint, rootPoint))\r\n  ).sort((rootOne: CoordinateType, rootTwo: CoordinateType): number => {\r\n    return calculateDistanceTwoPoints(intersectPoint, rootOne) - calculateDistanceTwoPoints(intersectPoint, rootTwo);\r\n  })[0];\r\n\r\n  //move newRoot to oldRoot\r\n  const transitionVector = calculateVector(newRootPoint, rootPoint, false);\r\n  if (checkResult.isChanged === false) {\r\n    dataViewModel.updateCoordinate(modifiedAngleName[2], {\r\n      x: changedPoint.x + transitionVector.x,\r\n      y: changedPoint.y + transitionVector.y\r\n    });\r\n\r\n    dataViewModel.replaceSetOfEquation(\r\n      modifiedAngleName[2],\r\n      getLineFromTwoPoints(rootPoint, changedPoint),\r\n      calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  dataViewModel.updateCoordinate(modifiedAngleName[0], {\r\n    x: staticPoint.x - transitionVector.x,\r\n    y: staticPoint.y - transitionVector.y\r\n  });\r\n\r\n  dataViewModel.replaceSetOfEquation(\r\n    modifiedAngleName[1],\r\n    getLineFromTwoPoints(rootPoint, changedPoint),\r\n    calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\r\n  );\r\n\r\n  return null;\r\n}\r\n\r\nfunction reExecuteNode(array: Array<string>) {\r\n  console.log(`----------------`);\r\n  dataViewModel.reExecuteNode(array);\r\n}\r\n\r\nfunction getShapeAffectList(): Array<string> {\r\n  const shapeList = [];\r\n\r\n  //get list of shape name\r\n  dataViewModel.getData.relationsResult.shapes.forEach((shapeData: Object): boolean => {\r\n    const shapeType = Object.keys(shapeData).filter((key: string): boolean => key !== 'outputType')[0];\r\n    if (ShapeAffectBySegmentChange.includes(shapeType)) {\r\n      shapeList.push(shapeData[shapeType]);\r\n    }\r\n  });\r\n\r\n  return shapeList;\r\n}\r\n\r\nfunction checkAndModifiedAngle(angle: string): { angle: string, isChanged: boolean } {\r\n  for (let i = 0; i < angle.length; i++) {\r\n    if (!dataViewModel.isValidCoordinate(angle[i])) {\r\n      const coordinate = dataViewModel.getNodeInPointsMapById(angle[i]).coordinate;\r\n      dataViewModel.updateCoordinate(angle[i], {\r\n        x: coordinate.x || getRandomValue(-10, 10),\r\n        y: coordinate.y || getRandomValue(-10, 10)\r\n      });\r\n      return { angle, isChanged: false };\r\n    }\r\n  }\r\n  const shapeList = getShapeAffectList();\r\n\r\n  const secondLine = `${angle[1]}${angle[2]}`;\r\n\r\n  for (let i = 0; i < shapeList.length; i++) {\r\n    const shape = shapeList[i];\r\n    const secondLineVector = calculateVector(\r\n      dataViewModel.getNodeInPointsMapById(secondLine[0]).coordinate,\r\n      dataViewModel.getNodeInPointsMapById(secondLine[1]).coordinate\r\n    );\r\n\r\n    let modifiedAngleName = angle;\r\n\r\n    if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\r\n        ),\r\n        secondLineVector\r\n      ) ||\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      modifiedAngleName = angle\r\n        .split('')\r\n        .reverse()\r\n        .join('');\r\n    }\r\n\r\n    let isChanged = modifiedAngleName !== angle;\r\n    let updatePoint = modifiedAngleName[2];\r\n\r\n    if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      if (modifiedAngleName[1] === shape[0]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[2];\r\n          isChanged = false;\r\n        }\r\n      } else if (modifiedAngleName[1] === shape[2]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[0];\r\n          isChanged = false;\r\n        }\r\n      }\r\n    } else if (\r\n      isVectorInSameLine(\r\n        calculateVector(\r\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n          dataViewModel.getNodeInPointsMapById(shape[3]).coordinate\r\n        ),\r\n        secondLineVector\r\n      )\r\n    ) {\r\n      if (modifiedAngleName[1] === shape[1]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[3]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[3];\r\n          isChanged = false;\r\n        }\r\n      } else if (modifiedAngleName[1] === shape[3]) {\r\n        if (\r\n          isVectorSameDirection(\r\n            calculateVector(\r\n              dataViewModel.getNodeInPointsMapById(shape[3]).coordinate,\r\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\r\n            ),\r\n            secondLineVector\r\n          )\r\n        ) {\r\n          updatePoint = shape[1];\r\n          isChanged = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    reExecuteNode([modifiedAngleName[1], updatePoint]);\r\n    const result = modifiedAngleName.replace(modifiedAngleName[2], updatePoint);\r\n\r\n    return { angle: result, isChanged };\r\n  }\r\n  return { angle, isChanged: false };\r\n}\r\n\r\nfunction analyzeTangentRelation(relation: mixed, point: string): any {\r\n  const otherPointInSegment = relation.segment[0].replace(point, '');\r\n  if (!dataViewModel.isStaticNodeById(otherPointInSegment)) {\r\n    return;\r\n  }\r\n\r\n  const tangentPointCoordinate = dataViewModel.getNodeInPointsMapById(otherPointInSegment).coordinate;\r\n  const circleEquation = dataViewModel.getCircleEquation(relation.circle[0]);\r\n  let tangentEquation;\r\n  if (isIn(tangentPointCoordinate, circleEquation)) {\r\n    tangentEquation = calculateTangentEquation(circleEquation, tangentPointCoordinate);\r\n    dataViewModel.updateCoordinate(point, getRandomPointInEquation(tangentEquation));\r\n    dataViewModel.getData.getAdditionSegment.push(`${otherPointInSegment}${relation.circle[0]}`);\r\n  } else {\r\n    const roots = calculateTangentIntersectPointsByPointOutsideCircle(circleEquation, tangentPointCoordinate);\r\n    const result = filterTangentPoint(roots, circleEquation);\r\n    tangentEquation = result.tangentEquation;\r\n    dataViewModel.updateCoordinate(point, result.point);\r\n    dataViewModel.getData.getAdditionSegment.push(`${point}${relation.circle[0]}`);\r\n  }\r\n\r\n  return tangentEquation;\r\n}\r\n\r\nfunction filterTangentPoint(\r\n  roots: Array<CoordinateType>,\r\n  circleEquation: EquationType\r\n): { equation: EquationType, point: CoordinateType } {\r\n  const filterRoots = roots.filter((root: CoordinateType): boolean => !dataViewModel.isCoordinateDuplicated(root));\r\n\r\n  return filterRoots.map((root: CoordinateType): { equation: EquationType, point: CoordinateType } => {\r\n    return {\r\n      equation: calculateTangentEquation(circleEquation, root),\r\n      point: root\r\n    };\r\n  })[getRandomValue(0, filterRoots.length - 1)];\r\n}\r\n","// @flow\r\n\r\nimport { objectWithPoint } from '../definition/define.js';\r\nimport type { DrawingDataType, NodeRelationType, NodeType } from '../../utils/types.js';\r\nimport dataViewModel from '../../ViewModel/DataViewModel';\r\nimport { readPointsMap } from './ReadPointsMap';\r\nimport { makeRoundCoordinate } from '../math/Math2D.js';\r\nimport ErrorService from '../error/ErrorHandleService.js';\r\nimport { Operation } from '../math/MathOperation.js';\r\n\r\nlet RelationPointsMap: Array<NodeType> = [];\r\n\r\nexport function analyzeResult(validatedResult): DrawingDataType {\r\n  validatedResult = deleteWrongRelation(validatedResult);\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    createPointsMapByShape(shape);\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n  relations.forEach((relation) => {\r\n    createPointsMapByRelation(relation).forEach((node) => {\r\n      updateMap(node, dataViewModel.getData.getPointsMap);\r\n    });\r\n  });\r\n\r\n  trimPointsMap();\r\n\r\n  let result = {};\r\n\r\n  readPointsMap();\r\n  result.points = dataViewModel.getData.getPointsMap.map((node: NodeType) => ({\r\n    id: node.id,\r\n    coordinate: {\r\n      x: Operation.Round(node.coordinate.x, 3),\r\n      y: Operation.Round(node.coordinate.y, 3)\r\n    }\r\n  }));\r\n\r\n  _RoundObject(dataViewModel.circlesData);\r\n  result.segments = [...getArraySegments(validatedResult), ...dataViewModel.getData.getAdditionSegment];\r\n  return result;\r\n}\r\n\r\nfunction _RoundObject(object: mixed): mixed {\r\n  if (typeof object === 'object') {\r\n    Object.keys(object).forEach((key: string) => {\r\n      object[key] = _RoundObject(object[key]);\r\n      if (key === 'radius') {\r\n        console.log(object[key]);\r\n      }\r\n    });\r\n    return object;\r\n  }\r\n  return Operation.Round(object);\r\n}\r\n\r\nfunction deleteWrongRelation(validatedResult) {\r\n  const shapes = validatedResult.shapes;\r\n  let isHaveTriangle = false;\r\n  let triangle = '';\r\n  shapes.forEach((shape: mixed) => {\r\n    if (shape.triangle && !shape.point) {\r\n      isHaveTriangle = true;\r\n      triangle = shape.triangle;\r\n    }\r\n  });\r\n\r\n  if (!isHaveTriangle) {\r\n    return validatedResult;\r\n  }\r\n\r\n  const segments = [];\r\n  const relationSegments = [];\r\n  const relationAngles = [];\r\n\r\n  validatedResult.relations.forEach((relation) => {\r\n    if (relation.outputType === 'define' && !!relation.value) {\r\n      if (relation.segment) {\r\n        relation.segment.forEach((segment: string) => {\r\n          if (!segments.includes(segment) && triangle.includes(segment[0]) && triangle.includes(segment[1])) {\r\n            segments.push(segment);\r\n            relationSegments.push(relation);\r\n          }\r\n        });\r\n      }\r\n\r\n      if (relation.angle) {\r\n        relation.angle.forEach((angle: string) => {\r\n          if (triangle.includes(angle[0]) && triangle.includes(angle[1]) && triangle.includes(angle[2])) {\r\n            relationAngles.push(relation);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  let deleteRelationList = [];\r\n\r\n  if (segments.length > 1) {\r\n    if (segments.length === 2) {\r\n      relationAngles.shift();\r\n    }\r\n    deleteRelationList = relationAngles;\r\n  }\r\n  const relations = validatedResult.relations.filter((relation: mixed): boolean => {\r\n    for (let i = 0; i < deleteRelationList.length; i++) {\r\n      if (JSON.stringify(relation) === JSON.stringify(deleteRelationList[i])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  });\r\n\r\n  deleteRelationList.forEach((relation: mixed) => {\r\n    ErrorService.updateErrorInInput(relation);\r\n  });\r\n\r\n  return { shapes, relations };\r\n}\r\n\r\nfunction getArraySegments(validatedResult): Array<string> {\r\n  let result: Array<string> = [];\r\n\r\n  const shapes = validatedResult.shapes;\r\n\r\n  shapes.forEach((shape) => {\r\n    result = result.concat(getShapeSegments(shape));\r\n  });\r\n\r\n  const relations = validatedResult.relations;\r\n\r\n  relations.forEach((relation) => {\r\n    result = result.concat(getRelationSegments(relation));\r\n  });\r\n\r\n  return result.filter((item, index, array) => array.indexOf(item) === index);\r\n}\r\n\r\nfunction getRelationSegments(relation: mixed): Array<string> {\r\n  let result = [];\r\n  if (relation.segment) {\r\n    result = result.concat(relation.segment);\r\n  }\r\n  if (relation.angle) {\r\n    relation.angle.forEach((angle: string) => {\r\n      result = result.concat([`${angle[0]}${angle[1]}`, `${angle[1]}${angle[2]}`]);\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction getShapeSegments(shape: any): Array<string> {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  const result = [];\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    if (i === points.length - 1) {\r\n      result.push(points[0] + points[i]);\r\n    } else {\r\n      result.push(points[i] + points[i + 1]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction trimPointsMap() {\r\n  dataViewModel.getData.setPointsMap = dataViewModel.getData.getPointsMap.map((node: NodeType): NodeType => ({\r\n    ...node,\r\n    dependentNodes: unique(node.dependentNodes)\r\n  }));\r\n}\r\n\r\nfunction unique(dependentNodes: Array<NodeRelationType>): Array<NodeRelationType> {\r\n  let result = [];\r\n\r\n  dependentNodes.forEach((node) => {\r\n    for (let i = 0; i < result.length; i++) {\r\n      if (JSON.stringify(node) === JSON.stringify(result[i])) return;\r\n    }\r\n    result.push(node);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction sortPriority(points) {\r\n  return points.sort((el1: string, el2: string): number => {\r\n    const index1 = findIndexByNodeId(el1, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(el2, dataViewModel.getData.getPointsMap);\r\n\r\n    if (index1 === -1 && index2 === -1) {\r\n      return 1;\r\n    }\r\n    if (index1 >= 0 && index2 >= 0) return 1;\r\n    return index2 - index1;\r\n  });\r\n}\r\n\r\nfunction createPointsMapByShape(shape: any) {\r\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\r\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\r\n\r\n  points = sortPriority([...points]);\r\n\r\n  if (dataViewModel.getData.getPointsMap.length === 0) {\r\n    const shouldStaticPoint = getFirstStaticPointInShape(shape[shapeName]);\r\n    points = [shouldStaticPoint].concat(points.filter((point) => point !== shouldStaticPoint));\r\n  }\r\n\r\n  let objectPointsMap;\r\n  // đường tròn ngoại tiếp, nội tiếp\r\n  if (shape.point) {\r\n    objectPointsMap = points.map((point: string) => {\r\n      return createNode(shape.point[0], [{ id: point, relation: shape }]);\r\n    });\r\n  } else {\r\n    objectPointsMap = points.map((point: string, index: number) => {\r\n      return createNode(point, [{ id: points[0], relation: shape }]);\r\n    });\r\n  }\r\n  console.log(objectPointsMap);\r\n  objectPointsMap.forEach((node: NodeType) => {\r\n    updateMap(node, dataViewModel.getData.getPointsMap);\r\n  });\r\n}\r\n\r\nfunction getFirstStaticPointInShape(shape: string): string {\r\n  const angles = [];\r\n  const segments = [];\r\n  if (dataViewModel.getData.getRelationsResult.relations) {\r\n    dataViewModel.getData.getRelationsResult.relations.forEach((relation) => {\r\n      if (!relation.angle || relation.outputType !== 'define') {\r\n        return;\r\n      } else {\r\n        angles.push(relation.angle[0]);\r\n      }\r\n      if (!relation.segment || relation.outputType !== 'define') {\r\n        return;\r\n      } else {\r\n        segments.push(relation.segment[0]);\r\n      }\r\n    });\r\n\r\n    const shapePointCount = {};\r\n\r\n    angles.forEach((angle: string): void => {\r\n      if (!shape.includes(angle[1])) {\r\n        return;\r\n      }\r\n      angle.split('').forEach((point, index) => {\r\n        //don't check middle point\r\n        if (index !== 1) {\r\n          if (shapePointCount[point]) {\r\n            shapePointCount[point] += 1;\r\n          } else {\r\n            shapePointCount[point] = 1;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    let minCountPoint = shape[0];\r\n    Object.keys(shapePointCount).forEach((point) => {\r\n      if (shapePointCount[point] < shapePointCount[minCountPoint]) {\r\n        minCountPoint = point;\r\n      }\r\n    });\r\n\r\n    return minCountPoint;\r\n  }\r\n  return shape[0];\r\n}\r\n\r\nfunction createPointsMapByRelation(relation: any) {\r\n  RelationPointsMap = [];\r\n  objectWithPoint.forEach((objectType: string) => {\r\n    if (relation[objectType]) {\r\n      relation[objectType].forEach((object) => {\r\n        let points = object.split('').filter((point) => point === point.toUpperCase());\r\n\r\n        const objectPointsMap = points.map((point: string, index: number) => {\r\n          return createNode(point);\r\n        });\r\n\r\n        objectPointsMap.forEach((node: NodeType) => {\r\n          updateMap(node, RelationPointsMap);\r\n        });\r\n      });\r\n    }\r\n  });\r\n\r\n  RelationPointsMap = [...RelationPointsMap].sort((nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const index1 = findIndexByNodeId(nodeOne.id, dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(nodeTwo.id, dataViewModel.getData.getPointsMap);\r\n    if (index1 === -1 && index2 === -1) return 1;\r\n    if (index1 >= 0 && index2 >= 0) return index1 - index2;\r\n    return index2 - index1;\r\n  });\r\n\r\n  let lastObjectPoints = [];\r\n\r\n  if (relation.angle && relation.outputType === 'define' && !!relation.value) {\r\n    const index1 = findIndexByNodeId(relation.angle[0][0], dataViewModel.getData.getPointsMap);\r\n    const index2 = findIndexByNodeId(relation.angle[0][2], dataViewModel.getData.getPointsMap);\r\n    if (index1 < 0) {\r\n      lastObjectPoints.push(relation.angle[0][0]);\r\n    }\r\n    if (index2 < 0) {\r\n      lastObjectPoints.push(relation.angle[0][2]);\r\n    }\r\n    if (index1 >= 0 && index2 >= 0) {\r\n      lastObjectPoints = [index1 > index2 ? relation.angle[0][0] : relation.angle[0][2]];\r\n    }\r\n  } else {\r\n    lastObjectPoints = getDependentObject();\r\n  }\r\n\r\n  if (lastObjectPoints.length === RelationPointsMap.length) {\r\n    lastObjectPoints = [lastObjectPoints[0]];\r\n  }\r\n  if (relation.relation === 'song song' || relation.relation === 'vuông góc' || relation.relation === 'phân giác') {\r\n    lastObjectPoints = lastObjectPoints.filter(\r\n      (point: string): boolean => !dataViewModel.getNodeInPointsMapById(point)\r\n    );\r\n  }\r\n  lastObjectPoints.forEach((point) => {\r\n    const index = findIndexByNodeId(point, RelationPointsMap);\r\n    const currentNode = RelationPointsMap[index];\r\n    RelationPointsMap.forEach((node) => {\r\n      if (node.id !== point) {\r\n        RelationPointsMap[index] = {\r\n          ...currentNode,\r\n          dependentNodes: [\r\n            ...currentNode.dependentNodes,\r\n            ...createDependentNodeOfRelation(node.id, relation, lastObjectPoints)\r\n          ]\r\n        };\r\n      }\r\n    });\r\n  });\r\n\r\n  return RelationPointsMap;\r\n}\r\n\r\nfunction getDependentObject(): Array<string> {\r\n  let result: Array = [];\r\n  const lastNode = RelationPointsMap[RelationPointsMap.length - 1];\r\n  if (lastNode) {\r\n    result.push(lastNode.id);\r\n\r\n    lastNode.dependentNodes.forEach((node) => {\r\n      const nodeIndex = findIndexByNodeId(node.id, dataViewModel.getData.getPointsMap);\r\n      if (!result.includes(node.id) && nodeIndex !== -1 && !dataViewModel.getData.getPointsMap[nodeIndex].isStatic)\r\n        result.push(node.id);\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction findIndexByNodeId(id: string, map: Array<NodeType | NodeRelationType>): number {\r\n  for (let i = 0; i < map.length; i++) {\r\n    if (map[i].id === id) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction createDependentNodeOfRelation(\r\n  point: string,\r\n  relation: any,\r\n  exception: Array<string>\r\n): Array<NodeRelationType> {\r\n  const result: Array<NodeRelationType> = [];\r\n  RelationPointsMap.forEach((node: NodeType) => {\r\n    if (exception.includes(node.id)) return;\r\n    result.push({ id: node.id, relation });\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction createNode(id: string, dependentNodes?: Array<NodeRelationType>): any {\r\n  const node = { id, coordinate: { x: undefined, y: undefined, z: 0 }, isStatic: false };\r\n  const _dependentNodes = dependentNodes ? { dependentNodes } : { dependentNodes: [] };\r\n\r\n  return { ...node, ..._dependentNodes };\r\n}\r\n\r\nfunction updateMap(node: NodeType, map: Array<NodeType>) {\r\n  const index = findIndexByNodeId(node.id, map);\r\n  if (index !== -1) {\r\n    //merge dependentNodes\r\n    const oldNode = map[index];\r\n    map[index] = {\r\n      ...oldNode,\r\n      dependentNodes: [...oldNode.dependentNodes, ...node.dependentNodes]\r\n    };\r\n  } else {\r\n    map.push(node);\r\n    if (dataViewModel.getData.getPointsMap.length === 1) map[0].isStatic = true;\r\n  }\r\n}\r\n","// @flow\r\nimport { observable } from 'mobx';\r\nimport GConst from '../core/config/values';\r\n\r\nexport default class RelationInputModel {\r\n  @observable\r\n  value: string = '';\r\n\r\n  @observable\r\n  status: string = GConst.InputStatus.NORMAL;\r\n\r\n  constructor(value: string) {\r\n    this.value = value || '';\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport appData from '../Model/AppData';\r\nimport type { EquationType, PointDetailsType } from '../utils/types';\r\nimport { NodeType } from '../utils/types';\r\nimport GConst from '../core/config/values.js';\r\nimport { calculateIntersectionTwoCircleEquations, isIn, makeRoundCoordinate } from '../core/math/Math2D.js';\r\nimport { isQuadraticEquation } from '../utils/checker.js';\r\nimport { defineSentences } from '../core/definition/define';\r\nimport { defineInformation } from '../core/definition';\r\nimport { analyzeResult } from '../core/analysis/Analysis';\r\nimport RelationInputModel from '../Model/RelationInputModel';\r\nimport { observable, action, computed } from 'mobx';\r\nimport ErrorService from '../core/error/ErrorHandleService';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { isTwoEquationEqual } from '../core/math/Math2D';\r\nimport { getRandomValue } from '../core/math/Generation';\r\nimport { Operation } from '../core/math/MathOperation';\r\n\r\nconst NOT_FOUND = GConst.Number.NOT_FOUND;\r\nconst NOT_ENOUGH_SET = GConst.String.NOT_ENOUGH_SET;\r\n\r\nclass DataViewModel {\r\n  @observable\r\n  isReCalculated = false;\r\n\r\n  @observable\r\n  circlesData = {};\r\n\r\n  @observable\r\n  relationsInput: Array<RelationInputModel>;\r\n\r\n  inputData: Array<mixed> = [];\r\n\r\n  executedInputIndex: number;\r\n\r\n  @observable\r\n  executingRelation: mixed;\r\n\r\n  constructor(appData) {\r\n    this.data = appData;\r\n    this.relationsInput = [\r\n      new RelationInputModel('tam giác ABC'),\r\n      new RelationInputModel('(I) bàng tiếp ABC tại A'),\r\n      new RelationInputModel('AB cắt (I) tại F')\r\n    ];\r\n  }\r\n\r\n  @computed\r\n  get RelationsInput() {\r\n    return this.relationsInput;\r\n  }\r\n\r\n  @computed\r\n  get isInputEmpty(): boolean {\r\n    if (this.relationsInput.length === 1 && !this.relationsInput[0].value) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @action\r\n  resetInputsStatus() {\r\n    this.relationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.NORMAL;\r\n    });\r\n  }\r\n\r\n  @action\r\n  onInputChange(value: string, index: number) {\r\n    const newRelationInput = { ...this.relationsInput[index] };\r\n    newRelationInput.value = value;\r\n    this.relationsInput[index] = newRelationInput;\r\n    this.resetInputsStatus();\r\n  }\r\n\r\n  @action\r\n  addNewInput() {\r\n    this.relationsInput.push(new RelationInputModel(''));\r\n  }\r\n\r\n  @action\r\n  removeInput(index: number) {\r\n    this.relationsInput.splice(index, 1);\r\n  }\r\n\r\n  clear() {\r\n    this.data.clear();\r\n    this.inputData = [];\r\n    this.circlesData = {};\r\n    this.executedInputIndex = undefined;\r\n    this.executingRelation = undefined;\r\n  }\r\n\r\n  get getData() {\r\n    return this.data;\r\n  }\r\n\r\n  createPointDetails() {\r\n    this.data.getPointsMap.forEach((node) => {\r\n      const roots = this.isValidCoordinate(node.coordinate) ? [node.coordinate] : [];\r\n      this._updatePointDetails(node.id, {\r\n        setOfEquation: [],\r\n        roots: roots,\r\n        exceptedCoordinates: []\r\n      });\r\n    });\r\n  }\r\n\r\n  isNeedRandomCoordinate = (pointId: string): boolean => {\r\n    const roots = this.data.getPointDetails.get(pointId).roots;\r\n    if (roots) {\r\n      for (let i = 0; i < roots.length; i++) {\r\n        if (\r\n          this.data.getPointDirectionMap[pointId] ||\r\n          JSON.stringify(makeRoundCoordinate(roots[i])) ===\r\n            JSON.stringify(makeRoundCoordinate(this.getNodeInPointsMapById(pointId).coordinate))\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  updateCoordinate = (nodeId: string, coordinate: CoordinateType, f: number = 3): void => {\r\n    const index = this.getIndexOfNodeInPointsMapById(nodeId);\r\n    if (!coordinate) {\r\n      ErrorService.showError('200');\r\n    }\r\n\r\n    const _coordinate = {};\r\n    Object.keys(coordinate)\r\n      .sort()\r\n      .forEach((key: string) => {\r\n        _coordinate[key] = coordinate[key];\r\n      });\r\n    if (index !== NOT_FOUND) {\r\n      this.data.getPointsMap[index].coordinate = _coordinate;\r\n    }\r\n  };\r\n\r\n  isStaticNode = (node: NodeType): boolean => {\r\n    if (node.isStatic) return true;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (!this.isExecutedRelation(node.dependentNodes[i].relation)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return this.data.getExecutedNode.includes(node.id);\r\n  };\r\n\r\n  reExecuteNode = (arrayPoint: Array<string>) => {\r\n    this.isReCalculated = true;\r\n    this.getData.pointsMap.forEach((node: NodeType, index: number) => {\r\n      if (arrayPoint.includes(node.id)) {\r\n        return;\r\n      }\r\n      this.getData.pointsMap[index].dependentNodes.forEach((dependence: NodeRelationType, index: number) => {\r\n        if (dependence.relation.outputType === 'shape' && !dependence.relation.point && arrayPoint.length > 0) {\r\n          this.getData.pointsMap[index].dependentNodes[index] = { ...dependence, id: arrayPoint[0] };\r\n        }\r\n      });\r\n      this.getData.pointsMap[index].isStatic = false;\r\n    });\r\n    this.getData.__pointDetails__.clear();\r\n\r\n    this.getData.executedNode = arrayPoint;\r\n    const keepExecutedRelations = this.getData.executedRelations.filter(\r\n      (relation: mixed): boolean => relation.outputType === 'shape'\r\n    );\r\n    this.getData.executedRelations = keepExecutedRelations;\r\n  };\r\n\r\n  isExecutedRelation = (relation: any): boolean => {\r\n    for (let i = 0; i < this.data.getExecutedRelations.length; i++) {\r\n      if (JSON.stringify(relation) === JSON.stringify(this.data.getExecutedRelations[i])) return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  updateStaticNode = () => {\r\n    const pointsMap = this.data.getPointsMap.map((node: NodeType): NodeType => {\r\n      node.isStatic = this.isStaticNode(node);\r\n      return node;\r\n    });\r\n    this.data.setPointsMap = pointsMap;\r\n  };\r\n\r\n  updatePointsMap = (node: NodeType) => {\r\n    let index = this.getIndexOfNodeInPointsMapById(node.id);\r\n    this.data.getPointsMap[index] = node;\r\n  };\r\n\r\n  isPointsMapStatic = (): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (!this.data.getPointsMap[i].isStatic) return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  isValidCoordinate = (nodeId: string) => {\r\n    if (nodeId) {\r\n      const node = this.getNodeInPointsMapById(nodeId);\r\n      if (node) {\r\n        return node.coordinate.x !== undefined && node.coordinate.y !== undefined;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  getNextExecuteNode = (): NodeType => {\r\n    const clonePointsMap = this.data.pointsMap\r\n      .filter((node) => !this.data.executedNode.includes(node.id) && !this.isStaticNode(node))\r\n      .sort(this.sortNodeByPriority);\r\n\r\n    if (clonePointsMap.length > 0) return clonePointsMap[0];\r\n    return null;\r\n  };\r\n\r\n  sortNodeByPriority = (nodeOne: NodeType, nodeTwo: NodeType): number => {\r\n    const staticNodeOneCount = this.getDependentStaticNodeCount(nodeOne);\r\n    const nodeOneData = {\r\n      static: staticNodeOneCount,\r\n      nonStatic: nodeOne.dependentNodes.length - staticNodeOneCount,\r\n      dependence: nodeOne.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeOne),\r\n      index: this.getIndexOfNodeInPointsMap(nodeOne)\r\n    };\r\n\r\n    const staticNodeTwoCount = this.getDependentStaticNodeCount(nodeTwo);\r\n    const nodeTwoData = {\r\n      static: staticNodeTwoCount,\r\n      nonStatic: nodeTwo.dependentNodes.length - staticNodeTwoCount,\r\n      dependence: nodeTwo.dependentNodes.length,\r\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeTwo),\r\n      index: this.getIndexOfNodeInPointsMap(nodeTwo)\r\n    };\r\n\r\n    //get Max\r\n    const rankingOrderDesc = ['static', 'dependence'];\r\n\r\n    //get Min\r\n    const rankingOrderAsc = ['nonStatic', 'minRelationIndex', 'index'];\r\n\r\n    let rankOne = nodeOneData.static === nodeOneData.dependence ? '1' : '0';\r\n    let rankTwo = nodeTwoData.static === nodeTwoData.dependence ? '1' : '0';\r\n\r\n    rankingOrderDesc.forEach((key) => {\r\n      if (nodeOneData[key] > nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    rankingOrderAsc.forEach((key) => {\r\n      if (nodeOneData[key] < nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '0';\r\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\r\n        rankOne += '1';\r\n        rankTwo += '1';\r\n      } else {\r\n        rankOne += '0';\r\n        rankTwo += '1';\r\n      }\r\n    });\r\n\r\n    return parseInt(rankTwo) - parseInt(rankOne);\r\n  };\r\n\r\n  getMinIndexOfDependentNodeInRelationsList = (node: NodeType) => {\r\n    const indexArray = [];\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      indexArray.push(this.getIndexOfRelationInRelationsList(node.dependentNodes[i]));\r\n    }\r\n\r\n    return Math.min(...indexArray);\r\n  };\r\n\r\n  getIndexOfRelationInRelationsList = (relation: any): number => {\r\n    const list = this.data.getRelationsResult.shapes.concat(this.data.getRelationsResult.relations);\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (relation === list[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getDependentStaticNodeCount = (node: NodeType): number => {\r\n    let count = 0;\r\n    for (let i = 0; i < node.dependentNodes.length; i++) {\r\n      if (this.isStaticNodeById(node.dependentNodes[i].id)) count++;\r\n    }\r\n\r\n    return count;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMap = (node): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (node === this.data.getPointsMap[i]) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getIndexOfNodeInPointsMapById = (id: string): number => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) return i;\r\n    }\r\n    return NOT_FOUND;\r\n  };\r\n\r\n  getNodeInPointsMapById = (id: string): NodeType | null => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) {\r\n        return this.data.getPointsMap[i];\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  isStaticNodeById = (id: string): boolean => {\r\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\r\n      if (id === this.data.getPointsMap[i].id) {\r\n        return this.isStaticNode(this.data.getPointsMap[i]);\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  _calculateSet = (equations: Array<EquationType>) => {\r\n    if (equations.length === 2) {\r\n      return calculateIntersectionTwoCircleEquations(equations[0], equations[1]);\r\n    } else return NOT_ENOUGH_SET;\r\n  };\r\n\r\n  replaceSetOfEquation(pointId: string, searchEquation: EquationType, replaceEquation: EquationType) {\r\n    if (!this.data.getPointDetails.has(pointId)) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [],\r\n        roots: [],\r\n        exceptedCoordinates: []\r\n      });\r\n    }\r\n    const pointDetail = this.data.getPointDetails.get(pointId);\r\n    const setOfEquation = pointDetail.setOfEquation;\r\n    let isReplaceComplete = false;\r\n    setOfEquation.forEach((equation: EquationType, index: number) => {\r\n      if (isTwoEquationEqual(equation, searchEquation)) {\r\n        setOfEquation[index] = replaceEquation;\r\n        isReplaceComplete = true;\r\n      }\r\n    });\r\n\r\n    if (!isReplaceComplete) {\r\n      setOfEquation.push(replaceEquation);\r\n    }\r\n    if (setOfEquation.length === 1) {\r\n      return;\r\n    }\r\n    const roots = this._calculateSet(setOfEquation);\r\n\r\n    this.data.getPointDetails.set(pointId, {\r\n      ...pointDetail,\r\n      setOfEquation,\r\n      roots\r\n    });\r\n\r\n    if (roots.length > 0) {\r\n      let coordinate;\r\n      if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n        coordinate = roots[getRandomValue(0, roots.length)];\r\n      } else {\r\n        const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n        const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n        if (roots.length > 1 && typeof roots !== 'string') {\r\n          const rootsDirection = roots.map((root) => ({\r\n            coordinate: root,\r\n            isRight: root.x > staticPointCoordinate.x,\r\n            isUp: root.y < staticPointCoordinate.y\r\n          }));\r\n\r\n          const coordinateMatch = rootsDirection\r\n            .map((directionInfo) => {\r\n              let matchCount = 0;\r\n              if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                matchCount++;\r\n              }\r\n              if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                matchCount++;\r\n              }\r\n              return {\r\n                coordinate: directionInfo.coordinate,\r\n                matchCount\r\n              };\r\n            })\r\n            .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n          coordinate = coordinateMatch.coordinate;\r\n        } else {\r\n          if (typeof roots === 'string') {\r\n            return;\r\n          }\r\n          coordinate = roots[0];\r\n        }\r\n      }\r\n      dataViewModel.updateCoordinate(pointId, coordinate);\r\n    }\r\n  }\r\n\r\n  _updatePointDetails(pointId: string, pointDetails: PointDetailsType) {\r\n    this.data.getPointDetails.set(pointId, {\r\n      setOfEquation: pointDetails.setOfEquation,\r\n      roots: pointDetails.roots,\r\n      exceptedCoordinates: pointDetails.exceptedCoordinates\r\n    });\r\n  }\r\n\r\n  uniqueSetOfEquation(equations: any[]): any[] {\r\n    let result = [];\r\n\r\n    equations.forEach((equation) => {\r\n      for (let i = 0; i < result.length; i++) {\r\n        if (JSON.stringify(equation) === JSON.stringify(result[i])) return;\r\n      }\r\n      result.push(equation);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  executePointDetails(pointId: string, equation: EquationType) {\r\n    let sum = 0;\r\n    Object.keys(equation)\r\n      .map((key: string): number => equation[key])\r\n      .forEach((value: number) => {\r\n        sum += Math.abs(value);\r\n      });\r\n    if (sum === 0) {\r\n      return;\r\n    }\r\n\r\n    let isFirst = false;\r\n    if (!this.data.getPointDetails.has(pointId)) {\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: [],\r\n        roots: [],\r\n        exceptedCoordinates: []\r\n      });\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length <= 1) {\r\n      let newSetOfEquation = [...this.data.getPointDetails.get(pointId).setOfEquation, equation];\r\n      if (newSetOfEquation.length === 2) {\r\n        if (isTwoEquationEqual(newSetOfEquation[0], newSetOfEquation[1])) {\r\n          newSetOfEquation = newSetOfEquation[0];\r\n        }\r\n      }\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: newSetOfEquation,\r\n        roots: this.data.getPointDetails.get(pointId).roots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n      isFirst = true;\r\n    }\r\n\r\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length === 2) {\r\n      if (isQuadraticEquation(equation) && !isFirst) {\r\n        for (let i = 0; i < 2; i++) {\r\n          if (!isQuadraticEquation(this.data.getPointDetails.get(pointId).setOfEquation[i])) {\r\n            this.data.getPointDetails.get(pointId).setOfEquation[i] = equation;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const roots = this._calculateSet(this.data.getPointDetails.get(pointId).setOfEquation);\r\n      const currentRoots = this.data.getPointDetails.get(pointId).roots;\r\n\r\n      const finalRoots = typeof roots === 'string' ? currentRoots : currentRoots.concat(roots);\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: finalRoots,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n    }\r\n\r\n    let temp = this.data.getPointDetails.get(pointId).roots;\r\n\r\n    if (typeof temp === 'string') {\r\n      ErrorService.showError('500');\r\n      return;\r\n    }\r\n\r\n    temp = temp.filter((root) => {\r\n      return isIn(root, equation);\r\n    });\r\n\r\n    if (temp.length > 0) {\r\n      // TODO: Add exception\r\n      this._updatePointDetails(pointId, {\r\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\r\n        roots: temp,\r\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\r\n      });\r\n\r\n      if (temp.length > 0) {\r\n        let coordinate;\r\n        if (dataViewModel.isNeedRandomCoordinate(pointId)) {\r\n          coordinate = temp[getRandomValue(0, temp.length)];\r\n        } else {\r\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\r\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\r\n          if (temp.length > 1) {\r\n            const rootsDirection = temp.map((root) => ({\r\n              coordinate: root,\r\n              isRight: root.x > staticPointCoordinate.x,\r\n              isUp: root.y < staticPointCoordinate.y\r\n            }));\r\n\r\n            const coordinateMatch = rootsDirection\r\n              .map((directionInfo) => {\r\n                let matchCount = 0;\r\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\r\n                  matchCount++;\r\n                }\r\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\r\n                  matchCount++;\r\n                }\r\n                return {\r\n                  coordinate: directionInfo.coordinate,\r\n                  matchCount\r\n                };\r\n              })\r\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\r\n\r\n            coordinate = coordinateMatch.coordinate;\r\n          } else {\r\n            coordinate = temp[0];\r\n          }\r\n        }\r\n        dataViewModel.updateCoordinate(pointId, coordinate);\r\n      }\r\n    }\r\n  }\r\n\r\n  getInformation(string: string): mixed {\r\n    const _string = '_ '.concat(string.concat(' _'));\r\n    let isMatching = false;\r\n    let preProgress = [];\r\n    Object.keys(defineSentences).forEach((key) => {\r\n      defineSentences[key].forEach((sentence) => {\r\n        sentence = '_ '.concat(sentence.concat(' _'));\r\n\r\n        if (isMatching) return;\r\n        const value = this.getBasicInformation(_string, sentence, key);\r\n        if (Object.keys(value).length > 0) {\r\n          isMatching = true;\r\n          preProgress = value;\r\n          preProgress['outputType'] = key;\r\n        }\r\n      });\r\n    });\r\n    const type = preProgress.outputType;\r\n\r\n    const result = defineInformation(preProgress);\r\n    if (result.Error || !result.outputType) {\r\n      ErrorService.showError('300');\r\n      return;\r\n    }\r\n    if (result.point && result.point.length > 3) {\r\n      ErrorService.showError('301');\r\n      return;\r\n    }\r\n\r\n    // add operation for define type\r\n    if (type === 'define') {\r\n      GConst.Others.OPERATIONS.forEach((operation) => {\r\n        if (result.operation) return;\r\n        if (string.includes(operation)) {\r\n          result.operation = operation;\r\n          if (operation === '=' && !result.value) {\r\n            result.value = '1';\r\n            result.operation = '*';\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getBasicInformation(string, _defineSentence, type) {\r\n    let others = _defineSentence.match(new RegExp(GConst.Regex.OTHER, 'g'));\r\n    let params = _defineSentence.match(new RegExp(GConst.Regex.KEY, 'g'));\r\n\r\n    let result = {};\r\n\r\n    params.forEach((key) => {\r\n      result[key] = [];\r\n    });\r\n\r\n    for (let i = 0; i < params.length; i++) {\r\n      let start =\r\n        others[i]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n      let end =\r\n        others[i + 1]\r\n          .replace('+', '\\\\+')\r\n          .replace('-', '\\\\-')\r\n          .replace('*', '\\\\*') || '';\r\n\r\n      let param = string.match(new RegExp(start + '(.*)' + end));\r\n\r\n      if (param) result[params[i]].push(param[1]);\r\n\r\n      if (i === others.length - 1) {\r\n        let lastParam = string.match(new RegExp(end + '(.*)'));\r\n        if (lastParam) result[params[i + 1]].push(lastParam[1]);\r\n      }\r\n    }\r\n\r\n    if (this.getLength(result) === params.length) {\r\n      if (type === 'relation') result[type] = others[1].replace('_', '').trim();\r\n      return result;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  getLength(dictionary) {\r\n    let count = 0;\r\n    Object.keys(dictionary).forEach((key) => {\r\n      count += dictionary[key].length;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  getCircleEquation(centerId: string): EquationType {\r\n    console.log(this.circlesData, centerId);\r\n    return this.circlesData[centerId].equation;\r\n  }\r\n\r\n  getCircleCenterCoordinate(centerId: string): CoordinateType {\r\n    return this.circlesData[centerId].coordinate;\r\n  }\r\n\r\n  isCoordinateDuplicated(coordinate: CoordinateType): boolean {\r\n    const stringifyCoordinate = JSON.stringify(coordinate);\r\n    let result = false;\r\n    this.getData.pointsMap.forEach((node: NodeType) => {\r\n      const key = node.id;\r\n      if (result) {\r\n        return;\r\n      }\r\n      if (JSON.stringify(stringifyCoordinate) === JSON.stringify(this.getNodeInPointsMapById(key).coordinate)) {\r\n        result = true;\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  analyzeInput() {\r\n    this.circlesData = {};\r\n    const data = this.RelationsInput.map((relationsInput: RelationInputModel): string => relationsInput.value)\r\n      // eslint-disable-next-line no-control-getBasicInformation\r\n      .filter((sentence) => !!sentence)\r\n      .map((sentence: string, index: number) => {\r\n        this.executedInputIndex = index;\r\n        const result = this.getInformation(sentence);\r\n        this.relationsInput[index].status = GConst.InputStatus.SUCCESS;\r\n        this.inputData.push(result);\r\n        return result;\r\n      });\r\n\r\n    let result = {\r\n      shapes: [],\r\n      relations: []\r\n    };\r\n    for (let i = 0; i < data.length; i++) {\r\n      let item = data[i];\r\n\r\n      if (item.outputType === 'shape') {\r\n        result.shapes.push(item);\r\n      } else {\r\n        result.relations.push(item);\r\n      }\r\n    }\r\n\r\n    this.data.setRelationsResult = result;\r\n\r\n    this.RelationsInput.forEach((input: RelationInputModel) => {\r\n      input.status = GConst.InputStatus.SUCCESS;\r\n    });\r\n    return analyzeResult(result);\r\n  }\r\n}\r\n\r\nconst dataViewModel = new DataViewModel(appData);\r\n\r\nexport default dataViewModel;\r\n","//@flow\r\n\r\nimport { observable, action, computed } from 'mobx';\r\nimport autobind from 'autobind-decorator';\r\n\r\nclass ContextMenuViewModel {\r\n  @observable\r\n  isContextShow: boolean = false;\r\n\r\n  @observable\r\n  currentInputIndex: number = null;\r\n\r\n  @action\r\n  showContextMenu() {\r\n    this.isContextShow = true;\r\n  }\r\n  @action\r\n  hideContextMenu() {\r\n    this.isContextShow = false;\r\n  }\r\n}\r\n\r\nexport default new ContextMenuViewModel();\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport './InputItem.scss';\r\nimport { Icon } from '../index';\r\nimport color from '../../../utils/color.scss';\r\nimport autobind from 'autobind-decorator';\r\nimport { observer } from 'mobx-react';\r\nimport ContextMenuViewModel from '../../../ViewModel/ContextMenuViewModel';\r\nimport dataViewModel from '../../../ViewModel/DataViewModel';\r\nimport RelationInputModel from '../../../Model/RelationInputModel';\r\n\r\ntype PropsType = {\r\n  index: number,\r\n  value: string,\r\n  status: string,\r\n  onValueChange: void,\r\n  onSubmit: void,\r\n  onBackspace: void\r\n};\r\n\r\ntype StateType = {\r\n  shouldRemove: boolean,\r\n  isEmpty: boolean,\r\n  popupX: number,\r\n  popupY: number\r\n};\r\n\r\nconst KEYCODE = Object.freeze({\r\n  BACKSPACE: 8,\r\n  ENTER: 13\r\n});\r\n\r\n@observer\r\nclass InputItem extends React.Component<PropsType, StateType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    this.state = {\r\n      shouldRemove: true,\r\n      isEmpty: true,\r\n      popupX: 0,\r\n      popupY: 0\r\n    };\r\n  }\r\n  inputRef: ReactRefs = React.createRef();\r\n\r\n  focus() {\r\n    if (this.inputRef.current) {\r\n      this.inputRef.current.focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onChange(e: React.FormEvent<HTMLInputElement>) {\r\n    const value = e.currentTarget.value;\r\n    const { onValueChange } = this.props;\r\n\r\n    if (value.length === 0) {\r\n      if (!this.state.isEmpty) {\r\n        this.setState({ isEmpty: true });\r\n      }\r\n    } else {\r\n      this.setState({\r\n        isEmpty: false,\r\n        shouldRemove: false\r\n      });\r\n    }\r\n    if (onValueChange) {\r\n      onValueChange(value);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onKeyUp(e: React.KeyboardEvent<FormControl>) {\r\n    const { onBackspace, onSubmit, value } = this.props;\r\n\r\n    if (e.keyCode === KEYCODE.ENTER) {\r\n      if (onSubmit) {\r\n        onSubmit();\r\n      }\r\n    } else if (e.keyCode === KEYCODE.BACKSPACE) {\r\n      if (this.state.isEmpty && !this.state.shouldRemove) {\r\n        this.setState({\r\n          shouldRemove: true\r\n        });\r\n        return;\r\n      }\r\n      if (onBackspace) {\r\n        onBackspace();\r\n      }\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  handleClose() {\r\n    ContextMenuViewModel.hideContextMenu();\r\n    ContextMenuViewModel.currentInputIndex = null;\r\n  }\r\n\r\n  @autobind\r\n  onOpenContextMenu(e: SyntheticEvent) {\r\n    e.preventDefault();\r\n    e.persist();\r\n    ContextMenuViewModel.hideContextMenu();\r\n    ContextMenuViewModel.currentInputIndex = this.props.index;\r\n    setTimeout(() => {\r\n      ContextMenuViewModel.showContextMenu();\r\n      this.setState({ popupX: e.pageX, popupY: e.clientY });\r\n    }, 100);\r\n    return false;\r\n  }\r\n\r\n  @autobind\r\n  onAddInputBefore() {\r\n    const { index } = this.props;\r\n    dataViewModel.RelationsInput.splice(index, 0, new RelationInputModel());\r\n    this.handleClose();\r\n  }\r\n\r\n  @autobind\r\n  onDeleteInput() {\r\n    const { index } = this.props;\r\n    dataViewModel.removeInput(index);\r\n    this.handleClose();\r\n  }\r\n\r\n  @autobind\r\n  renderContextMenu(): React.Node {\r\n    const { isContextShow, currentInputIndex } = ContextMenuViewModel;\r\n    if (!isContextShow || currentInputIndex !== this.props.index) {\r\n      return;\r\n    }\r\n    return (\r\n      <div className=\"context-menu\" style={{ left: this.state.popupX, top: this.state.popupY }}>\r\n        <div onMouseDown={this.onAddInputBefore} className=\"context-menu-item\">\r\n          <Icon name=\"icAdd\" width={30} height={30} color=\"black\" />\r\n          <p>Thêm dòng phía trên</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  render(): React.Node {\r\n    const { status, value } = this.props;\r\n    return (\r\n      <div className=\"input-item\">\r\n        {this.renderContextMenu()}\r\n        <div onContextMenu={this.onOpenContextMenu} className=\"input-group input-container\">\r\n          <div className=\"input-remove-btn\" onClick={this.onDeleteInput}>\r\n            <Icon name=\"inputError\" width={10} height={10} color={'#7f8c8d'} />\r\n          </div>\r\n          <div className=\"input-group-prepend input-status\">\r\n            <span className={`input-group-text ${status.toLowerCase()}`} id=\"basic-addon1\">\r\n              <Icon width={15} height={15} name={`input${status}`} color={color[`input${status}`]} />\r\n            </span>\r\n          </div>\r\n          <input\r\n            type=\"text\"\r\n            onBlur={this.handleClose}\r\n            onClick={this.handleClose}\r\n            ref={this.inputRef}\r\n            onChange={this.onChange}\r\n            onKeyUp={this.onKeyUp}\r\n            value={value}\r\n            className={`form-control ${status.toLowerCase()}`}\r\n            aria-describedby=\"basic-addon1\"></input>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default InputItem;\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport { inputSuccess, inputError, inputNormal, icInformation, icRemove, icEdit, icAdd, icPlusBold } from './Svg';\r\n\r\ntype PropsType = {\r\n  name: string,\r\n  color: string,\r\n  width: number,\r\n  height: number\r\n};\r\n\r\nconst iconList = {\r\n  inputSuccess,\r\n  inputError,\r\n  inputNormal,\r\n  icInformation,\r\n  icRemove,\r\n  icEdit,\r\n  icAdd,\r\n  icPlusBold\r\n};\r\n\r\nexport default class Icon extends React.Component<PropsType> {\r\n  render(): React.Node {\r\n    const { name, width, height, color } = this.props;\r\n    const icon = iconList[name];\r\n    return (\r\n      <svg width={width} height={height} viewBox={icon.viewBox}>\r\n        {icon.svg({ color })}\r\n      </svg>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\n\r\nexport const inputSuccess = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M337.222 22.952c-15.912-8.568-33.66 7.956-44.064 17.748-23.867 23.256-44.063 50.184-66.708 74.664-25.092 26.928-48.348 53.856-74.052 80.173-14.688 14.688-30.6 30.6-40.392 48.96-22.032-21.421-41.004-44.677-65.484-63.648C28.774 167.385-.602 157.593.01 190.029c1.224 42.229 38.556 87.517 66.096 116.28 11.628 12.24 26.928 25.092 44.676 25.704 21.42 1.224 43.452-24.48 56.304-38.556 22.645-24.48 41.005-52.021 61.812-77.112 26.928-33.048 54.468-65.485 80.784-99.145 16.524-20.808 68.544-72.217 27.54-94.248zM26.937 187.581c-.612 0-1.224 0-2.448.611-2.448-.611-4.284-1.224-6.732-2.448 1.836-1.224 4.896-.612 9.18 1.837z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const inputError = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color}\r\n      d=\"M285.368 234.691L459.36 60.697c13.895-13.88 13.895-36.395 0-50.275-13.881-13.895-36.38-13.895-50.275 0L235.091 184.416 61.082 10.421c-13.866-13.895-36.395-13.895-50.275 0-13.88 13.881-13.88 36.395 0 50.275l174.01 173.995L10.421 409.085c-13.895 13.895-13.895 36.395 0 50.275 6.94 6.955 16.043 10.425 25.145 10.425 9.088 0 18.19-3.47 25.132-10.425L235.09 284.967l173.995 173.995c6.955 6.94 16.043 10.425 25.145 10.425 9.088 0 18.19-3.485 25.131-10.425 13.895-13.88 13.895-36.38 0-50.275L285.367 234.691z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 469.785 469.785'\r\n};\r\n\r\nexport const inputNormal = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M370.59 250.973c-5.524 0-10 4.476-10 10v88.789c-.02 16.562-13.438 29.984-30 30H50c-16.563-.016-29.98-13.438-30-30V89.172c.02-16.559 13.438-29.98 30-30h88.79c5.523 0 10-4.477 10-10 0-5.52-4.477-10-10-10H50c-27.602.031-49.969 22.398-50 50v260.594c.031 27.601 22.398 49.968 50 50h280.59c27.601-.032 49.969-22.399 50-50v-88.793c0-5.524-4.477-10-10-10zm0 0\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M376.629 13.441c-17.574-17.574-46.067-17.574-63.64 0L134.581 191.848a9.997 9.997 0 0 0-2.566 4.402l-23.461 84.7a9.997 9.997 0 0 0 12.304 12.308l84.7-23.465a9.997 9.997 0 0 0 4.402-2.566l178.402-178.41c17.547-17.587 17.547-46.055 0-63.641zM156.37 198.348L302.383 52.332l47.09 47.09-146.016 146.016zm-9.406 18.875l37.62 37.625-52.038 14.418zM374.223 74.676L363.617 85.28l-47.094-47.094 10.61-10.605c9.762-9.762 25.59-9.762 35.351 0l11.739 11.734c9.746 9.774 9.746 25.59 0 35.36zm0 0\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 352.62 352.62'\r\n};\r\n\r\nexport const icInformation = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color}\r\n        d=\"M194 142.8c.8 1.6 1.6 3.2 2.4 4.4.8 1.2 2 2.4 2.8 3.6 1.2 1.2 2.4 2.4 4 3.6 1.2.8 2.8 2 4.8 2.4 1.6.8 3.2 1.2 5.2 1.6 2 .4 3.6.4 5.2.4s3.6 0 5.2-.4 3.2-.8 4.4-1.6h.4c1.6-.8 3.2-1.6 4.8-2.8 1.2-.8 2.4-2 3.6-3.2l.4-.4c1.2-1.2 2-2.4 2.8-3.6s1.6-2.4 2-4c0-.4 0-.4.4-.8.8-1.6 1.2-3.6 1.6-5.2.4-1.6.4-3.6.4-5.2s0-3.6-.4-5.2-.8-3.2-1.6-5.2c-1.2-2.8-2.8-5.2-4.8-7.2l-.8-.8c-1.2-1.2-2.4-2-4-3.2-1.6-.8-2.8-1.6-4.4-2.4-1.6-.8-3.2-1.2-4.8-1.6-2-.4-3.6-.4-5.2-.4s-3.6 0-5.2.4-3.2.8-4.8 1.6h-.4c-1.6.8-3.2 1.6-4.4 2.4-1.6 1.2-2.8 2-4 3.2-1.2 1.2-2.4 2.4-3.2 3.6-.8 1.2-1.6 2.8-2.4 4.4-.8 1.6-1.2 3.2-1.6 4.8-.4 2-.4 3.6-.4 5.2s0 3.6.4 5.2c.4 3.2 1.2 4.8 1.6 6.4zM249.6 289.2h-9.2v-98c0-5.6-4.4-10.4-10.4-10.4h-42c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h8.4v66.4H188c-5.6 0-10.4 4.4-10.4 10.4v21.6c0 5.6 4.4 10.4 10.4 10.4h61.6c5.6 0 10.4-4.4 10.4-10.4V300c0-6-4.8-10.8-10.4-10.8z\"\r\n      />\r\n      <path\r\n        fill={props.color}\r\n        d=\"M218.8 0C98 0 0 98 0 218.8s98 218.8 218.8 218.8 218.8-98 218.8-218.8S339.6 0 218.8 0zm0 408.8c-104.8 0-190-85.2-190-190s85.2-190 190-190 190 85.2 190 190-85.2 190-190 190z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 437.6 427.6'\r\n};\r\n\r\nexport const icEdit = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M328.883 89.125l107.59 107.589-272.34 272.34L56.604 361.465l272.279-272.34zm189.23-25.948l-47.981-47.981c-18.543-18.543-48.653-18.543-67.259 0l-45.961 45.961 107.59 107.59 53.611-53.611c14.382-14.383 14.382-37.577 0-51.959zM.3 512.69c-1.958 8.812 5.998 16.708 14.811 14.565l119.891-29.069L27.473 390.597.3 512.69z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 528.899 528.899'\r\n};\r\n\r\nexport const icRemove = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fill={props.color || '#dcdcdc'}\r\n        d=\"M465.167 211.613H26.69c-8.424 0-26.69 11.439-26.69 34.316s18.267 34.316 26.69 34.316H465.169c8.421 0 26.689-11.439 26.689-34.316s-18.268-34.316-26.691-34.316z\"\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 491.858 491.858'\r\n};\r\n\r\nexport const icAdd = {\r\n  svg: (props): React.Node => (\r\n    <g>\r\n      <path\r\n        fillRule=\"evenodd\"\r\n        clipRule=\"evenodd\"\r\n        d=\"M34.525 19.11l.398.038a17.705 17.705 0 000-3.296l-.398.037-.398.038a16.903 16.903 0 010 3.146l.398.038zm-.333-5.342l.39-.087a17.364 17.364 0 00-1.017-3.133l-.367.16-.367.158c.413.954.74 1.953.97 2.989l.39-.087zm-1.97-4.974l.343-.203a17.556 17.556 0 00-1.938-2.664l-.3.265-.3.264a16.76 16.76 0 011.85 2.542l.344-.204zm-3.414-4.121l.265-.3a17.551 17.551 0 00-2.663-1.938l-.204.344-.204.344a16.755 16.755 0 012.542 1.85l.264-.3zm-4.515-2.87l.159-.368c-1-.433-2.047-.775-3.133-1.017l-.087.39-.087.39c1.036.231 2.035.558 2.989.971l.159-.367zM19.11.474l.037-.398a17.718 17.718 0 00-3.296 0l.037.398.038.398a16.919 16.919 0 013.146 0l.038-.398zm-5.343.333l-.087-.39a17.365 17.365 0 00-3.133 1.017l.16.367.158.367c.954-.413 1.953-.74 2.989-.97l-.087-.39zm-4.974 1.97l-.203-.343c-.95.562-1.841 1.212-2.664 1.938l.265.3.264.3a16.756 16.756 0 012.542-1.85l-.204-.344zM4.673 6.193l-.3-.265a17.556 17.556 0 00-1.938 2.664l.344.203.344.204a16.756 16.756 0 011.85-2.542l-.3-.264zm-2.87 4.515l-.368-.159c-.433 1-.775 2.047-1.017 3.133l.39.087.39.087c.231-1.036.558-2.036.971-2.989l-.367-.159zM0 17.5c0-.556.026-1.105.077-1.648l.398.037.398.038a16.919 16.919 0 000 3.146l-.398.038-.398.037A17.718 17.718 0 010 17.5zm.808 3.732l-.39.087a17.365 17.365 0 001.017 3.133l.367-.16.367-.158a16.565 16.565 0 01-.97-2.989l-.39.087zm1.97 4.974l-.343.204a17.55 17.55 0 001.938 2.663l.3-.265.3-.264a16.755 16.755 0 01-1.85-2.542l-.344.204zm3.414 4.121l-.265.3a17.556 17.556 0 002.664 1.938l.203-.344.204-.344a16.76 16.76 0 01-2.542-1.85l-.264.3zm4.515 2.87l-.159.368c1 .433 2.047.775 3.133 1.017l.087-.39.087-.39a16.563 16.563 0 01-2.989-.971l-.159.367zm5.182 1.328l-.037.398a17.705 17.705 0 003.296 0l-.037-.398-.038-.398a16.903 16.903 0 01-3.146 0l-.038.398zm5.343-.333l.087.39a17.364 17.364 0 003.133-1.017l-.16-.367-.158-.367c-.954.413-1.953.74-2.989.97l.087.39zm4.974-1.97l.204.343c.949-.562 1.84-1.212 2.663-1.938l-.265-.3-.264-.3a16.76 16.76 0 01-2.542 1.85l.204.344zm4.121-3.414l.3.265a17.552 17.552 0 001.938-2.663l-.344-.204-.344-.204a16.76 16.76 0 01-1.85 2.542l.3.264zm2.87-4.515l.368.159c.433-1 .775-2.047 1.017-3.133l-.39-.087-.39-.087a16.563 16.563 0 01-.971 2.989l.367.159zM17.7 9.723a.5.5 0 01.5.5V17h7a.5.5 0 010 1h-7v6.778a.5.5 0 01-1 0V18h-7a.5.5 0 010-1h7v-6.778a.5.5 0 01.5-.5z\"\r\n        fill={props.color || '#dcdcdc'}\r\n      />\r\n    </g>\r\n  ),\r\n  viewBox: '0 0 35 35'\r\n};\r\n\r\nexport const icPlusBold = {\r\n  svg: (props): React.Node => (\r\n    <path\r\n      fill={props.color || '#000'}\r\n      d=\"M37.059 16H26V4.941C26 2.224 23.718 0 21 0s-5 2.224-5 4.941V16H4.941C2.224 16 0 18.282 0 21s2.224 5 4.941 5H16v11.059C16 39.776 18.282 42 21 42s5-2.224 5-4.941V26h11.059C39.776 26 42 23.718 42 21s-2.224-5-4.941-5z\"\r\n    />\r\n  ),\r\n  viewBox: '0 0 42 42'\r\n};\r\n","// @flow\r\n\r\nimport * as React from 'react';\r\nimport Toggle from 'react-bootstrap-toggle';\r\nimport { Button, Dropdown, DropdownButton } from 'react-bootstrap';\r\nimport autobind from 'autobind-decorator';\r\nimport { Icon } from '../index';\r\nimport type { DrawingSegmentType } from '../../../utils/types';\r\nimport './SegmentSetting.scss';\r\n\r\ntype PropsType = {\r\n  value?: DrawingSegmentType,\r\n  data: Array<string>,\r\n  onDone: void,\r\n  onDelete: void,\r\n  onVisibleChange: void\r\n};\r\n\r\ntype StateType = {\r\n  start: string,\r\n  end: string,\r\n  visible: boolean,\r\n  isEditMode: boolean,\r\n  isCreateMode: boolean,\r\n  isMouseHoverEdition: boolean,\r\n  isMouseHoverDeletion: boolean,\r\n};\r\n\r\nclass SegmentSetting extends React.Component<PropsType, StateType> {\r\n  constructor(props: PropsType) {\r\n    super(props);\r\n    const start = props.value ? props.value.name[0] : '';\r\n    const end = props.value ? props.value.name[1] : '';\r\n    this.state = {\r\n      start,\r\n      end,\r\n      visible: true,\r\n      isEditMode: !props.value,\r\n      isCreateMode: !props.value,\r\n      isMouseHoverEdition: false,\r\n      isMouseHoverDeletion: false,\r\n    };\r\n  }\r\n\r\n  @autobind\r\n  onDone() {\r\n    const {start, end} = this.state;\r\n    const {onDone} = this.props;\r\n\r\n    if (onDone) {\r\n      onDone({name: [start, end].sort().join(''), visible: true});\r\n    }\r\n    this.setState({isEditMode: false});\r\n  }\r\n\r\n  @autobind\r\n  onDelete() {\r\n    const {onDelete} = this.props;\r\n    if (onDelete) {\r\n      onDelete();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onVisibleChange(visible: boolean) {\r\n    const {onVisibleChange, value} = this.props;\r\n    if (onVisibleChange) {\r\n      onVisibleChange({name: value.name, visible: !value.visible});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  getIndexInData(dropdownIndex: string, filterValue: string): number {\r\n    const {data} = this.props;\r\n    const filterValueIndex = data.indexOf(filterValue);\r\n    if (filterValueIndex < 0) {\r\n      return dropdownIndex;\r\n    }\r\n    return filterValueIndex > dropdownIndex ? dropdownIndex : parseInt(dropdownIndex) + 1;\r\n  }\r\n\r\n  @autobind\r\n  onStartPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    const {start, end} = this.state;\r\n    const newStartValue = data[index];\r\n    if (newStartValue === end) {\r\n      this.setState({start: newStartValue, end: start});\r\n    } else {\r\n      this.setState({start: newStartValue});\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onEndPointSelect(index: string) {\r\n    const {data} = this.props;\r\n    this.setState({end: data[this.getIndexInData(index, this.state.start)]});\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverEdition() {\r\n    this.setState({isMouseHoverEdition: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveEdition() {\r\n    this.setState({isMouseHoverEdition: false})\r\n  }\r\n\r\n  @autobind\r\n  mouseHoverDeletion() {\r\n    this.setState({isMouseHoverDeletion: true})\r\n  }\r\n\r\n  @autobind\r\n  mouseLeaveDeletion() {\r\n    this.setState({isMouseHoverDeletion: false})\r\n  }\r\n\r\n  @autobind\r\n  onChangeContentState() {\r\n    const {isEditMode, start, end} = this.state;\r\n    if (!start || !end) {\r\n      return;\r\n    }\r\n    this.setState({isEditMode: !isEditMode});\r\n  }\r\n\r\n  @autobind\r\n  renderDropdown(value: string, data: Array<string>, onSelect: void): React.Node {\r\n    return (\r\n      <DropdownButton title={value || 'Chọn điểm'} id={`segment-dropdown`} onSelect={onSelect}>\r\n        {data.map((item: string, index: number): React.Node => (\r\n          <Dropdown.Item key={`Drop-item-${index}`} eventKey={`${index}`}>\r\n            {item}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderEditContent(): React.Node {\r\n    const {data} = this.props;\r\n    const {start, end, isCreateMode} = this.state;\r\n    return (\r\n      <div className=\"content-edit\">\r\n        <div className=\"drop-down-container\">\r\n          <div className={\"col-6 p-0\"}>\r\n            {this.renderDropdown(start, data, this.onStartPointSelect)}\r\n          </div>\r\n          <div className=\"col-6 p-0 right-drop-down\">\r\n            {this.renderDropdown(end, data.filter((item) => item !== this.state.start), this.onEndPointSelect)}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"button-container mt-1\">\r\n          <div className={\"col-6 p-0 d-flex justify-content-between\"}>\r\n            <Button className={\"btn-cancel\"} onClick={isCreateMode ? this.onDelete : this.onChangeContentState}>\r\n              HỦY\r\n            </Button>\r\n            <Button className={\"btn-update\"} variant={`${isCreateMode ? 'link' : 'success'}`} disabled={!(start && end)}\r\n                    onClick={this.onDone}>\r\n              {isCreateMode ? 'THÊM' : 'CẬP NHẬT'}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderShowContent(): React.Node {\r\n    const {\r\n      value: {name, visible}\r\n    } = this.props;\r\n    return (\r\n      <div className=\"content-show\">\r\n        <div className=\"content\">\r\n          <div className={\"segment-edit-name col-8\"}>\r\n            <p>{name}</p>\r\n          </div>\r\n\r\n          <div className={\"segment-edit-controller col-4\"}>\r\n            <Toggle\r\n              onstyle=\"success\"\r\n              offstyle=\"danger\"\r\n              handleClassName=\"toggle-handler\"\r\n              onClick={this.onVisibleChange}\r\n              off=\"HIỆN\"\r\n              on=\"ẨN\"\r\n              active={visible}\r\n            />\r\n\r\n            <div onClick={this.onChangeContentState}\r\n                 onMouseLeave={this.mouseLeaveEdition}\r\n                 onMouseOver={this.mouseHoverEdition}\r\n                 onMouseDown={this.mouseLeaveEdition}>\r\n              {\r\n                this.state.isMouseHoverEdition ?\r\n                  <Icon name={'icEdit'} color={'#218838'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icEdit'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n\r\n            <div onClick={this.onDelete}\r\n                 onMouseOver={this.mouseHoverDeletion}\r\n                 onMouseLeave={this.mouseLeaveDeletion}\r\n                 onMouseDown={this.mouseLeaveDeletion}>\r\n              {\r\n                this.state.isMouseHoverDeletion ?\r\n                  <Icon name={'icRemove'} color={'#dc3545'} width={16} height={16}/>\r\n                  :\r\n                  <Icon name={'icRemove'} color={'#757575'} width={16} height={16}/>\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  @autobind\r\n  renderContent(): React.Node {\r\n    const {isEditMode} = this.state;\r\n    if (isEditMode) {\r\n      return this.renderEditContent();\r\n    }\r\n\r\n    return this.renderShowContent();\r\n  }\r\n\r\n  render(): React.Node {\r\n    const {style} = this.props;\r\n    const {isEditMode, isCreateMode} = this.state;\r\n\r\n    return (\r\n      <div className=\"segment-setting\" style={{...style}}>\r\n        <div className=\"container\">\r\n          {isEditMode && (\r\n            <div className=\"title\">\r\n              <p>{`${isCreateMode ? 'Thêm' : 'Cập nhật'} đoạn thẳng :`}</p>\r\n            </div>\r\n          )}\r\n          {this.renderContent()}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SegmentSetting;\r\n","class Geom {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  toString() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nexport { Geom };\r\n","import { Geom } from './geom';\r\n\r\nclass Point extends Geom {\r\n  constructor(name, x, y) {\r\n    if (typeof y === 'undefined') {\r\n      y = x;\r\n      x = name;\r\n      name = null;\r\n    }\r\n    super(name);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.free = true;\r\n  }\r\n\r\n  toString() {\r\n    return super.toString() + '(' + this.x + ',' + this.y + ')';\r\n  }\r\n\r\n  /* shorthand function for constructing a point from coodinates */\r\n  static P(name, x, y) {\r\n    return new Point(name, x, y);\r\n  }\r\n}\r\n\r\nexport { Point };\r\n","export { distance, distanceSquared };\r\n\r\n/* returns the Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distance(p1, p2) {\r\n  return Math.sqrt(distanceSquared(p1, p2));\r\n}\r\n\r\n/* returns the squared Euclidean distance between (p1.x, p1.y) and (p2.x, p2.y) */\r\nfunction distanceSquared(p1, p2) {\r\n  let dx = p1.x - p2.x,\r\n    dy = p1.y - p2.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n","import { Geom } from './geom';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nclass Circle extends Geom {\r\n  constructor(name, center, a) {\r\n    if (typeof a === 'undefined') {\r\n      a = center;\r\n      center = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    this.center = center;\r\n    if (a instanceof Point) {\r\n      this._fromCenterAndBoundaryPoint(center, a);\r\n    } else if (typeof a === 'number') {\r\n      this._fromCenterAndRadius(center, a);\r\n    }\r\n  }\r\n\r\n  _fromCenterAndRadius(center, radius) {\r\n    this.radius = radius;\r\n    Object.defineProperties(this, {\r\n      radiussq: {\r\n        get() {\r\n          return this.radius * this.radius;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _fromCenterAndBoundaryPoint(center, boundaryPoint) {\r\n    this.boundaryPoint = boundaryPoint;\r\n    Object.defineProperties(this, {\r\n      radius: {\r\n        get() {\r\n          return distance(this.boundaryPoint, this.center);\r\n        }\r\n      },\r\n      radiussq: {\r\n        get() {\r\n          return distanceSquared(this.boundaryPoint, this.center);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    var w = Math.abs(x - this.center.x);\r\n    if (w > this.radius) return null;\r\n    if (w === this.radius) return new Point(x, this.center.y);\r\n\r\n    var h = Math.sqrt(this.radius * this.radius - w * w);\r\n    return [this.center.y + h, this.center.y - h];\r\n  }\r\n\r\n  contains(p) {\r\n    return distanceSquared(p, this.center) === this.radiussq;\r\n  }\r\n\r\n  toString() {\r\n    return 'Circle' + super.toString() + '[' + this.center.toString() + ';' + this.radius + ']';\r\n  }\r\n}\r\n\r\nexport { Circle };\r\n","import { Geom } from './geom';\r\n\r\nclass Line extends Geom {\r\n  constructor(name, p1, p2) {\r\n    if (typeof p2 === 'undefined') {\r\n      p2 = p1;\r\n      p1 = name;\r\n      name = null;\r\n    }\r\n\r\n    super(name);\r\n    if (!p2) {\r\n      this._p = p1.slice(0);\r\n    } else {\r\n      this._p = [p1, p2];\r\n    }\r\n\r\n    this._clip = false;\r\n\r\n    Object.defineProperties(this, {\r\n      // TODO: I don't like dx and dy on the line class...\r\n      dx: {\r\n        get() {\r\n          return this._p[1].x - this._p[0].x;\r\n        }\r\n      },\r\n      dy: {\r\n        get() {\r\n          return this._p[1].y - this._p[0].y;\r\n        }\r\n      },\r\n      theta: {\r\n        get() {\r\n          return Math.atan2(this.dy, this.dx);\r\n        }\r\n      },\r\n      m: {\r\n        get() {\r\n          if (this.dx === 0) return null;\r\n          else return this.dy / this.dx;\r\n        }\r\n      },\r\n\r\n      left: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      right: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].x, this._p[1].x) : null;\r\n        }\r\n      },\r\n      top: {\r\n        get() {\r\n          return this._clip ? Math.min(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      },\r\n      bottom: {\r\n        get() {\r\n          return this._clip ? Math.max(this._p[0].y, this._p[1].y) : null;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  y(x) {\r\n    if (this.dx === 0 || (this._clip && (this.left > x || this.right < x))) return null;\r\n    else return this._p[0].y + ((x - this._p[0].x) * this.dy) / this.dx;\r\n  }\r\n\r\n  x(y) {\r\n    if (this.dy === 0 || (this._clip && (this.top > y || this.bottom < y))) return null;\r\n    else return this._p[0].x + ((y - this._p[0].y) * this.dx) / this.dy;\r\n  }\r\n\r\n  contains(p) {\r\n    let onLine = this.dx !== 0 ? this.y(p.x) === p.y : this.x(p.y) === p.x;\r\n    return (\r\n      onLine && (!this._clip || (this.left <= p.x && p.x <= this.right && (this.top <= p.y && p.y <= this.bottom)))\r\n    );\r\n  }\r\n\r\n  toString() {\r\n    return 'Line' + super.toString() + '[' + this._p[0].toString() + ';' + this._p[1].toString() + ']';\r\n  }\r\n}\r\n\r\nexport { Line };\r\n","import { Line } from './line';\r\nimport { Point } from './point';\r\nimport { distance, distanceSquared } from '../calc';\r\n\r\nconst P = Point.P;\r\n\r\nclass Segment extends Line {\r\n  constructor(name, p1, p2) {\r\n    super(name, p1, p2);\r\n    this._clip = true;\r\n\r\n    Object.defineProperties(this, {\r\n      p: {\r\n        // TODO: clone point themselves?\r\n        get() {\r\n          return [].concat(this._p);\r\n        }\r\n      },\r\n\r\n      lengthsq: {\r\n        get() {\r\n          return distanceSquared(this._p[0], this._p[1]);\r\n        }\r\n      },\r\n\r\n      length: {\r\n        get() {\r\n          return distance(this._p[0], this._p[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  toString() {\r\n    return 'Segment' + super.toString();\r\n  }\r\n\r\n  /*\r\n  clip the given line (or line segment) to the given bounding box, where `bounds`\r\n  must have `left`, `right`, `top`, and `bottom` properties.\r\n  */\r\n  static clip(bounds, line) {\r\n    var [p1, p2] = line._p;\r\n\r\n    var left = line.y(bounds.left),\r\n      right = line.y(bounds.right),\r\n      top = line.x(bounds.top),\r\n      bottom = line.x(bounds.bottom);\r\n\r\n    if (p1.x > p2.x) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (left && left >= bounds.top && left <= bounds.bottom) {\r\n      // intersects left wall\r\n      p1 = P(bounds.left, left);\r\n    }\r\n    if (right && right >= bounds.top && right <= bounds.bottom) {\r\n      // intersects right wall\r\n      p2 = P(bounds.right, right);\r\n    }\r\n\r\n    if (p1.y > p2.y) {\r\n      let t = p1;\r\n      p1 = p2;\r\n      p2 = t;\r\n    }\r\n    if (top && top >= bounds.left && top <= bounds.right) {\r\n      // intersects top wall\r\n      p1 = P(top, bounds.top);\r\n    }\r\n    if (bottom && bottom >= bounds.left && bottom <= bounds.right) {\r\n      // intersects bottom wall\r\n      p2 = P(bottom, bounds.bottom);\r\n    }\r\n\r\n    let clipped = new Segment(null, p1, p2);\r\n    clipped.parent = line;\r\n    return clipped;\r\n  }\r\n}\r\n\r\nexport { Segment };\r\n","import { Point } from './model/point';\r\nimport { Line } from './model/line';\r\nimport { Segment } from './model/segment';\r\nimport { Circle } from './model/circle';\r\nimport { distanceSquared as dd } from './calc';\r\n\r\nimport uniq from 'uniq';\r\n\r\nlet P = Point.P;\r\n\r\n/* helpers */\r\nfunction comparePoints(p, q) {\r\n  return p.x === q.x && p.y === q.y ? 0 : 1;\r\n}\r\n\r\nfunction sq(a) {\r\n  return a * a;\r\n}\r\n\r\nfunction between(x, a, b) {\r\n  let left = Math.min(a, b),\r\n    right = Math.max(a, b);\r\n  return left <= x && x <= right;\r\n}\r\n\r\n/*\r\n  Intersection of two objects; returns an array, possibly empty, of \r\n  intersection points.\r\n*/\r\n\r\n/**\r\n * intersect - Find the intersection(s) of the given two objects.\r\n *\r\n * @param  {Geom} o1 first object\r\n * @param  {Geom} o2 second object\r\n * @return {Array.<Point>}    Points of intersection between the two objects.\r\n */\r\nfunction intersect(o1, o2) {\r\n  if (o1 instanceof Circle && o2 instanceof Circle)\r\n    // circle-circle\r\n    return intersectCircleCircle(o1, o2);\r\n  // if only one is a circle, it should be first.\r\n  else if (o2 instanceof Circle) return intersect(o2, o1);\r\n  else if (o1 instanceof Circle && o2 instanceof Segment)\r\n    // circle-segment\r\n    return intersectCircleLine(o1, o2, true);\r\n  else if (o1 instanceof Circle && o2 instanceof Line)\r\n    // circle-line\r\n    return intersectCircleLine(o1, o2, false);\r\n  else if (o1 instanceof Segment && o2 instanceof Segment)\r\n    // segment-segment\r\n    return intersectLineLine(o1, o2, true);\r\n  // if only one is a segment, it should be first.\r\n  else if (o2 instanceof Segment) return intersect(o2, o1);\r\n  else if (o1 instanceof Line && o2 instanceof Line)\r\n    // line-line\r\n    return intersectLineLine(o1, o2, false);\r\n  // TODO: circle-point, segment-point, point-point\r\n  else if (o2 instanceof Point || o1 instanceof Point) return [];\r\n  else throw new Error('Cannot intersect ' + o1.constructor.name + ' and ' + o2.constructor.name);\r\n}\r\n\r\nfunction intersectCircleCircle(c1, c2) {\r\n  let dsq = dd(c1.center, c2.center);\r\n  let d = Math.sqrt(dsq);\r\n\r\n  if (d > c1.radius + c2.radius) {\r\n    return [];\r\n  } else if (d < c1.radius - c2.radius) {\r\n    return [];\r\n  } else if (dsq === 0) {\r\n    return [];\r\n  }\r\n\r\n  let a = (c1.radiussq - c2.radiussq + dsq) / (2 * d);\r\n  let h = Math.sqrt(Math.max(c1.radiussq - sq(a), 0));\r\n  let cx = c1.center.x + (a * (c2.center.x - c1.center.x)) / d;\r\n  let cy = c1.center.y + (a * (c2.center.y - c1.center.y)) / d;\r\n\r\n  let nx = (h * (c1.center.y - c2.center.y)) / d;\r\n  let ny = (h * (c1.center.x - c2.center.x)) / d;\r\n\r\n  return uniq([P(0, cx + nx, cy - ny), P(1, cx - nx, cy + ny)], comparePoints);\r\n}\r\n\r\nfunction intersectLineLine(s1, s2, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s1._p;\r\n  let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = s2._p;\r\n  let s = (-s1.dy * (x1 - x3) + s1.dx * (y1 - y3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n  let t = (s2.dx * (y1 - y3) - s2.dy * (x1 - x3)) / (-s2.dx * s1.dy + s1.dx * s2.dy);\r\n\r\n  if (!clip || (between(s, 0, 1) && between(t, 0, 1))) return [P(0, x1 + t * s1.dx, y1 + t * s1.dy)];\r\n  else return []; // no collision\r\n}\r\n\r\n/* http://mathworld.wolfram.com/Circle-LineIntersection.html */\r\nfunction intersectCircleLine(c, s, clip) {\r\n  let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = s._p;\r\n  let { x: x0, y: y0 } = c.center;\r\n\r\n  // note the translation (x0, y0)->(0,0).\r\n  let D = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0);\r\n  let Dsq = sq(D);\r\n\r\n  let lensq = sq(s.dx) + sq(s.dy);\r\n  let disc = Math.sqrt(sq(c.radius) * lensq - Dsq);\r\n  if (disc < 0) {\r\n    return [];\r\n  }\r\n\r\n  let cx = (D * s.dy) / lensq,\r\n    cy = (-D * s.dx) / lensq;\r\n  let nx = ((s.dy < 0 ? -1 * s.dx : s.dx) * disc) / lensq,\r\n    ny = (Math.abs(s.dy) * disc) / lensq;\r\n\r\n  // translate (0,0)->(x0, y0).\r\n  return uniq([P(0, cx + nx + x0, cy + ny + y0), P(1, cx - nx + x0, cy - ny + y0)], comparePoints).filter((p) =>\r\n    clip ? between(p.x, x1, x2) && between(p.y, y1, y2) : true\r\n  );\r\n}\r\n\r\nexport { intersect, intersectCircleCircle, intersectCircleLine, intersectLineLine };\r\n","import { Point } from './point';\r\nimport { Geom } from './geom';\r\n\r\nimport { intersect } from '../intersection';\r\n\r\nclass Intersection extends Point {\r\n  /**\r\n   * @param {string} name\r\n   * @param {...Geom} objects to be intersected\r\n   * @param {number|Geom~boolean} [which] optional array index or filter callback in case there are multiple intersections.\r\n   */\r\n  constructor(name, ...objects) {\r\n    if (name instanceof Geom) {\r\n      objects.shift(name);\r\n      name = null;\r\n    }\r\n    super(name, null, null);\r\n\r\n    this.which = /function|number/.test(typeof objects[objects.length - 1]) ? objects.pop() : 0;\r\n    this.objects = objects;\r\n    this.free = false;\r\n  }\r\n\r\n  update() {\r\n    let result = intersect.apply(null, this.objects);\r\n    if (typeof this.which === 'function') result = result.filter(this.which)[0];\r\n    else result = result[this.which];\r\n\r\n    if (result) {\r\n      ({ x: this.x, y: this.y } = result);\r\n    } else {\r\n      this.x = this.y = null;\r\n    }\r\n  }\r\n\r\n  toString(verbose) {\r\n    let pstr = super.toString();\r\n    return !verbose ? pstr : pstr + '; intersection of: ' + this.objects.map((o) => o.toString()).join(',');\r\n  }\r\n}\r\n\r\nexport { Intersection };\r\n","import { Point } from './point';\r\nimport { Circle } from './circle';\r\nimport { Line } from './line';\r\nimport { Segment } from './segment';\r\nimport { Intersection } from './intersection';\r\n\r\nconst P = Point.P;\r\nexport { P, Point, Circle, Segment, Line, Intersection };\r\n\r\n/* return a deep-equality test function that checks for geometric object\r\n   equality using the given distance threshold for point equality; i.e., if \r\n   two points are closer than `threshold`, consider them equal. */\r\nexport function equalWithin(threshold) {\r\n  threshold = threshold || 0;\r\n  return function equal(o1, o2) {\r\n    if (Array.isArray(o1) && Array.isArray(o2)) {\r\n      return o1.every((obj, index) => equal(obj, o2[index]));\r\n    }\r\n    if (typeof o1 === 'number' && typeof o2 === 'number') {\r\n      return Math.abs(o1 - o2) < threshold;\r\n    }\r\n    if (o1 instanceof Point && o2 instanceof Point) {\r\n      if (o1.x === null || o2.x === null || o1.y === null || o2.y === null) return false;\r\n      else return equal(Math.abs(o1.x - o2.x) + Math.abs(o1.y - o2.y), 0);\r\n    }\r\n    if (o1 instanceof Circle && o2 instanceof Circle) {\r\n      return equal(o1.radius, o2.radius) && equal(o1.center, o2.center);\r\n    }\r\n    if (o1 instanceof Segment && o2 instanceof Segment) {\r\n      var p1 = [].concat(o1.p),\r\n        p2 = [].concat(o2.p);\r\n      // ensure points from both segments are in the same order\r\n      // (left to right or right to left).\r\n      if (p1[0].x > p1[1].x && p2[0].x < p2[0].x) p1.reverse();\r\n      // then delegate to point equality\r\n      return equal(p1, p2);\r\n    }\r\n    if (o1 instanceof Line && o2 instanceof Line) {\r\n      return equal(o1.m, o2.m) && equal(o1.y(0), o2.y(0)) && equal(o1.x(0), o2.x(0));\r\n    }\r\n\r\n    // fallback to object equality\r\n    return o1 === o2;\r\n  };\r\n}\r\n","import * as d3 from 'd3';\r\nimport { Circle, equalWithin, Intersection, Line, Point, Segment } from './model';\r\n\r\nfunction addClass(obj, klass) {\r\n  obj.classes = obj.classes || d3.set();\r\n  obj.classes.add(klass);\r\n}\r\n\r\nclass Scene {\r\n  constructor(bounds) {\r\n    this.bounds = bounds;\r\n    this.bounds.width = this.bounds.right - this.bounds.left;\r\n    this.bounds.height = this.bounds.bottom - this.bounds.top;\r\n\r\n    this._last = null; // hack -- should be keeping objects in ordered structure anyway.\r\n    this._objects = d3.map();\r\n    this.equal = equalWithin(Math.sqrt(2));\r\n    this.log = [];\r\n  }\r\n\r\n  /* return an array of all Points in the scene */\r\n  points() {\r\n    return this._objects.values().filter((o) => o instanceof Point);\r\n  }\r\n\r\n  /* return an array of all objects in the scene */\r\n  objects() {\r\n    return this._objects.values();\r\n  }\r\n\r\n  /* find the given object is in the scene using geometric\r\n  (i.e. deep) equality rather than reference ===. */\r\n  find(obj) {\r\n    let objects = this._objects.values();\r\n    for (let i = 0; i < objects.length; i++) {\r\n      if (this.equal(objects[i], obj)) return objects[i];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * is - Get an equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is geometrically equal to obj.\r\n   */\r\n  is(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && this.equal(obj, secondObj);\r\n  }\r\n\r\n  /**\r\n   * is - Get an NON-equality-testing callback for the given object.\r\n   *\r\n   * @param  {Geom|string} obj Either the name of the object to test or the object itself.\r\n   * @return {Geom~boolean} a function that tests whether its argument is NOT geometrically equal to obj.\r\n   */\r\n  isnt(obj) {\r\n    if (typeof obj === 'string') {\r\n      obj = this.get(obj);\r\n    }\r\n    return (secondObj) => obj && !this.equal(obj, secondObj);\r\n  }\r\n\r\n  last() {\r\n    return this._last;\r\n  }\r\n\r\n  get(name) {\r\n    return this._objects.get(name);\r\n  }\r\n\r\n  point(name, x, y) {\r\n    return this.add(new Point(name, x, y));\r\n  }\r\n\r\n  circle(name, centerId, radius) {\r\n    return this.add(new Circle(name, this.get(centerId), radius));\r\n  }\r\n\r\n  segment(name, id1, id2) {\r\n    return this.add(new Segment(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  line(name, id1, id2) {\r\n    return this.add(new Line(name, this.get(id1), this.get(id2)));\r\n  }\r\n\r\n  intersection(name, id1, id2, which) {\r\n    if (typeof id2 === 'undefined') {\r\n      id2 = id1;\r\n      id1 = name;\r\n      name = null;\r\n    }\r\n\r\n    let o1 = this.get(id1),\r\n      o2 = this.get(id2);\r\n    if (!o1) throw new Error(\"Can't find object \" + id1);\r\n    if (!o2) throw new Error(\"Can't find object \" + id2);\r\n\r\n    return this.add(new Intersection(name, o1, o2, which));\r\n  }\r\n\r\n  group(tag) {\r\n    this._currentTag = tag;\r\n    return this;\r\n  }\r\n\r\n  add(object) {\r\n    // if we already have this object, and it's the same type, then update the\r\n    // existing one in place.\r\n    let existing = this._objects.get(object.name);\r\n    if (existing && existing.constructor.name === object.constructor.name) {\r\n      for (let prop in object) existing[prop] = object[prop];\r\n      object = existing;\r\n    }\r\n    // if an object of the same name but different type or an object that is\r\n    // geometrically equivalent already exists in the scene, do nothing.\r\n    else if (existing || (existing = this.find(object))) {\r\n      return this;\r\n    }\r\n    // add a new object to the scene.\r\n    else {\r\n      object.name = object.name || this.freeName();\r\n      this._objects.set(object.name, object);\r\n    }\r\n\r\n    if (this._currentTag) addClass(object, this._currentTag);\r\n    if (object.free) addClass(object, 'free-point');\r\n\r\n    this.update(object);\r\n\r\n    this._last = object;\r\n    return this;\r\n  }\r\n\r\n  freeName() {\r\n    let keys = this._objects.keys(),\r\n      id = 0;\r\n    for (; keys.indexOf('object' + id) >= 0; id++);\r\n    return 'object' + id;\r\n  }\r\n\r\n  /**\r\n   * update - Update objects to reflect changes in dependent objects. (E.g.,\r\n   * update Intersection coordinates when the intersected objects have changed.)\r\n   *\r\n   * @param {Geom} root The object from which to start walking the dependency graph.\r\n   */\r\n  // TODO: respect `root` parameter, and do an actual DAG walk.\r\n  update(root) {\r\n    this._objects\r\n      .values()\r\n      .filter((obj) => obj instanceof Intersection)\r\n      .forEach((obj) => obj.update());\r\n  }\r\n\r\n  logState(label) {\r\n    let self = this;\r\n    let objects = this._objects.values();\r\n    let points = this.points();\r\n\r\n    let state = {\r\n      label,\r\n      time: new Date().toString(),\r\n      objects: objects.map((o) => o.toString())\r\n    };\r\n    this.log.push(state);\r\n  }\r\n}\r\n\r\nexport { Scene };\r\n","import * as d3 from 'd3';\r\nimport { Circle, Line, Point, Segment } from './model';\r\n\r\nfunction klasses() {\r\n  let init = Array.prototype.slice.call(arguments, 0);\r\n  return (d) => init.concat(d.classes ? d.classes.values() : []).join(' ');\r\n}\r\n\r\nfunction renderGeometry(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* circles */\r\n  let circles = svg.selectAll('g.circle').data(scene.objects().filter((d) => d instanceof Circle));\r\n\r\n  let circleGroup = circles\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('circle'));\r\n  circleGroup.append('circle').attr('class', 'handle');\r\n  circleGroup.append('circle').attr('class', 'visible');\r\n\r\n  circles\r\n    .attr('class', klasses('circle'))\r\n    .selectAll('circle')\r\n    .attr('cx', (d) => d.center.x)\r\n    .attr('cy', (d) => d.center.y)\r\n    .attr('r', (d) => d.radius);\r\n\r\n  circles.exit().remove();\r\n\r\n  /* lines */\r\n  let lines = svg.selectAll('g.line').data(scene.objects().filter((d) => d instanceof Line));\r\n\r\n  let lineGroup = lines\r\n    .enter()\r\n    .append('g')\r\n    .attr('class', klasses('line'));\r\n  lineGroup.filter((d) => d instanceof Segment).attr('class', klasses('line', 'segment'));\r\n  lineGroup.append('line').attr('class', 'handle');\r\n  lineGroup.append('line').attr('class', 'visible');\r\n\r\n  // TODO: this is grossly inefficient\r\n  function endpoint(index, coord) {\r\n    return (d) => {\r\n      let s = d instanceof Segment ? d : Segment.clip(scene.bounds, d);\r\n      return s.p[index][coord];\r\n    };\r\n  }\r\n\r\n  lines\r\n    .attr('class', klasses('line'))\r\n    .selectAll('line')\r\n    .attr('x1', endpoint(0, 'x'))\r\n    .attr('y1', endpoint(0, 'y'))\r\n    .attr('x2', endpoint(1, 'x'))\r\n    .attr('y2', endpoint(1, 'y'));\r\n\r\n  lines.exit().remove();\r\n}\r\n\r\nfunction renderPoints(scene, svgElement) {\r\n  let svg = d3.select(svgElement);\r\n\r\n  /* points */\r\n  let points = svg.selectAll('circle.point').data(scene.objects().filter((d) => d instanceof Point));\r\n\r\n  points\r\n    .enter()\r\n    .append('circle')\r\n    .attr('class', klasses('point'))\r\n    .attr('cx', (d) => d.x)\r\n    .attr('cy', (d) => d.y)\r\n    .attr('r', (d) => 5);\r\n\r\n  points\r\n    .enter()\r\n    .append('text')\r\n    .attr('class', klasses('point-name'))\r\n    .attr('x', (d) => d.x + 10)\r\n    .attr('y', (d) => d.y - 15)\r\n    .attr('id', (d) => `point-${d.name}`);\r\n\r\n  points.enter()._groups[0].forEach((node) => {\r\n    const name = node.__data__.name;\r\n    document.getElementById(`point-${name}`).appendChild(document.createTextNode(name));\r\n  });\r\n\r\n  points.exit().remove();\r\n}\r\n\r\nexport { renderGeometry, renderPoints };\r\n","import * as React from 'react';\r\nimport { Scene } from '../../../vendor/euclid';\r\nimport { renderGeometry, renderPoints } from '../../../vendor/euclid/render';\r\nimport type { DrawingDataType } from '../../../utils/types';\r\nimport './DrawingPanel.scss';\r\nimport { Operation } from '../../../core/math/MathOperation';\r\ntype PropsType = {\r\n  drawingData: DrawingDataType\r\n};\r\n\r\nclass DrawingPanel extends React.Component<PropsType> {\r\n  componentDidMount() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.renderGeometry(this.props.drawingData);\r\n  }\r\n\r\n  renderGeometry(drawingData: DrawingDataType) {\r\n    const svg = document.getElementById('geometry');\r\n\r\n    while (svg.firstChild) {\r\n      svg.firstChild.remove();\r\n    }\r\n    const pointElements = document.getElementById('points');\r\n    while (pointElements.firstChild) {\r\n      pointElements.firstChild.remove();\r\n    }\r\n\r\n    const { points, segments, circles } = drawingData;\r\n    const viewBox = svg.viewBox.baseVal;\r\n    const width = viewBox.width;\r\n    const height = viewBox.height;\r\n\r\n    const scene = new Scene({\r\n      left: viewBox.x,\r\n      top: viewBox.y,\r\n      right: viewBox.x + width,\r\n      bottom: viewBox.y + height\r\n    });\r\n\r\n    const arrX = [];\r\n    const arrY = [];\r\n    points.forEach((point) => {\r\n      arrX.push(point.coordinate.x);\r\n      arrY.push(point.coordinate.y);\r\n    });\r\n\r\n    if (circles) {\r\n      Object.keys(circles).forEach((point) => {\r\n        const center = circles[point].center;\r\n        const radius = circles[point].radius;\r\n        arrX.push(center.x - radius, center.x + radius);\r\n        arrX.push(center.y - radius, center.y + radius);\r\n      });\r\n    }\r\n    const minX = Math.min(...arrX);\r\n    const minY = Math.min(...arrY);\r\n    const disparityX = Math.max(...arrX) - minX;\r\n    const disparityY = Math.max(...arrY) - minY;\r\n    const ODD = 0.15;\r\n    let ratio = 1;\r\n    if (disparityX / disparityY >= 1) {\r\n      // scale theo width\r\n      // giá trị ước lượng (ODD): nhằm tránh điểm render ngay cạnh của viewBox sẽ làm mất tên điểm\r\n      ratio = Operation.Round(width / disparityX) * (1 - ODD);\r\n    } else {\r\n      ratio = Operation.Round(height / disparityY) * (1 - ODD);\r\n    }\r\n\r\n    const transitionX = width / 2 - (disparityX * ratio) / 2;\r\n    const transitionY = height / 2 - (disparityY * ratio) / 2;\r\n    points.forEach((point) => {\r\n      scene.point(\r\n        point.id,\r\n        (point.coordinate.x - minX) * ratio + transitionX,\r\n        (point.coordinate.y - minY) * ratio + transitionY\r\n      );\r\n    });\r\n\r\n    segments.forEach((segment) => {\r\n      if (segment && segment.visible) {\r\n        scene.segment(segment.name, segment.name[0], segment.name[1]);\r\n      }\r\n    });\r\n\r\n    if (circles) {\r\n      Object.keys(circles).forEach((point) => {\r\n        const circlePoint = {\r\n          x: circles[point].radius + circles[point].center.x,\r\n          y: circles[point].radius + circles[point].center.y\r\n        };\r\n        scene.point(\r\n          point,\r\n          (circles[point].center.x - minX) * ratio + transitionX,\r\n          (circles[point].center.y - minY) * ratio + transitionY\r\n        );\r\n\r\n        const scaledCirclePoint = {\r\n          x: (circlePoint.x - minX) * ratio + transitionX,\r\n          y: (circlePoint.y - minY) * ratio + transitionY\r\n        };\r\n        console.log(circles[point].radius, ratio);\r\n        scene.circle(`circle-${point}`, point, circles[point].radius * ratio);\r\n      });\r\n    }\r\n\r\n    scene.update();\r\n    renderGeometry(scene, svg);\r\n    renderGeometry(scene, svg);\r\n    renderPoints(scene, pointElements);\r\n  }\r\n\r\n  render(): React.Node {\r\n    return (\r\n      <div className=\"geometry-container\">\r\n        <svg id=\"geometry\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n        <svg id=\"points\" className=\"geometry-scene\" viewBox=\"0 0 800 800\" />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DrawingPanel;\r\n","import React from 'react';\r\nimport './css/MainView.scss';\r\nimport { observer } from 'mobx-react';\r\nimport autobind from 'autobind-decorator';\r\nimport { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';\r\n\r\nimport DataViewModel from '../ViewModel/DataViewModel';\r\n\r\nimport { Icon, InputItem, SegmentSetting } from './components';\r\nimport { DrawingPanel } from './components/DrawingPanel';\r\nimport { calculateDistanceTwoPoints, calculateVector, isVectorSameDirection } from '../core/math/Math2D';\r\nimport type { DrawingSegmentType, SegmentDataType } from '../utils/types';\r\nimport GConst from '../core/config/values';\r\n\r\n@observer\r\nclass MainView extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.inputRefs = [];\r\n    this.state = {\r\n      focusIndex: 0,\r\n      points: [\r\n        { id: 'A', coordinate: { x: 0, y: 0, z: 0 } },\r\n        { id: 'B', coordinate: { y: 5, x: -7 } },\r\n        { id: 'C', coordinate: { x: -9, y: 4.0901353661613005 } },\r\n        { id: 'H', coordinate: { x: -3.0849364905389067, y: 6.781088913245535 } },\r\n        { id: 'D', coordinate: { x: -5.250000000000003, y: 3.7500000000000018 } },\r\n        { id: 'E', coordinate: { x: -8, y: 9.794855240493977 } }\r\n      ],\r\n      segments: [\r\n        'AB',\r\n        'BC',\r\n        'AC',\r\n        'AH',\r\n        'DH',\r\n        'DE',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA',\r\n        'HB',\r\n        'HA',\r\n        'HA',\r\n        'HD',\r\n        'DA',\r\n        'DD',\r\n        'DD',\r\n        'DA',\r\n        'ED',\r\n        'EA'\r\n      ],\r\n      drawingSegments: []\r\n    };\r\n    this.scrollView = React.createRef();\r\n  }\r\n\r\n  componentWillMount() {\r\n    const { points, segments } = this.state;\r\n    this.setState({\r\n      drawingSegments: this.trimDrawingData({ points, segments }).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  scrollToBottom() {\r\n    if (this.scrollView.current) {\r\n      setTimeout(() => {\r\n        this.scrollView.current.firstChild.scrollIntoView(false);\r\n      }, 250);\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  trimDrawingData(data) {\r\n    const { points, segments } = data;\r\n\r\n    //change to DataViewModel.getNodeInPointsMapById.coordinate when refactor done\r\n    const pointData = {};\r\n    points.forEach((point) => {\r\n      pointData[point.id] = point.coordinate;\r\n    });\r\n\r\n    const segmentsData = {};\r\n    let result = [];\r\n    points.forEach((point) => {\r\n      segmentsData[point.id] = segments\r\n        .map((segment: string): string =>\r\n          segment\r\n            .split('')\r\n            .sort()\r\n            .join('')\r\n        )\r\n        .filter((segment: string): boolean => segment.includes(point.id))\r\n        .map((segment: string): SegmentDataType => {\r\n          const firstPoint = pointData[segment[0]];\r\n          const secondPoint = pointData[segment[1]];\r\n          return {\r\n            name: segment,\r\n            vector: calculateVector(firstPoint, secondPoint),\r\n            length: calculateDistanceTwoPoints(firstPoint, secondPoint)\r\n          };\r\n        });\r\n    });\r\n\r\n    const removeSegments = [];\r\n\r\n    Object.keys(segmentsData).forEach((point) => {\r\n      if (segmentsData[point].length > 0) {\r\n        const segments = this.uniqueSegmentData(segmentsData[point], removeSegments);\r\n        result = result.concat(segments);\r\n      }\r\n    });\r\n\r\n    result = [...new Set(result)].filter((segment: string): boolean => segment[0] !== segment[1]);\r\n\r\n    return result;\r\n  }\r\n\r\n  uniqueSegmentData(data: Array<SegmentDataType>, removeSegments: Array<string>): Array<string> {\r\n    let result = [data[0]];\r\n    for (let i = 1; i < data.length; i++) {\r\n      const segmentData = data[i];\r\n\r\n      const length = result.length;\r\n      let replaceIndex = -1;\r\n      for (let j = 0; j < length; j++) {\r\n        if (isVectorSameDirection(segmentData.vector, result[j].vector)) {\r\n          if (segmentData.length >= result[j].length) {\r\n            replaceIndex = j;\r\n          } else {\r\n            removeSegments.push(segmentData.name);\r\n          }\r\n        }\r\n      }\r\n      if (replaceIndex >= 0) {\r\n        result[replaceIndex] = segmentData;\r\n      } else {\r\n        if (!removeSegments.includes(segmentData.name)) {\r\n          result.push(segmentData);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result.map((segmentData: SegmentDataType): string => segmentData.name);\r\n  }\r\n\r\n  @autobind\r\n  onValueChange(value: string, index: number) {\r\n    DataViewModel.RelationsInput[index].value = value;\r\n    this.setState({ focusIndex: index });\r\n  }\r\n\r\n  @autobind\r\n  onSubmit(index: number) {\r\n    if (index === DataViewModel.RelationsInput.length - 1 && DataViewModel.RelationsInput[index].value.length > 2) {\r\n      DataViewModel.addNewInput();\r\n    }\r\n\r\n    this.setState({ focusIndex: index + 1 });\r\n  }\r\n\r\n  @autobind\r\n  onBackspace(index: number) {\r\n    const value = DataViewModel.RelationsInput[index].value;\r\n    if (value.length === 0 && DataViewModel.RelationsInput.length > 1) {\r\n      DataViewModel.removeInput(index);\r\n      this.inputRefs.splice(index, 1);\r\n      this.setState({ focusIndex: index - 1 });\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  onClickDrawing() {\r\n    DataViewModel.clear();\r\n\r\n    const data = DataViewModel.analyzeInput();\r\n    if (data.points.length === 0 && data.segments.length === 0) {\r\n      DataViewModel.resetInputsStatus();\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      points: data.points,\r\n      segments: data.segments,\r\n      drawingSegments: this.trimDrawingData(data).map((segment: string): DrawingSegmentType => ({\r\n        name: segment,\r\n        visible: true\r\n      }))\r\n    });\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    const { focusIndex } = this.state;\r\n    if (this.inputRefs[focusIndex]) {\r\n      this.inputRefs[focusIndex].focus();\r\n    }\r\n  }\r\n\r\n  @autobind\r\n  renderRelationInput(): React.Node {\r\n    return DataViewModel.RelationsInput.map((model, index) => {\r\n      return (\r\n        <InputItem\r\n          key={`input-${index}`}\r\n          index={index}\r\n          ref={(ref) => {\r\n            this.inputRefs[index] = ref;\r\n          }}\r\n          onValueChange={(value: string) => {\r\n            this.onValueChange(value, index);\r\n          }}\r\n          onSubmit={() => {\r\n            this.onSubmit(index);\r\n          }}\r\n          onBackspace={() => {\r\n            this.onBackspace(index);\r\n          }}\r\n          value={model.value}\r\n          status={model.status}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onDoneSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n    if (JSON.stringify(data) === JSON.stringify(drawingSegments[index])) {\r\n      return;\r\n    }\r\n    const length = JSON.parse(JSON.stringify(drawingSegments.length));\r\n    const isAddSegment = !!drawingSegments[index];\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments }, () => {\r\n      if (isAddSegment) {\r\n        if (\r\n          drawingSegments.map((segment: SegmentDataType): string => segment.name).includes(data.name) &&\r\n          length !== drawingSegments.length\r\n        ) {\r\n          this.onDeleteSegmentSetting(index);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  @autobind\r\n  onChangeSegmentSetting(data: DrawingSegmentType, index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments[index] = data;\r\n\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  onDeleteSegmentSetting(index: number) {\r\n    const { drawingSegments } = this.state;\r\n\r\n    drawingSegments.splice(index, 1);\r\n    this.setState({ drawingSegments });\r\n  }\r\n\r\n  @autobind\r\n  addNewSegmentSetting() {\r\n    if (this.state.drawingSegments.includes(undefined)) {\r\n      return;\r\n    }\r\n    this.scrollToBottom();\r\n    this.setState((prevState) => ({\r\n      drawingSegments: prevState.drawingSegments.concat([undefined])\r\n    }));\r\n  }\r\n\r\n  @autobind\r\n  renderSegmentSettings(): React.Node {\r\n    const { drawingSegments } = this.state;\r\n    const points = this.state.points.map((point: NodeType): number => point.id);\r\n\r\n    return drawingSegments.map((segment: DrawingSegmentType, index: number): React.Node => {\r\n      return (\r\n        <SegmentSetting\r\n          key={`segment-setting-${index}`}\r\n          data={points}\r\n          value={segment}\r\n          onDone={(value) => {\r\n            this.onDoneSegmentSetting(value, index);\r\n          }}\r\n          onVisibleChange={(value) => {\r\n            this.onChangeSegmentSetting(value, index);\r\n          }}\r\n          onDelete={() => {\r\n            this.onDeleteSegmentSetting(index);\r\n          }}\r\n          style={index === 0 ? { marginTop: '1rem' } : {}}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { points, drawingSegments, segments } = this.state;\r\n    return (\r\n      <div className={'container-fluid'}>\r\n        <div className={'app-header'}>\r\n          <div className={'app-name'}>\r\n            <p>Gemath</p>\r\n          </div>\r\n\r\n          <div className={'app-description'}>\r\n            <p>app description</p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"app-body\">\r\n          <div className=\"app-controller\">\r\n            <div className=\"accordion\" id=\"accordionExample\">\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingOne\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewOne\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseOne\">\r\n                  <p>1. Nhập đề</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <div>{GConst.TutorialString.STEP_ONE}</div>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div\r\n                  id=\"viewOne\"\r\n                  className=\"collapse show\"\r\n                  aria-labelledby=\"headingOne\"\r\n                  data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\">\r\n                    <div>\r\n                      {this.renderRelationInput()}\r\n                      <Button\r\n                        type=\"button\"\r\n                        className=\"btn btn-success w-100\"\r\n                        onClick={this.onClickDrawing}\r\n                        disabled={DataViewModel.isInputEmpty}>\r\n                        Vẽ hình\r\n                      </Button>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"card\">\r\n                <div\r\n                  className=\"card-header left-panel-tab\"\r\n                  id=\"headingTwp\"\r\n                  data-toggle=\"collapse\"\r\n                  data-target=\"#viewTwo\"\r\n                  aria-expanded=\"true\"\r\n                  aria-controls=\"collapseTwp\">\r\n                  <p>2. Chỉnh sửa hình</p>\r\n                  <OverlayTrigger\r\n                    key=\"right\"\r\n                    container={this}\r\n                    placement=\"right\"\r\n                    overlay={\r\n                      <Tooltip id={`tooltip-right`} className=\"help-tooltip\">\r\n                        <span>Thêm/Xóa các doạn thẳng</span>\r\n                      </Tooltip>\r\n                    }>\r\n                    <div className=\"bg-transparent icon-container\">\r\n                      <Icon name=\"icInformation\" width={22} height={22} />\r\n                    </div>\r\n                  </OverlayTrigger>\r\n                </div>\r\n                <div id=\"viewTwo\" className=\"collapse \" aria-labelledby=\"headingOne\" data-parent=\"#accordionExample\">\r\n                  <div className=\"card-body\" ref={this.scrollView}>\r\n                    <div>\r\n                      {this.renderSegmentSettings()}\r\n                      <div className={'add-row-container'} onClick={this.addNewSegmentSetting}>\r\n                        <Icon name={'icAdd'} width={35} height={35} color={'#757575'} />\r\n                        <p>Thêm đoạn thẳng</p>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className={'app-drawing-panel'}>\r\n            <DrawingPanel drawingData={{ points, segments: drawingSegments, circles: DataViewModel.circlesData }} />\r\n          </div>\r\n        </div>\r\n\r\n        <div className={'app-footer'}>\r\n          <p>abc</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MainView;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainView from './View/MainView';\r\n\r\nReactDOM.render(<MainView />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputSuccess\":\"#28a745\",\"inputError\":\"#dc3545\",\"inputNormal\":\"#6c757d\"};"],"sourceRoot":""}