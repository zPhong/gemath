{"version":3,"sources":["serviceWorker.js","Model/AppData.js","core/definition/define.js","core/config/values.js","core/utils/isNum.js","core/utils/isValid.js","core/utils/isFunction.js","core/error/ErrorHandleService.js","core/math/MathOperation.js","core/math/Converter.js","core/math/Generation.js","core/config/GConfig.js","core/config/GLog.js","core/math/Math2D.js","utils/checker.js","core/definition/defineObjType.js","core/validation/validation.js","core/definition/index.js","core/definition/defineShapeType.js","core/definition/definePointType.js","core/math/GenerateGeometry.js","core/analysis/ReadPointsMap.js","core/analysis/ReadRelation.js","core/analysis/Analysis.js","Model/RelationInputModel.js","ViewModel/InputConverter.js","ViewModel/DataViewModel.js","core/drawing/base/DrawingData.js","View/components/DrawingPanel/DrawingPanel.js","core/drawing/core/Render.js","core/drawing/core/TranformCenter.js","View/IFrameView.js","index.js"],"names":["Boolean","window","location","hostname","match","appData","AppData","Object","classCallCheck","this","additionSegment","relationsResult","pointsMap","pointsDirectionMap","executedRelations","executedNode","__pointDetails__","Map","clear","segment","push","newPointsMap","value","defineSentences","define","relation","shape","reversedDependentObjRelation","RankingObjectContain","objectWithPoint","validate","object","point","length","format","ray","line","angle","triangle","quadrilateral","trapezoid","parallelogram","rectangle","rhombus","square","circle","shapeType","shapeRules","right","isosceles","right_isosceles","equilateral","normal","mappingShapeType","vuông","cân","vuông cân","đều","nội tiếp","ngoại tiếp","bàng tiếp","circleType","TwoStaticPointRequireShape","ShapeAffectBySegmentChange","GConst","Number","freeze","MIN_RANDOM_NUMBER","MAX_RANDOM_NUMBER","MIN_RANDOM_GENERATION","MAX_RANDOM_GENERATION","NOT_FOUND","String","INFINITY","IMPOSSIBLE","TOO_SHORT","NOT_ENOUGH_SET","NOT_BE_IN_LINE","Regex","KEY","OTHER","Others","OPERATIONS","Errors","UNDEFINED_ERROR","WRONG_FORMAT","MAXIMUM_POINT_ERROR","InputStatus","SUCCESS","NORMAL","ERROR","TutorialString","STEP_ONE","isNum","rs","undefined","Array","isArray","Infinity","isNaN","isValid","r","toString","prototype","isFunction","type","isObject","tag","call","getTag","ErrorCode","200","300","301","400","401","500","501","502","ErrorService","message","code","errorRelation","index","dataViewModel","inputData","forEach","data","i","executedInputIndex","filter","executingRelation","RelationsInput","status","alert","console","error","instance","Parenthesis","element","concat","showError","Sub","elementOne","elementTwo","parseFloat","Math","abs","Round","f","arguments","calculatedValue","evaluate","myF","pow","round","Add","Multiply","isNegative","result","Divide","Sqrt","Pow","exponent","isEqual","Compare","calculatedValueOne","calculatedValueTwo","isZero","Abs","isSmallerThanZero","Max","_len","values","_key","max","maxValue","evaluatedValue","MathOperation","Operation","convertLinearToEquation","l","c","d","e","a","b","convertEquationToLineType","convertLineTypeToEquation","MIN","MAX","getRandomValue","min","floor","random","getRandomPointInEquation","equation","x","y","tempX","centerPoint","radius","randomValueX","solvedValueY","calculateQuadraticEquation","generatePointAlignmentInside","firstPoint","secondPoint","getLineFromTwoPoints","rV","less","greater","dis","tempY","generatePointAlignmentOutside","isRight","tempXRight","tempXLeft","env","isDev","isOffLog","GConfig","GLog","moduleName","constructor","_console","args","info","apply","name","msg","offThis","log","_len2","msgs","_key2","join","_makeRound","num","logError","calculateVector","isMakeRound","isVectorSameDirection","firstVector","secondVector","isVectorInSameLine","calculateMiddlePoint","calculateSymmetricalPoint","p1","p2","directionVector","normalVector","calculateDistanceTwoPoints","squareX","squareY","calculateDistanceFromPointToLine","numerator","denominator","calculateParallelLineByPointAndLine","lineEquation","parLine","calculatePerpendicularLineByPointAndLine","perpendicularLine","perLine","calculateIntersectionByLineAndLine","lineOne","lineTwo","calculateSetOfEquationTypeAndQuadraticEquation","calculateCircleEquationByCenterPoint","calculateInternalBisectLineEquation","pointOne","pointTwo","results","_calculateBisectLineEquation","firstLine","secondLine","getAngleFromTwoLines","set","_getInternalBisectLineEquation","calculateExternalBisectLineEquation","internalLine","JSON","stringify","resultOne","resultTwo","coefficient","firstEquation","secondEquation","calculateSetOfEquationTypes","d1","d2","logMsg","calculateIntersectionEquationTypeWithCircleEquation","q","A","B","distanceFromCenterPointToLine","logMsgWithLineBreaks","delta","isIn","p","temp","C","D","E","F","G","H","root","r1","r2","calculateIntersectionTwoCircleEquations","q1","q2","Z","_D","_E","_G","map","roots","calculateLinesByAnotherLineAndAngle","rootPoint","staticPoint","dynamicPoint","dynamicVectorArr","newRootPointArr","staticVectorArr","equations","_calculateLinesByAnotherLineAndAngle","count","filterEquations","newRootPoint","staticVector","dynamicVector","calculateAngleTwoVector","parseInt","calculateIntegratedDirection","vectorOne","vectorTwo","calculateVectorLength","vector","cosine","makeRoundCoordinate","a1","a2","b1","b2","getMiddlePointFromThreePointsInALine","p3","dis_p1_p2","dis_p2_p3","dis_p1_p3","calculateCircumCircleEquation","midperpendicularsLineOne","midperpendicularsLineTwo","center","calculateInCircleEquation","bisectorLineOne","bisectorLineTwo","calculateEscribedCirclesEquation","escribedPoint","logInfo","otherPoints","calculateTangentEquation","tangentPoint","tangentEquation","calculateTangentIntersectPointsByPointOutsideCircle","exceptionPoint","tempCircleCenter","tempCircleRadius","tempCircleEquation","isTwoEquationEqual","equationOne","equationTwo","isIsosceles","gcd","t","isNumber","isObjectLike","isQuadraticEquation","checkFormatString","str","split","char","toLowerCase","defineObject","slice","includes","validateObject","validateValue","key","_validateName","validateType","validateGeometryType","validateShape","keys","validateShapeFormat","validateShapeType","shapeFormatCheck","shapeTypeCheck","checkObjectRelationship","obj1","obj2","check","toConsumableArray","Set","indexOf","string","item","array","validateInformation","outputType","j","indexOfRankingLevel","indexOfObjectCurrentLevel","indexOfObjectNextLevel","validateDataRelationship","defineInformation","splitter","shapeName","pop","otherData","replace","trim","defineShapeType","definePointType","reverse","sortString","toUpperCase","sort","Error","math2D","calculateParallelEquation","parallelEquation","calculatePerpendicularEquation","perpendicularEquation","fractionReducing","_gcd","geometricObj","z","updateCoordinate","distance_From_A_To_B","sqrt","linearEquation","p4","lineAB","lineAC","lineBC","lineAD","lineCD","intersection_AB_CD","intersection_AD_BC","distanceX","node","isFunc","readRelation","equationResults","operation","objectType","valueData","objectsIncludePoint","getNodeInPointsMapById","coordinate","staticValue","staticObject","angleName","angleValue","executePoint","checkResult","isValidCoordinate","isChanged","shapeList","getData","shapes","shapeData","getShapeAffectList","isStaticNodeById","secondLineVector","modifiedAngleName","updatePoint","reExecuteNode","checkAndModifiedAngle","changedPoint","calculatedEquation","intersectPoint","transitionVector","rootOne","rootTwo","calculatedCoordinate","getPointDirectionMap","isUp","replaceSetOfEquation","calculateLineEquationByAngleRelation","staticPointOne","staticPointTwo","staticLineEquation","staticDistance","isAlign","coefficientX","coefficientY","constantTerm","ratio","calculatedPoint","betweenPoint","analyzeOperationType","segmentIncludePoint","segmentNotIncludePoint","relationType","getCircleEquation","otherStaticPoint","otherStaticNodeInSegment","points","pushInsideRule","getAdditionSegment","generatePointMiddleTwoPoints","calculatedLineEquation","isInStaticLine","isExternal","analyzeRelationType","calculatedLineEquationOne","calculatedLineEquationTwo","analyzeIntersectRelation","otherPointInSegment","tangentPointCoordinate","circleEquation","filterRoots","isCoordinateDuplicated","filterTangentPoint","analyzeTangentRelation","newPointCount","circlesData","getCircleEquationByRelation","getPointOrderInShape","limit","readPointsMap","createPointDetails","table","parse","getPointsMap","_loop2","executingNode","getNextExecuteNode","dependentNodes","_makeUniqueNodeRelation","relationEquation","isExecutedRelation","generateFunc","generateGeometry","pointCoordinate","rootCoordinate","setPointsDirection","makeCorrectShape","id","executePointDetails","getExecutedRelations","isReCalculated","getExecutedNode","executeRelations","getPointDetails","has","get","v","isNeedRandomCoordinate","nodeDirectionInfo","staticPointCoordinate","coordinatesMatch","directionInfo","matchCount","checkInsideRule","updateStaticNode","_loop","isPointsMapStatic","_ret","setOfEquation","rules","staticPointCountRequire","staticPoints","arrayRules","RegExp","executePointIndex","nodeSetEquations","rule","staticLine","nonStaticLine","pLine","getLinearEquationByParallelRule","getLinearEquationByPerpendicularRule","includeLine","nonIncludeLine","staticLines","shapePoints","staticPointIndex","pointIndex","otherPointInIncludeLine","nonStaticPointIndex","updateCoordinateBySpecialPerpendicularRule","otherPoint","getLinearEquationsByEqualRule","RelationPointsMap","AdditionRelation","random_angle_default","analyzeResult","validatedResult","isHaveTriangle","segments","angles","relationSegments","relationAngles","relations","deleteRelationList","splice","position","some","firstRelation","_segment","_value","sum","oppositeAngle","calculatedSegmentValue","sin","PI","shift","updateErrorInInput","deleteWrongRelation","objectPointsMap","createNode","updateMap","createPointsMapByShape","nodeOne","nodeTwo","index1","findIndexByNodeId","index2","lastObjectPoints","lastNode","nodeIndex","isStatic","getDependentObject","currentNode","objectSpread","createDependentNodeOfRelation","createPointsMapByRelation","setPointsMap","unique","_RoundObject","getShapeSegments","getRelationSegments","getArraySegments","getRelationsResult","shapePointCount","segmentCount","angleCount","segOne","segTwo","pointCount","createAngleByTwoSegments","exception","_dependentNodes","oldNode","RelationInputModel","initializerDefineProperty","_descriptor","_descriptor2","observable","specializeLanguageMap","Góc({object})=Góc({object})","{object}={object}","{object} song song {object}","{object} vuông góc {object}","{object} cắt {object} tại {arrayPoints}","{arrayPoints} là giao điểm của {object} và {object}","{object} là phân giác ngoài Góc({angle})","{object} là phân giác trong Góc({angle})","{object} là phân giác của Góc({angle})","{arrayPoints} thẳng hàng","{point} là trung điểm của {segment}","{point} không thuộc {object}","{point} thuộc {object}","{segment} là trung tuyến {type triangle}","{segment} là đường cao của tam giác {triangle}","{circle} đường kính {segment}","{segment} là tiếp tuyến {circle}","Cho tam giác {type triangle}","Cho tứ giác {quadrilateral}","Cho hình thang {type trapezoid}","Cho hình bình hành {parallelogram}","Cho hình chữ nhật {rectangle}","Cho hình thoi {rhombus}","Cho hình vuông {square}","{object type triangle} tại {escribedPoint}","{object type triangle}","getInformation","_string","isMatching","sentence","_sentence","_defineSentence","others","params","start","end","param","lastParam","dictionary","getLength","getBasicInformation","mySentence","classifyData","DataViewModel","_this","DataViewModel_descriptor","DataViewModel_descriptor2","_descriptor3","_descriptor4","pointId","nodeId","getIndexOfNodeInPointsMapById","_coordinate","isStaticNode","arrayPoint","dependence","keepExecutedRelations","updatePointsMap","clonePointsMap","sortNodeByPriority","staticNodeOneCount","getDependentStaticNodeCount","nodeOneData","static","nonStatic","minRelationIndex","getMinIndexOfDependentNodeInRelationsList","getIndexOfNodeInPointsMap","staticNodeTwoCount","nodeTwoData","rankOne","rankTwo","indexArray","getIndexOfRelationInRelationsList","list","_calculateSet","relationsInput","input","newRelationInput","resetInputsStatus","_this2","_updatePointDetails","exceptedCoordinates","insideRule","outsideRule","insideRuleSegments","checkPointRelationWithTwoPoint","coordinateOne","coordinateTwo","searchEquation","replaceEquation","pointDetail","isReplaceComplete","pointDetails","isFirst","newSetOfEquation","currentRoots","finalRoots","coordinateMatch","beSorted","_this3","preProgress","centerId","_this4","stringifyCoordinate","_this5","setRelationsResult","computed","action","autobind","LineStyle","Dashed","Light","Medium","Bold","SEGMENTS","LINES","CIRCLES","Boundary","MIN_HORIZONTAL","MAX_HORIZONTAL","MIN_VERTICAL","MAX_VERTICAL","createDrawingData","_ref","__pointsMap__","__drawingMap__","__boundaryPoints__","isInitDone","addPoints","minX","minXPoint","maxX","maxXPoint","minY","minYPoint","maxY","maxYPoint","getPoints","addPoint","_setMinHorizontalPoint","getPoint","_setMaxHorizontalPoint","_setMinVerticalPoint","_setMaxVerticalPoint","_updateBoundaryPoints","addSegments","lines","circles","addCircles","dataCircles","objCircles","res","obj","lineStyle","isVisible","convertCircleFromObjToArr","initData","addSegment","addLine","_ref4","startPoint","endPoint","addCircle","getSegment","getSegments","segmentKeys","size","segmentName","next","segmentValue","getLine","lineName","getLines","lineKeys","lineValue","getCircle","getCircles","circletKeys","circleName","circleValue","getMinHorizontalPoint","getMaxHorizontalPoint","getMinVerticalPoint","getMaxVerticalPoint","_ref2","_ref3","_ref5","centerName","pointName","uppercasePointName","pointValues","_ref6","_ref7","_ref8","_ref9","DrawingPanel","renderGeometry","props","drawingData","svg","document","getElementById","viewBox","baseVal","width","height","scene","firstChild","remove","clearGeometry","sWidth","clientWidth","sHeight","clientHeight","d3","attr","append","getCoordinate","slicePoints","arr","getStyles","comp","style","dSegments","selectAll","dCircles","dPoints","enter","circleObj","fontSize","getPointNamePosition","pName","minH","maxH","minV","maxV","_enter","__data__","textNode","createTextNode","appendChild","fontFamily","fill","extent","scaleExtent","on","renderSvg","arrX","arrY","disparityX","disparityY","w","h","rW","rH","transitionX","transitionY","followH","realCenter","curCenter","ODD","getTransformData","react","className","React","IFrameView","observer","possibleConstructorReturn","getPrototypeOf","state","focusIndex","queryString","search","inputArray","InputConverter","onClickDrawing","pointData","segmentsData","removeSegments","uniqueSegmentData","segmentData","replaceIndex","analyzeInput","setState","trimDrawingData","visible","lineType","_this$state","react_default","createElement","components_DrawingPanel_DrawingPanel","Component","ReactDOM","render","View_IFrameView","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fcf44050.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// @flow\n\nclass AppData {\n  constructor() {\n    this.additionSegment = [];\n    this.relationsResult = {};\n    this.pointsMap = [];\n    this.pointsDirectionMap = {};\n    this.executedRelations = [];\n    this.executedNode = [];\n    this.__pointDetails__ = new Map();\n  }\n\n  clear() {\n    this.additionSegment = [];\n    this.relationsResult = {};\n    this.pointsMap = [];\n    this.pointsDirectionMap = {};\n    this.executedRelations = [];\n    this.executedNode = [];\n    this.__pointDetails__.clear();\n  }\n\n  set setRelationsResult(value) {\n    this.relationsResult = value;\n  }\n\n  pushAdditionSegment(segment: string) {\n    this.additionSegment.push(segment);\n  }\n\n  get getAdditionSegment() {\n    return this.additionSegment;\n  }\n\n  get getRelationsResult() {\n    return this.relationsResult;\n  }\n\n  get getPointsMap() {\n    return this.pointsMap;\n  }\n\n  setPointsMap(newPointsMap) {\n    this.pointsMap = newPointsMap;\n  }\n\n  get getPointDirectionMap() {\n    return this.pointsDirectionMap;\n  }\n\n  get getExecutedRelations() {\n    return this.executedRelations;\n  }\n\n  get getExecutedNode() {\n    return this.executedNode;\n  }\n\n  get getPointDetails() {\n    return this.__pointDetails__;\n  }\n}\n\nconst appData = new AppData();\n\nexport default appData;\n","const defineSentences = {\n  define: [\n    '{object} + {object} = {object}',\n    '{object} - {object} = {object}',\n    '{object} = {value} * {object}',\n    '{object} = {object}',\n    '{object} > {object}',\n    '{object} < {object}'\n  ],\n  relation: [\n    '{object} song song {object}',\n    '{object} vuông góc {object}',\n    '{object} cắt {object} tại {arrayPoints}',\n    '{object} phân giác ngoài {angle}',\n    '{object} phân giác trong {angle}',\n    '{object} phân giác {angle}',\n    '{arrayPoints} thẳng hàng',\n    '{point} trung điểm {segment}',\n    '{point} không thuộc {object}',\n    '{point} thuộc {object}',\n    '{segment} trung tuyến {triangle}',\n    '{segment} đường cao {triangle}',\n    '{circle} đường kính {segment}',\n    '{segment} tiếp tuyến {circle}'\n  ],\n  shape: [\n    'tam giác {type triangle}',\n    'tứ giác {quadrilateral}',\n    'hình thang {type trapezoid}',\n    'hình bình hành {parallelogram}',\n    'hình chữ nhật {rectangle}',\n    'hình thoi {rhombus}',\n    'hình vuông {square}',\n    '{object type triangle} tại {escribedPoint}',\n    '{object type triangle}'\n  ]\n};\n\nconst shapeList = ['triangle', 'quadrilateral', 'trapezoid', 'parallelogram', 'rectangle', 'rhombus', 'square'];\n\nconst reversedDependentObjRelation = ['vuông góc', 'cắt'];\n\nconst RankingObjectContain = [['point'], ['segment', 'ray'], ['angle']];\n\nconst objectWithPoint = ['angle', 'segment', 'ray', 'point', 'circle', 'triangle'];\n\nconst validate = {\n  object: {\n    define: ['angle', 'segment'],\n    relation: ['ray', 'line', 'segment', 'circle']\n  },\n  point: { length: 1, format: '1' },\n  segment: { length: 2, format: '11' },\n  ray: { length: 2, format: '11' },\n  line: { length: 1, format: '0' },\n  angle: { length: 3 },\n  shape: {\n    triangle: { length: 3, format: '111' },\n    quadrilateral: { length: 4, format: '1111' },\n    trapezoid: { length: 4, format: '1111' },\n    parallelogram: { length: 4, format: '1111' },\n    rectangle: { length: 4, format: '1111' },\n    rhombus: { length: 4, format: '1111' },\n    square: { length: 4, format: '1111' },\n    circle: { length: 1, format: '1' }\n  },\n  shapeType: {\n    triangle: ['', 'vuông', 'cân', 'vuông cân', 'đều', 'nội tiếp', 'ngoại tiếp', 'bàng tiếp'],\n    trapezoid: ['', 'vuông', 'cân']\n  }\n};\n\n/*\n    | song song,\n    ^ vuông góc,\n    = cân\n */\nconst shapeRules = {\n  triangle: {\n    right: '10^02', // Ex: AB vuong goc AC\n    isosceles: '01=02',\n    right_isosceles: '10^02&01=02',\n    equilateral: '01=02&01=12&02=12'\n  },\n  trapezoid: {\n    normal: '01|23',\n    right: '01|23&10^03',\n    isosceles: '01|23&03=12'\n  },\n  parallelogram: {\n    normal: '01|23&03|12'\n  },\n  rectangle: {\n    normal: '01^12&12^23&23^30&30^01'\n  },\n  rhombus: {\n    normal: '02^13'\n  },\n  square: {\n    normal: '01|23&03|12&01^12&12^23&23^03&01=03&&01=12&12=23&&23=03'\n  }\n};\n\nconst mappingShapeType = {\n  vuông: 'right',\n  cân: 'isosceles',\n  'vuông cân': 'right_isosceles',\n  đều: 'equilateral',\n  'nội tiếp': 'nội tiếp',\n  'ngoại tiếp': 'ngoại tiếp',\n  'bàng tiếp': 'bàng tiếp'\n};\n\nconst circleType = ['nội tiếp', 'ngoại tiếp', 'bàng tiếp'];\n\nconst TwoStaticPointRequireShape = ['triangle', 'trapezoid', 'rectangle', 'square'];\n\nconst ShapeAffectBySegmentChange = ['rhombus', 'trapezoid', 'parallelogram'];\n\nexport {\n  validate,\n  TwoStaticPointRequireShape,\n  defineSentences,\n  RankingObjectContain,\n  objectWithPoint,\n  shapeList,\n  reversedDependentObjRelation,\n  shapeRules,\n  mappingShapeType,\n  circleType,\n  ShapeAffectBySegmentChange\n};\n","const Number = Object.freeze({\n  MIN_RANDOM_NUMBER: -10,\n  MAX_RANDOM_NUMBER: 10,\n  MIN_RANDOM_GENERATION: 5,\n  MAX_RANDOM_GENERATION: 15,\n  NOT_FOUND: 99\n});\n\nconst String = Object.freeze({\n  INFINITY: 'vô cực',\n  IMPOSSIBLE: 'vô nghiệm',\n  TOO_SHORT: 'quá ngắn',\n  NOT_ENOUGH_SET: 'không đủ phương trình tạo thành hệ',\n  NOT_BE_IN_LINE: 'điểm không thuộc đường'\n});\n\nconst Regex = Object.freeze({\n  KEY: '[^{\\\\}]+(?=})',\n  OTHER: '(^([^{]+(?={)))|((?<=})([^{]+)(?={))|(((?<=})[^}]+)$)'\n});\n\nconst Others = Object.freeze({\n  OPERATIONS: ['+', '-', '*', '<', '>', '=']\n});\n\nconst Errors = Object.freeze({\n  UNDEFINED_ERROR: 'Lỗi không xác dịnh',\n  WRONG_FORMAT: 'Sai định dạng',\n  MAXIMUM_POINT_ERROR: 'Tối đa 3 điểm thẳng háng'\n});\n\nconst InputStatus = Object.freeze({\n  SUCCESS: 'Success',\n  NORMAL: `Normal`,\n  ERROR: 'Error'\n});\nconst TutorialString = {\n  STEP_ONE: `\n  Danh sách các mẫu câu dặc trưng:\n    \\n__ = __\n    \\n__ song song/vuông góc __\n    \\n__ cắt __ tại __\n    \\n__ phân giác __\n    \\n__ thẳng hàng\n    \\n__ trung điểm __\n    \\n__ thuộc/không thuộc __\n    \\n__ tiếp tuyến (__)\n    \\ntam giác {loại} __\n    \\ntứ giác __\n    \\nđường tròn tâm __ ngoại tiếp/nội tiếp __\n\\nLưu ý:\n  \\n Đường tròn trong cái mối quan hệ khác sẽ nằm trong ()\n  \\n  Vd: AB tiếp tuyến (O)\n  `\n};\nconst GConst = {\n  Number,\n  String,\n  Regex,\n  Others,\n  Errors,\n  InputStatus,\n  TutorialString\n};\n\nexport default GConst;\n","export default function isNum(value) {\n  let rs = true;\n\n  if (\n    value === undefined ||\n    value === null ||\n    value === false ||\n    value === true ||\n    Array.isArray(value) ||\n    value === Infinity ||\n    isNaN(value)\n  ) {\n    rs = false;\n  }\n\n  return rs;\n}","export default function isValid(value) {\n  let r = true;\n\n  if (value === undefined || value === null || value === '') {\n    r = false;\n  }\n\n  return r;\n}","const toString = Object.prototype.toString;\n\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nfunction getTag(value) {\n  if (value == null) {\n    return value === undefined ?\n      '[object Undefined]' :\n      '[object Null]';\n  }\n  return toString.call(value);\n}\n\nexport default function isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  const tag = getTag(value);\n  return tag === '[object Function]' ||\n    tag === '[object AsyncFunction]' ||\n    tag === '[object GeneratorFunction]'\n    || tag === '[object Proxy]';\n}","// @flow\n\nimport GConst from '../config/values';\nimport dataViewModel from '../../ViewModel/DataViewModel';\n\nconst ErrorCode = {\n  200: GConst.Errors.UNDEFINED_ERROR,\n  300: GConst.Errors.WRONG_FORMAT,\n  301: GConst.Errors.MAXIMUM_POINT_ERROR,\n  400: GConst.String.IMPOSSIBLE,\n  401: GConst.String.INFINITY,\n  500: GConst.String.NOT_BE_IN_LINE,\n  501: GConst.String.NOT_ENOUGH_SET,\n  502: GConst.String.TOO_SHORT\n};\n\nclass ErrorHandleService {\n  message: string = '';\n\n  get ErrorMessage() {\n    return this.message;\n  }\n\n  showError(code: string, errorRelation?: mixed) {\n    let index;\n    if (errorRelation) {\n      dataViewModel.inputData.forEach((data: mixed, i: number) => {\n        if (data === errorRelation) {\n          index = i;\n        }\n      });\n    } else {\n      switch (code) {\n        case 300:\n        case 301:\n          index = dataViewModel.executedInputIndex;\n          break;\n        default:\n          index = dataViewModel.inputData.filter((data: mixed): boolean => data === dataViewModel.executingRelation)[0];\n      }\n    }\n    if (index >= 0) {\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\n    }\n\n    alert(ErrorCode[code]);\n    throw console.error('error', ErrorCode[code]);\n  }\n\n  updateErrorInInput(errorRelation: mixed) {\n    let index;\n    if (errorRelation) {\n      dataViewModel.inputData.forEach((data: mixed, i: number) => {\n        if (data === errorRelation) {\n          index = i;\n        }\n      });\n    }\n    if (index >= 0) {\n      dataViewModel.RelationsInput[index].status = GConst.InputStatus.ERROR;\n    }\n  }\n}\n\nconst ErrorService = new ErrorHandleService();\n\nexport default ErrorService;\n","//@flow\n\nimport { evaluate } from 'mathjs';\nimport type { CalculatedResultType } from '../../utils/types';\n\nimport ErrorService from '../error/ErrorHandleService';\n\nfunction MathOperation(): Object {\n  function Parenthesis(element: CalculatedResultType): string {\n    if (!isNaN(element)) {\n      return element;\n    }\n    if (typeof element === 'string') {\n      return `(${element})`;\n    }\n    ErrorService.showError('200');\n  }\n  function Add(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\n    if (!isNaN(elementOne) || !isNaN(elementTwo)) {\n      if (parseFloat(elementOne) === 0) {\n        return Parenthesis(elementTwo);\n      }\n      if (parseFloat(elementTwo) === 0) {\n        return Parenthesis(elementOne);\n      }\n    }\n\n    if (!isNaN(elementOne) && !isNaN(elementTwo)) {\n      if (parseFloat(elementOne) === Round(elementOne) && parseFloat(elementTwo) === Round(elementTwo))\n        return parseFloat(elementOne) + parseFloat(elementTwo);\n    }\n\n    const result = `(${elementOne})+(${elementTwo})`;\n\n    return Parenthesis(result);\n  }\n  function Sub(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\n    if (!isNaN(elementOne) && !isNaN(elementTwo)) {\n      if (parseFloat(elementOne) === 0) {\n        if (parseFloat(elementTwo) < 0) {\n          return Math.abs(parseFloat(elementTwo));\n        }\n        return `-${elementTwo}`;\n      }\n      if (parseFloat(elementTwo) === 0) {\n        return elementOne;\n      }\n      return parseFloat(elementOne) - parseFloat(elementTwo);\n    }\n    const result = `(${elementOne})-(${elementTwo})`;\n    return Parenthesis(result);\n  }\n  function Multiply(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\n    if (!isNaN(elementOne) || !isNaN(elementTwo)) {\n      if (parseFloat(elementOne) === 0 || parseFloat(elementTwo) === 0) {\n        return 0;\n      }\n      if (!isNaN(elementOne) && Math.abs(elementOne) === 1) {\n        const calculatedValue = evaluate(elementTwo);\n        if (calculatedValue === Round(calculatedValue)) {\n          return Parenthesis(parseFloat(elementOne) * calculatedValue);\n        }\n        const isNegative = parseFloat(elementOne) / Math.abs(elementOne) < 0;\n        return Parenthesis(`${isNegative ? '-' : ''}(${elementTwo})`);\n      }\n      if (!isNaN(elementTwo) && Math.abs(elementTwo) === 1) {\n        const calculatedValue = evaluate(elementOne);\n        if (calculatedValue === Round(calculatedValue)) {\n          return Parenthesis(parseFloat(elementTwo) * calculatedValue);\n        }\n        const isNegative = parseFloat(elementTwo) / Math.abs(elementTwo) < 0;\n        return Parenthesis(`${isNegative ? '-' : ''}(${elementOne})`);\n      }\n    }\n\n    if (!isNaN(elementOne) && !isNaN(elementTwo)) {\n      return parseFloat(elementOne) * parseFloat(elementTwo);\n    }\n\n    const result = `(${elementOne})*(${elementTwo})`;\n\n    const calculatedValue = evaluate(result);\n    if (calculatedValue === Round(calculatedValue)) {\n      return Parenthesis(calculatedValue);\n    }\n    return Parenthesis(result);\n  }\n  function Divide(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): CalculatedResultType {\n    if (!isNaN(elementOne) || !isNaN(elementTwo)) {\n      if (parseFloat(elementOne) === 0) {\n        return 0;\n      }\n      if (parseFloat(elementTwo) === 0) {\n        ErrorService.showError('200');\n      }\n      if (!isNaN(elementTwo) && Math.abs(elementTwo) === 1) {\n        const calculatedValue = evaluate(elementOne);\n        if (calculatedValue === Round(calculatedValue)) {\n          return Parenthesis(parseFloat(elementTwo) * calculatedValue);\n        }\n        const isNegative = parseFloat(elementTwo) / Math.abs(elementTwo) < 0;\n        return Parenthesis(`${isNegative ? '-' : ''}(${elementOne})`);\n      }\n    }\n\n    const result = `(${elementOne})/(${elementTwo})`;\n\n    const calculatedValue = evaluate(result);\n    if (calculatedValue === Round(calculatedValue)) {\n      return Parenthesis(calculatedValue);\n    }\n    return Parenthesis(result);\n  }\n  function Sqrt(element: CalculatedResultType): CalculatedResultType {\n    const result = `(${element})^(1/2)`;\n    if (Round(element) < 0) {\n      ErrorService.showError('200');\n    }\n    const calculatedValue = evaluate(result);\n    if (typeof calculatedValue !== 'number') {\n      if (Round(element, 8) === 0) {\n        return 0;\n      }\n      ErrorService.showError('200');\n    }\n    if (calculatedValue === Round(calculatedValue)) {\n      return calculatedValue;\n    }\n    return Parenthesis(result);\n  }\n  function Pow(element: CalculatedResultType, exponent: CalculatedResultType): CalculatedResultType {\n    if (!isNaN(element)) {\n      return parseFloat(element) * parseFloat(element);\n    }\n    const result = `(${element})^(${exponent})`;\n\n    const calculatedValue = evaluate(result);\n\n    if (calculatedValue === Round(calculatedValue)) {\n      return Parenthesis(calculatedValue);\n    }\n    return Parenthesis(result);\n  }\n\n  function isEqual(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): boolean {\n    const calculatedValueOne = Round(elementOne, 7);\n    const calculatedValueTwo = Round(elementTwo, 7);\n\n    return calculatedValueOne === calculatedValueTwo;\n  }\n\n  function Compare(elementOne: CalculatedResultType, elementTwo: CalculatedResultType): number {\n    const calculatedValueOne = Round(elementOne, 3);\n    const calculatedValueTwo = Round(elementTwo, 3);\n\n    if (calculatedValueOne > calculatedValueTwo) {\n      return 1;\n    }\n    if (calculatedValueOne < calculatedValueTwo) {\n      return -1;\n    }\n    return 0;\n  }\n  function isZero(element: CalculatedResultType): boolean {\n    return Round(element, 5) === 0;\n  }\n\n  function isSmallerThanZero(element: CalculatedResultType): boolean {\n    return Round(element, 5) < 0;\n  }\n\n  function Abs(element: CalculatedResultType): CalculatedResultType {\n    const calculatedValue = evaluate(element);\n\n    if (calculatedValue >= 0) {\n      return element;\n    }\n\n    return Parenthesis(Sub(0, element));\n  }\n\n  function Round(element: CalculatedResultType, f?: number = 3): number {\n    const calculatedValue = typeof element === 'number' ? element : evaluate(element);\n    const myF = Math.pow(10, f);\n    return Math.round(calculatedValue * myF) / myF;\n  }\n\n  function Max(...values: Array<CalculatedResultType>): CalculatedResultType {\n    let max = values[0];\n    let maxValue = evaluate(max);\n    values.forEach((value: CalculatedResultType) => {\n      const evaluatedValue = evaluate(value);\n      if (evaluatedValue > maxValue) {\n        maxValue = evaluatedValue;\n        max = value;\n      }\n    });\n\n    return max;\n  }\n\n  return Object.freeze({\n    Parenthesis,\n    Add,\n    Sub,\n    Multiply,\n    Divide,\n    Sqrt,\n    Pow,\n    isEqual,\n    Compare,\n    isZero,\n    Abs,\n    isSmallerThanZero,\n    Round,\n    Max\n  });\n}\n\nconst instance = MathOperation();\n\nexport { instance as Operation };\n","import type {\n  EquationType,\n  LineType,\n} from '../../utils/types';\nimport { isValid } from '../utils/index';\nimport { Operation } from './MathOperation';\n\nconst {Sub, Divide, isZero} = Operation;\n\nexport function convertLinearToEquation(l: EquationType): EquationType {\n  if (\n    isValid(l) &&\n    isValid(l.c) &&\n    isValid(l.d) &&\n    isValid(l.e)\n  ) {\n    return {\n      a: 0,\n      b: 0,\n      c: l.c,\n      d: l.d,\n      e: l.e,\n    };\n  }\n}\n\nexport function convertEquationToLineType(line: EquationType): LineType {\n  if (\n    isValid(line) &&\n    isValid(line.c) &&\n    isValid(line.d) &&\n    isValid(line.e)\n  ) {\n    return {\n      //-line.c / (line.d === 0 ? 1 : line.d)\n      a: Divide(Sub(0, line.c), isZero(line.d) ?\n        1 :\n        line.d),\n      b: Divide(Sub(0, line.e), isZero(line.d) ?\n        1 :\n        line.d),\n    };\n  }\n}\n\nexport function convertLineTypeToEquation(line: LineType): EquationType {\n  if (\n    isValid(line) &&\n    isValid(line.a) &&\n    isValid(line.b)\n  ) {\n    return {\n      a: 0,\n      b: 0,\n      c: Sub(0, line.a),\n      d: 1,\n      e: Sub(0, line.b),\n    };\n  }\n}\n","// @flow\n\nimport GConst from '../config/values';\nimport type {\n\tCoordinateType,\n\tEquationType,\n} from '../../utils/types';\nimport {\n\tcalculatePerpendicularLineByPointAndLine,\n\tcalculateQuadraticEquation,\n\tgetLineFromTwoPoints,\n} from './Math2D';\nimport {\n\tisNum,\n\tisValid,\n} from '../utils';\nimport { Operation } from './MathOperation';\n\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\n\nconst {\n  Add,\n  Sub,\n  Multiply,\n  Divide,\n  Sqrt,\n  Pow,\n  isEqual,\n  Compare,\n  isZero,\n  Abs,\n  isSmallerThanZero,\n  Round,\n  Max\n} = Operation;\n\nexport function getStartPoint(): CoordinateType {\n  return {\n    x: 0,\n    y: 0\n  };\n}\n\nexport function getRandomValue(min: number, max: number): number {\n  if (isNum(min) && isNum(max)) {\n    if (max < min) {\n      return min;\n    }\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  return min;\n}\n\nexport function getRandomPointInEquation(equation: EquationType): CoordinateType {\n  if (\n    isValid(equation) &&\n    isValid(equation.a) &&\n    isValid(equation.b) &&\n    isValid(equation.c) &&\n    isValid(equation.d) &&\n    isValid(equation.e)\n  ) {\n    if (!equation.a) {\n      equation.a = 0;\n    }\n    if (!equation.b) {\n      equation.b = 0;\n    }\n    if (isZero(equation.a) && isZero(equation.b)) {\n      if (!isZero(equation.d)) {\n        const tempX = getRandomValue(MIN, MAX);\n        return {\n          x: tempX,\n          //y: (-equation.e - equation.c * tempX) / equation.d\n          y: Divide(Sub(0, Add(equation.e, Multiply(equation.c, tempX))), equation.d)\n        };\n      } else {\n        return {\n          x: Divide(Sub(0, equation.e), equation.c),\n          y: getRandomValue(MIN, MAX)\n        };\n      }\n    } else if (isEqual(equation.a, 1) && isEqual(equation.b, 1)) {\n      const centerPoint = {\n        a: Divide(equation.c, -2),\n        b: Divide(equation.d, -2)\n      };\n      //Math.sqrt(centerPoint.a * centerPoint.a + centerPoint.b * centerPoint.b - equation.e);\n      const radius = Sqrt(Sub(Add(Pow(centerPoint.a, 2), Pow(centerPoint.b, 2)), equation.e));\n      const randomValueX = getRandomValue(Round(Sub(centerPoint.a, radius), 9), Round(Add(centerPoint.a, radius), 9));\n\n      let solvedValueY = [];\n      if (isValid(randomValueX)) {\n        solvedValueY = calculateQuadraticEquation(\n          equation.b,\n          equation.d,\n          //randomValueX * randomValueX + equation.c * randomValueX + equation.e\n          Add(Add(Pow(randomValueX, 2), Multiply(randomValueX, equation.c)), equation.e)\n        );\n      }\n\n      return {\n        x: randomValueX,\n        y: solvedValueY[getRandomValue(0, solvedValueY.length)] || 0\n      };\n    }\n  }\n}\n\nexport function generatePointAlignmentInside(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\n\tif (isValid(firstPoint) && isValid(firstPoint.x) && isValid(secondPoint) && isValid(secondPoint.x)) {\n\t\tconst line = getLineFromTwoPoints(firstPoint, secondPoint);\n\t\t// const randomValue = getRandomValue(2, 5);\n\t\t// const tempX = Divide(Add(firstPoint.x, Multiply(secondPoint.x, randomValue - 1)), randomValue);\n\t\tconst rV = getRandomValue(20, 80) / 100;\n\t\tlet less = Compare(firstPoint.x, secondPoint.x) < 0\n\t\t           ? firstPoint.x\n\t\t           : secondPoint.x;\n\t\tlet greater = Compare(less, firstPoint.x) === 0\n\t\t              ? secondPoint.x\n\t\t              : firstPoint.x;\n\t\tlet dis = Sub(greater, less);\n\n\t\tif (Round(dis) != 0) {\n\t\t\tconst tempX = Add(less, Multiply(dis, rV));\n\t\t\tif (isValid(line) && isValid(line.c) && isValid(line.d) && isValid(line.e) && isValid(tempX)) {\n\t\t\t\t// line.d can not equals 0\n\t\t\t\treturn {\n\t\t\t\t\tx: tempX,\n\t\t\t\t\t//y: (line.c * tempX + line.e) / -line.d\n\t\t\t\t\ty: Divide(Add(Multiply(line.c, tempX), line.e), Sub(0, line.d)),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tless = Compare(firstPoint.y, secondPoint.y) < 0\n\t\t\t       ? firstPoint.y\n\t\t\t       : secondPoint.y;\n\t\t\tgreater = Compare(less, firstPoint.y) === 0\n\t\t\t          ? secondPoint.y\n\t\t\t          : firstPoint.y;\n\t\t\tdis = Sub(greater, less);\n\t\t\tif(Round(dis) == 0) {\n\t\t\t\treturn {\n\t\t\t\t\tx: firstPoint.x,\n\t\t\t\t\ty: firstPoint.y,\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst tempY = Add(less, Multiply(dis, rV));\n\t\t\tif (isValid(line) && isValid(line.c) && isValid(line.d) && isValid(line.e) && isValid(tempY)) {\n\t\t\t\t// line.c can not equals 0\n\t\t\t\treturn {\n\t\t\t\t\t// x = (line.d * tempY + line.e) / -line.c\n\t\t\t\t\tx: Divide(Add(Multiply(line.d, tempY), line.e), Sub(0, line.c)),\n\t\t\t\t\ty: tempY,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function generatePointAlignmentOutside(\n  firstPoint: CoordinateType,\n  secondPoint: CoordinateType,\n  isRight: boolean = true\n): CoordinateType {\n  if (isValid(firstPoint) && isValid(firstPoint.x) && isValid(secondPoint) && isValid(secondPoint.x)) {\n    const line = getLineFromTwoPoints(firstPoint, secondPoint);\n    const tempXRight = getRandomValue(secondPoint.x, MAX);\n    const tempXLeft = getRandomValue(MIN, firstPoint.x);\n\n    if (\n      isValid(line) &&\n      isValid(line.c) &&\n      isValid(line.d) &&\n      isValid(line.e) &&\n      isValid(tempXLeft) &&\n      isValid(tempXRight)\n    ) {\n      return isRight\n        ? {\n            x: tempXRight,\n            y: Divide(Add(Multiply(line.c, tempXRight), line.e), Sub(0, line.d))\n          }\n        : {\n            x: tempXLeft,\n            y: Divide(Add(Multiply(line.c, tempXLeft), line.e), Sub(0, line.d))\n          };\n    }\n  }\n}\n\nexport function generatePointNotAlignment(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\n  if (isValid(firstPoint) && isValid(secondPoint)) {\n    let resultPoint: CoordinateType = {};\n    resultPoint.x = getRandomValue(MIN, MAX);\n    const line = getLineFromTwoPoints(firstPoint, secondPoint);\n    if (isValid(line) && isValid(line.c) && isValid(line.e)) {\n      do {\n        resultPoint.y = getRandomValue(MIN, MAX);\n      } while (isEqual(resultPoint.y, Add(Multiply(line.c, resultPoint.x)), line.e));\n    }\n    return resultPoint;\n  }\n}\n\nexport function generatePointMiddleTwoPoints(p1: CoordinateType, p2: CoordinateType) {\n  if (isValid(p1) && isValid(p2)) {\n    const line = getLineFromTwoPoints(p1, p2);\n    const randomPoint = generatePointAlignmentInside(p1, p2);\n\n    const randomLine = calculatePerpendicularLineByPointAndLine(randomPoint, line);\n    return getRandomPointInEquation(randomLine);\n  }\n}\n","const env = {\n  isDev: true,\n};\n\nlet isOffLog = false;\n\nexport default class GConfig {\n  static offLog() {\n    isOffLog = true;\n  }\n\n  static onLog() {\n    isOffLog = false;\n  }\n\n  static offEnvDev() {\n    env.isDev = false;\n  }\n\n  static onEnvDev() {\n    env.isDev = true;\n  }\n\n  static get isDev() {\n    return env.isDev;\n  }\n\n  static get env() {\n    return env;\n  }\n  \n  static get isOffLog() {\n    return isOffLog;\n  }\n}","import GConfig from './GConfig';\n\nexport default class GLog {\n  static logInfo(moduleName, ...args) {\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor) {\n      console.info(`[${moduleName.constructor.name}]`, ...args);\n    }\n  }\n\n  static logMsg(moduleName, msg, offThis = false) {\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor && !offThis) {\n      console.log(`[${moduleName.constructor.name}]`, msg);\n    }\n  }\n\n  static logMsgWithLineBreaks(moduleName, ...msgs) {\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor) {\n      let msg = undefined;\n      if (Array.isArray(msgs)) {\n        msg = msgs.join('\\n ');\n      }\n      console.log(`[${moduleName.constructor.name}]`, `\\n ${msg}`);\n    }\n  }\n\n  static logError(moduleName, error, offThis = false) {\n    if (!GConfig.isOffLog && GConfig.isDev && moduleName && moduleName.constructor && !offThis) {\n      console.error(`[${moduleName.constructor.name}]`, error);\n    }\n  }\n}","import GConst from '../config/values';\nimport type { CalculatedResultType, CircleType, CoordinateType, EquationType, LineType } from '../../utils/types';\nimport { convertEquationToLineType, convertLinearToEquation, convertLineTypeToEquation } from './Converter';\nimport { getRandomPointInEquation, getRandomValue } from './Generation';\nimport ErrorService from '../error/ErrorHandleService';\nimport { Operation } from './MathOperation';\nimport GLog from '../config/GLog';\nimport { isValid } from '../utils';\n\nconst MIN = GConst.Number.MIN_RANDOM_NUMBER;\nconst MAX = GConst.Number.MAX_RANDOM_NUMBER;\nconst INFINITY = GConst.String.INFINITY;\nconst IMPOSSIBLE = GConst.String.IMPOSSIBLE;\nconst NOT_BE_IN_LINE = GConst.String.NOT_BE_IN_LINE;\n\nconst {\n  Add,\n  Sub,\n  Multiply,\n  Divide,\n  Sqrt,\n  Pow,\n  isEqual,\n  Compare,\n  isZero,\n  Abs,\n  isSmallerThanZero,\n  Round,\n  Max\n} = Operation;\n\nfunction _makeRound(num: CalculatedResultType, f: number = 3): number {\n  if (typeof num === 'string') {\n    return Round(num, f);\n  }\n  if (!isValid(num)) {\n    GLog.logError(this, `${num} is NaN`);\n    throw console.error('error', num);\n  }\n  const myF = Math.pow(10, f);\n  return Math.round(num * myF) / myF;\n}\n\nexport function calculateVector(\n  firstPoint: CoordinateType,\n  secondPoint: CoordinateType,\n  isMakeRound? = true\n): CoordinateType {\n  if (\n    isValid(firstPoint) &&\n    isValid(secondPoint) &&\n    isValid(firstPoint.x) &&\n    isValid(firstPoint.y) &&\n    isValid(secondPoint.x) &&\n    isValid(secondPoint.y)\n  ) {\n    const x = Operation.Sub(secondPoint.x, firstPoint.x);\n    const y = Operation.Sub(secondPoint.y, firstPoint.y);\n\n    if (isMakeRound) {\n      return {\n        x: _makeRound(x),\n        y: _makeRound(y)\n      };\n    }\n    return {\n      x,\n      y\n    };\n  }\n}\n\nexport function isVectorSameDirection(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\n  if (\n    isValid(firstVector) &&\n    isValid(secondVector) &&\n    isValid(firstVector.x) &&\n    isValid(firstVector.y) &&\n    isValid(secondVector.x) &&\n    isValid(secondVector.y)\n  ) {\n    if (isZero(firstVector.x)) {\n      return (\n        isZero(secondVector.x) &&\n        isEqual(Divide(firstVector.y, Abs(firstVector.y)), Divide(secondVector.y, Abs(secondVector.y)))\n      );\n    }\n\n    if (isZero(firstVector.y)) {\n      return (\n        isZero(secondVector.y) &&\n        isEqual(Divide(firstVector.x, Abs(firstVector.x)), Divide(secondVector.x, Abs(secondVector.x)))\n      );\n    }\n\n    if (isZero(secondVector.x)) {\n      return (\n        isZero(firstVector.x) &&\n        isEqual(Divide(firstVector.y, Abs(firstVector.y)), Divide(secondVector.y, Abs(secondVector.y)))\n      );\n    }\n\n    if (isZero(secondVector.y)) {\n      return (\n        isZero(firstVector.y) &&\n        isEqual(Divide(firstVector.x, Abs(firstVector.x)), Divide(secondVector.x, Abs(secondVector.x)))\n      );\n    }\n\n    return (\n      isEqual(Divide(firstVector.x, Abs(firstVector.x)), Divide(secondVector.x, Abs(secondVector.x))) &&\n      isEqual(Divide(firstVector.y, Abs(firstVector.y)), Divide(secondVector.y, Abs(secondVector.y))) &&\n      isEqual(_makeRound(Multiply(firstVector.x, secondVector.y)), _makeRound(Multiply(firstVector.y, secondVector.x)))\n    );\n  }\n}\n\nexport function isVectorInSameLine(firstVector: CoordinateType, secondVector: CoordinateType): boolean {\n  if (\n    isValid(firstVector) &&\n    isValid(secondVector) &&\n    isValid(firstVector.x) &&\n    isValid(firstVector.y) &&\n    isValid(secondVector.x) &&\n    isValid(secondVector.y)\n  ) {\n    if (isZero(firstVector.x)) {\n      return isZero(secondVector.x);\n    }\n\n    if (isZero(firstVector.y)) {\n      return isZero(secondVector.y);\n    }\n\n    if (isZero(secondVector.x)) {\n      return isZero(firstVector.x);\n    }\n\n    if (isZero(secondVector.y)) {\n      return isZero(firstVector.y);\n    }\n\n    return isEqual(\n      _makeRound(Multiply(firstVector.x, secondVector.y)),\n      _makeRound(Multiply(firstVector.y, secondVector.x))\n    );\n  }\n}\n\nexport function calculateMiddlePoint(firstPoint: CoordinateType, secondPoint: CoordinateType): CoordinateType {\n  if (\n    isValid(firstPoint) &&\n    isValid(secondPoint) &&\n    isValid(firstPoint.x) &&\n    isValid(firstPoint.y) &&\n    isValid(secondPoint.x) &&\n    isValid(secondPoint.y)\n  ) {\n    const x = Divide(Add(firstPoint.x, secondPoint.x), 2);\n    const y = Divide(Add(firstPoint.y, secondPoint.y), 2);\n    return {\n      x,\n      y\n    };\n  }\n}\n\nexport function calculateSymmetricalPoint(\n  firstPoint: CoordinateType,\n  secondPoint: CoordinateType,\n  isRight: boolean = true\n): CoordinateType {\n  if (\n    isValid(firstPoint) &&\n    isValid(secondPoint) &&\n    isValid(firstPoint.x) &&\n    isValid(firstPoint.y) &&\n    isValid(secondPoint.x) &&\n    isValid(secondPoint.y)\n  ) {\n    return isRight\n      ? {\n          x: Sub(Multiply(2, secondPoint.x), firstPoint.x),\n          y: Sub(Multiply(2, secondPoint.y), firstPoint.y)\n        }\n      : {\n          x: Sub(Multiply(2, firstPoint.x), secondPoint.x),\n          y: Sub(Multiply(2, firstPoint.y), secondPoint.y)\n        };\n  }\n}\n\nexport function getLineFromTwoPoints(p1: CoordinateType, p2: CoordinateType): EquationType {\n  if (isValid(p1) && isValid(p2) && isValid(p1.x) && isValid(p1.y) && isValid(p2.x) && isValid(p2.y)) {\n    const directionVector = {\n      a: Sub(p2.x, p1.x),\n      b: Sub(p2.y, p1.y)\n    };\n    const normalVector = {\n      a: Sub(0, directionVector.b),\n      b: directionVector.a\n    };\n\n    return {\n      a: 0,\n      b: 0,\n      c: normalVector.a,\n      d: normalVector.b,\n      //-normalVector.a * p1.x - normalVector.b * p1.y\n      e: Sub(Multiply(Sub(0, normalVector.a), p1.x), Multiply(normalVector.b, p1.y))\n    };\n  }\n}\n\nexport function calculateParallelEquation(equation: EquationType): EquationType {\n  if (isValid(equation) && isValid(equation.c) && isValid(equation.d)) {\n    // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\n    const e = Math.floor(Math.random() * 100) - MAX;\n\n    let parallelEquation: EquationType = {};\n    parallelEquation.c = equation.c;\n    parallelEquation.d = equation.d;\n    parallelEquation.e = e;\n\n    return parallelEquation;\n  }\n}\n\nexport function calculatePerpendicularEquation(equation: EquationType): EquationType {\n  if (isValid(equation) && isValid(equation.c) && isValid(equation.d)) {\n    // Random a constance term from MIN_RANDOM_NUMBER -> MAX_RANDOM_NUMBER\n    const e = Math.floor(Math.random() * 100) - MIN;\n\n    let perpendicularEquation: EquationType = {};\n    perpendicularEquation.c = Sub(0, equation.c);\n    perpendicularEquation.d = equation.d;\n    perpendicularEquation.e = e;\n\n    return perpendicularEquation;\n  }\n}\n\nexport function calculateDistanceTwoPoints(\n  firstPoint: CoordinateType,\n  secondPoint: CoordinateType\n): CalculatedResultType {\n  if (\n    isValid(firstPoint) &&\n    isValid(secondPoint) &&\n    isValid(firstPoint.x) &&\n    isValid(firstPoint.y) &&\n    isValid(secondPoint.x) &&\n    isValid(secondPoint.y)\n  ) {\n    const squareX = Pow(Sub(secondPoint.x, firstPoint.x), 2);\n    const squareY = Pow(Sub(secondPoint.y, firstPoint.y), 2);\n    return Sqrt(Add(squareX, squareY));\n  }\n}\n\nexport function calculateDistanceFromPointToLine(point: CoordinateType, line: EquationType): CalculatedResultType {\n  if (isValid(point) && isValid(line) && isValid(line.c) && isValid(line.d) && isValid(line.e)) {\n    let numerator = Abs(Add(Add(Multiply(line.c, point.x), Multiply(line.d, point.y)), line.e));\n    let denominator = Sqrt(Add(Pow(line.c, 2), Pow(line.d, 2)));\n\n    if (isZero(denominator)) {\n      GLog.logError(this, 'calculateDistanceFromPointToLine: mẫu số bằng 0');\n      ErrorService.showError(200);\n      return {};\n    }\n    return Divide(numerator, denominator);\n  }\n}\n\nexport function calculateParallelLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\n  if (isValid(point) && isValid(point.x) && isValid(point.y) && isValid(line) && isValid(line.d)) {\n    // parallel line has `a` coefficient equals the other line.\n    // parallel line's e = -ax - y with (x,y) is coordinate of the point\n    const lineEquation = convertEquationToLineType(line);\n    const parLine: LineType = {};\n    parLine.a = lineEquation.a;\n    parLine.b = Sub(point.y, Multiply(lineEquation.a, point.x));\n\n    let result = convertLineTypeToEquation(parLine);\n    if (isZero(line.d)) {\n      result.d = line.d;\n    }\n    return result;\n  }\n}\n\nexport function calculatePerpendicularLineByPointAndLine(point: CoordinateType, line: EquationType): EquationType {\n  if (isValid(point) && isValid(point.x) && isValid(point.y) && isValid(line) && isValid(line.c) && isValid(line.d)) {\n    let perpendicularLine: EquationType = {};\n\n    // perpendicular line has the direction vector is opposite pairs with the other line.\n    // perpendicular line's e = -ax - y with (x,y) is coordinate of the point\n    if (isZero(line.c)) {\n      perpendicularLine.c = Divide(-1, line.d);\n      perpendicularLine.d = 0;\n      perpendicularLine.e = Multiply(Sub(0, perpendicularLine.c), point.x);\n    } else if (isZero(line.d)) {\n      perpendicularLine.c = 0;\n      perpendicularLine.d = Divide(-1, line.c);\n      perpendicularLine.e = Multiply(Sub(0, perpendicularLine.d), point.y);\n    } else {\n      const lineEquation = convertEquationToLineType(line);\n      const perLine: LineType = {};\n      perLine.a = Divide(-1, lineEquation.a);\n      perLine.b = Add(point.y, Divide(point.x, lineEquation.a));\n      perpendicularLine = convertLineTypeToEquation(perLine);\n    }\n\n    return perpendicularLine;\n  }\n}\n\nexport function calculateIntersectionByLineAndLine(lineOne: EquationType, lineTwo: EquationType): CoordinateType {\n  if (\n    isValid(lineOne) &&\n    isValid(lineOne.c) &&\n    isValid(lineOne.d) &&\n    isValid(lineOne.e) &&\n    isValid(lineTwo) &&\n    isValid(lineTwo.c) &&\n    isValid(lineTwo.d) &&\n    isValid(lineTwo.e)\n  ) {\n    let r = calculateSetOfEquationTypeAndQuadraticEquation(\n      {\n        c: lineOne.c,\n        d: lineOne.d,\n        e: lineOne.e\n      },\n      {\n        a: 0,\n        b: 0,\n        c: lineTwo.c,\n        d: lineTwo.d,\n        e: lineTwo.e\n      }\n    );\n\n    if (Array.isArray(r)) {\n      if (r.length === 0) {\n        return [];\n      } else {\n        return r[0];\n      }\n    }\n  }\n}\n\nexport function calculateCircleEquationByCenterPoint(\n  centerPoint: CoordinateType,\n  radius: CalculatedResultType\n): EquationType {\n  if (isValid(centerPoint) && isValid(centerPoint.x) && isValid(centerPoint.y) && isValid(radius)) {\n    //const roundedRadius = _makeRound(radius, 6);\n    return {\n      a: 1,\n      b: 1,\n      c: Multiply(-2, centerPoint.x),\n      d: Multiply(-2, centerPoint.y),\n      //centerPoint.x * centerPoint.x + centerPoint.y * centerPoint.y - radius * radius\n      e: Sub(Add(Pow(centerPoint.x, 2), Pow(centerPoint.y, 2)), Pow(radius, 2))\n    };\n  }\n}\n\nexport function calculateInternalBisectLineEquation(\n  lineOne: EquationType,\n  lineTwo: EquationType,\n  pointOne: CoordinateType,\n  pointTwo: CoordinateType\n): EquationType {\n  if (isValid(lineOne) && isValid(lineTwo) && isValid(pointOne) && isValid(pointTwo)) {\n    const results = _calculateBisectLineEquation(lineOne, lineTwo);\n    const firstLine: EquationType = results[0];\n    const secondLine: EquationType = results[1];\n\n    // const pointInFirstLine: CoordinateType = getRandomPointInLine(lineOne);\n    // let pointInSecondLine: CoordinateType = { x: pointInFirstLine.x, y: undefined };\n    // if (lineTwo.d !== 0) {\n    //   pointInSecondLine.y = (-lineTwo.e - lineTwo.c * pointInSecondLine.x) / lineTwo.d;\n    // } else {\n    //   pointInSecondLine.y = getRandomValue(MIN_RANDOM_NUMBER, MAX_RANDOM_NUMBER);\n    // }\n\n    if (isZero(getAngleFromTwoLines(lineOne, lineTwo))) {\n      throw new Map().set('error', 'không hỗ trợ trường hợp này');\n    }\n    return _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\n  }\n}\n\nexport function calculateExternalBisectLineEquation(\n  lineOne: EquationType,\n  lineTwo: EquationType,\n  pointOne: CoordinateType,\n  pointTwo: CoordinateType\n): EquationType {\n  if (isValid(lineOne) && isValid(lineTwo) && isValid(pointOne) && isValid(pointTwo)) {\n    let results = _calculateBisectLineEquation(lineOne, lineTwo);\n    const firstLine: EquationType = results[0];\n    const secondLine: EquationType = results[1];\n\n    if (isZero(getAngleFromTwoLines(lineOne, lineTwo))) {\n      throw new Map().set('error', 'không hỗ trợ trường hợp này');\n    }\n\n    const internalLine = _getInternalBisectLineEquation(firstLine, secondLine, pointOne, pointTwo);\n\n    results = results.filter((line: EquationType): boolean => JSON.stringify(line) !== JSON.stringify(internalLine));\n    return results[0];\n  }\n}\n\nfunction _calculateBisectLineEquation(lineOne: EquationType, lineTwo: EquationType): [EquationType, EquationType] {\n  if (\n    isValid(lineOne) &&\n    isValid(lineOne.c) &&\n    isValid(lineOne.d) &&\n    isValid(lineOne.e) &&\n    isValid(lineTwo) &&\n    isValid(lineTwo.c) &&\n    isValid(lineTwo.d) &&\n    isValid(lineTwo.e)\n  ) {\n    let resultOne: EquationType = {};\n    let resultTwo: EquationType = {};\n\n    // ax + by + c = +/- [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')] * (a'x + b'y + c)\n\n    // check if denominator equals 0\n    if (isZero(Add(Pow(lineTwo.c, 2), Pow(lineTwo.d, 2)))) {\n      GLog.logError(this, 'calculateDistanceFromPointToLine: mẫu số bằng 0');\n      ErrorService.showError(200);\n      return [];\n    }\n\n    // Represent for [sqrt(a*a + b*b) / sqrt(a'*a' + b'*b')]\n    //   Math.sqrt(lineOne.c * lineOne.c + lineOne.d * lineOne.d)\n    //  /Math.sqrt(lineTwo.c * lineTwo.c + lineTwo.d * lineTwo.d);\n\n    let coefficient = Divide(\n      Sqrt(Add(Multiply(lineOne.c, lineOne.c), Multiply(lineOne.d, lineOne.d))),\n      Sqrt(Add(Multiply(lineTwo.c, lineTwo.c), Multiply(lineTwo.d, lineTwo.d)))\n    );\n\n    /*\n     * Two results:\n     *    (a - coefficient*a')x + (b - coefficient*b')y + c - coefficient*c' = 0\n     *    (a + coefficient*a')x + (b + coefficient*b')y + c + coefficient*c' = 0\n     */\n    resultOne.c = Sub(lineOne.c, Multiply(coefficient, lineTwo.c));\n    resultOne.d = Sub(lineOne.d, Multiply(coefficient, lineTwo.d));\n    resultOne.e = Sub(lineOne.e, Multiply(coefficient, lineTwo.e));\n\n    resultTwo.c = Add(lineOne.c, Multiply(coefficient, lineTwo.c));\n    resultTwo.d = Add(lineOne.d, Multiply(coefficient, lineTwo.d));\n    resultTwo.e = Add(lineOne.e, Multiply(coefficient, lineTwo.e));\n\n    return [resultOne, resultTwo];\n  }\n}\n\n/*\n *   Line one and line two is 2 lines are the result of _calculateBisectLineEquation function\n *   Point one and point two are 2 points that each point located in each line\n *             which is equivalent each argument in _calculateBisectLineEquation function\n */\nfunction _getInternalBisectLineEquation(\n  lineOne: EquationType,\n  lineTwo: EquationType,\n  pointOne: CoordinateType,\n  pointTwo: CoordinateType\n): EquationType {\n  if (\n    isValid(lineOne) &&\n    isValid(lineOne.c) &&\n    isValid(lineOne.d) &&\n    isValid(lineOne.e) &&\n    isValid(lineTwo) &&\n    isValid(pointOne) &&\n    isValid(pointOne.x) &&\n    isValid(pointOne.y) &&\n    isValid(pointTwo) &&\n    isValid(pointTwo.x) &&\n    isValid(pointTwo.y)\n  ) {\n    //pointOne.x * lineOne.c + pointOne.y * lineOne.d + lineOne.e\n    let firstEquation = Add(Add(Multiply(pointOne.x, lineOne.c), Multiply(pointOne.y, lineOne.d)), lineOne.e);\n    let secondEquation = Add(Add(Multiply(pointTwo.x, lineOne.c), Multiply(pointTwo.y, lineOne.d)), lineOne.e);\n    return Compare(Multiply(firstEquation, secondEquation), 0) > 0 ? lineTwo : lineOne;\n  }\n}\n\n// TODO: Uncheck\nexport function calculateSetOfEquationTypes(d1: EquationType, d2: EquationType) {\n  if (\n    isValid(d1) &&\n    isValid(d1.c) &&\n    isValid(d1.d) &&\n    isValid(d1.e) &&\n    isValid(d2) &&\n    isValid(d2.c) &&\n    isValid(d2.d) &&\n    isValid(d2.e)\n  ) {\n    if (\n      (isZero(d1.c) && isZero(d2.c) && (isZero(d1.d) && isZero(d2.d))) ||\n      (isZero(d1.c) && isZero(d1.d)) ||\n      (isZero(d2.c) && isZero(d2.d))\n    ) {\n      GLog.logMsg(this, d1, d2, IMPOSSIBLE);\n      return {};\n    }\n    if (isZero(d1.c) && isZero(d2.d)) {\n      return {\n        x: Sub(0, Divide(d2.e, d2.c)),\n        y: Sub(0, Divide(d1.e, d1.d))\n      };\n    }\n    if (isZero(d2.c) && isZero(d1.d)) {\n      return {\n        x: Sub(0, Divide(d1.e, d1.c)),\n        y: Sub(0, Divide(d2.e, d2.d))\n      };\n    }\n    if (isZero(d1.e) && isZero(d2.e)) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (isZero(d1.c)) {\n      const tempY = Sub(0, Divide(d1.e, d1.d));\n      return {\n        //(-d2.e - tempY * d2.d) / d2.c\n        x: Sub(0, Divide(Add(d2.e, Multiply(tempY, d2.d)), d2.c)),\n        y: tempY\n      };\n    }\n\n    if (isZero(d1.d)) {\n      const tempX = Sub(0, Divide(d1.e, d1.c));\n      return {\n        x: tempX,\n        y: Sub(0, Divide(Add(d2.e, Multiply(tempX, d2.c)), d2.d))\n      };\n    }\n\n    if (isZero(d2.c)) {\n      const tempY = Sub(0, Divide(d2.e, d2.d));\n      return {\n        x: Sub(0, Divide(Add(d1.e, Multiply(tempY, d1.d)), d1.c)),\n        y: tempY\n      };\n    }\n\n    if (isZero(d2.d)) {\n      const tempX = Sub(0, Divide(d2.e, d2.c));\n      return {\n        x: tempX,\n        y: Sub(0, Divide(Add(d1.e, Multiply(tempX, d1.c)), d1.d))\n      };\n    }\n\n    //(d1.e * d2.c - d1.c * d2.e) / (d1.d * d2.c - d1.c * d2.d)\n    const tempY = Sub(\n      0,\n      Divide(Sub(Multiply(d1.e, d2.c), Multiply(d1.c, d2.e)), Sub(Multiply(d1.d, d2.c), Multiply(d1.c, d2.d)))\n    );\n\n    return {\n      x: Sub(0, Divide(Add(d1.e, Multiply(tempY, d1.d)), d1.c)),\n      y: tempY\n    };\n  }\n}\n\n/*\n *  Find point(s) of intersection between a linear equation and a circle equation.\n *  @params:\n *        + d (EquationType): a line.\n *        + c (CircleEquation): a circle.\n *  @return:\n *        + IMPOSSIBLE: if distance from center point of the circle to the line is greater than the radius.\n *        + (Array<Object>): if the line intersects the circle.\n *          + length = 1;\n *          + length = 2;\n */\nexport function calculateIntersectionEquationTypeWithCircleEquation(d: EquationType, q: EquationType): Array<Object> {\n  if (isValid(d) && isValid(q) && isValid(q.c) && isValid(q.d) && isValid(q.e)) {\n    const A = Divide(q.c, -2);\n    const B = Divide(q.d, -2);\n    const centerPoint: CoordinateType = {\n      x: A,\n      y: B\n    };\n    const distanceFromCenterPointToLine = calculateDistanceFromPointToLine(centerPoint, d);\n\n    if (Compare(distanceFromCenterPointToLine, Sqrt(Sub(Add(Pow(A, 2), Pow(B, 2)), q.e))) > 0) {\n      GLog.logMsgWithLineBreaks(this, d, q, IMPOSSIBLE);\n      return [];\n    } else {\n      return calculateSetOfEquationTypeAndQuadraticEquation(d, q);\n    }\n  }\n}\n\n/*\n * Solves a quadratic equation. This equation is defined: Ax2 + Bx + C = 0.\n *\n *  @params:\n *        + a (number): represents x's coefficient.\n *        + b (number): represents y's coefficient.\n *        + c (number): represents constant term.\n * @return:\n *        + IMPOSSIBLE (string): if the equation is no root.\n *        + (number): if the equation has only ONE root.\n *        + x1, x2 (Object): if the equation has TWO root.\n */\nexport function calculateQuadraticEquation(\n  a: CalculatedResultType,\n  b: CalculatedResultType,\n  c: CalculatedResultType\n): CalculatedResultType {\n  if (isValid(a) && isValid(b) && isValid(c)) {\n    const delta = Sub(Pow(b, 2), Multiply(4, Multiply(a, c)));\n\n    let firstRoot,\n      secondRoot: CalculatedResultType = undefined;\n\n    if (isZero(a)) {\n      if (isZero(b)) {\n        return [];\n      }\n      return [Sub(0, Divide(c, b))];\n    } else if (isSmallerThanZero(delta)) {\n      return [];\n    } else if (isZero(delta)) {\n      return [Sub(0, Divide(b, Multiply(2, a)))];\n    } else {\n      firstRoot = Divide(Add(Sub(0, b), Sqrt(delta)), Multiply(2, a));\n      secondRoot = Divide(Sub(Sub(0, b), Sqrt(delta)), Multiply(2, a));\n      return [firstRoot, secondRoot];\n    }\n  }\n  return [];\n}\n\n// Ax2 + By2 + Cx + Dy + E = 0\nexport function isIn(p: CoordinateType, e: EquationType): boolean {\n  if (\n    isValid(p) &&\n    isValid(p.x) &&\n    isValid(p.y) &&\n    isValid(e) &&\n    isValid(e.a) &&\n    isValid(e.b) &&\n    isValid(e.c) &&\n    isValid(e.d) &&\n    isValid(e.e)\n  ) {\n    if (p.x === undefined || p.y === undefined) {\n      return false;\n    }\n    if (e.a === undefined) {\n      e = convertLinearToEquation(e);\n    }\n    const temp = Add(\n      Add(Add(Multiply(e.a, Pow(p.x, 2)), Multiply(e.b, Pow(p.y, 2))), Add(Multiply(e.c, p.x), Multiply(e.d, p.y))),\n      e.e\n    );\n    return isZero(Round(temp));\n  }\n}\n\n/*\n *  Solves a set of a linear equation and quadratic equation.\n *  Linear equation is defined:     Ax + By + C = 0.\n *  Quadratic equation is defined:  Ax2 + By2 + Cx + Dy + E = 0.\n *\n *  @params:\n *        + l (EquationType): represents a linear equation.\n *        + q (QuadraticEquation): represents a quadratic equation.\n *  @return:\n *        + IMPOSSIBLE (string): if the set is no root.\n *        + (number): if the set has only ONE root.\n *        + x1, x2 (Object): if the set has TWO root.\n */\nexport function calculateSetOfEquationTypeAndQuadraticEquation(l: EquationType, q: EquationType): Array<Object> {\n  if (\n    isValid(l) &&\n    isValid(l.c) &&\n    isValid(l.d) &&\n    isValid(l.e) &&\n    isValid(q) &&\n    isValid(q.a) &&\n    isValid(q.b) &&\n    isValid(q.c) &&\n    isValid(q.d) &&\n    isValid(q.e)\n  ) {\n    let results: Array<Object> = [];\n    let u, v, w;\n\n    const A = l.c;\n    const B = l.d;\n    const C = l.e;\n    const D = q.a;\n    const E = q.b;\n    const F = q.c;\n    const G = q.d;\n    const H = q.e;\n\n    if (!isZero(A)) {\n      //A * A * E + D * B * B\n      u = Add(Multiply(Pow(A, 2), E), Multiply(Pow(B, 2), D));\n      //2 * B * C * D - A * B * F + A * A * G\n      v = Add(Sub(Multiply(Multiply(2, B), Multiply(C, D)), Multiply(A, Multiply(B, F))), Multiply(Pow(A, 2), G));\n\n      //D * C * C - A * C * F + A * A * H\n      w = Sub(Add(Multiply(D, Pow(C, 2)), Multiply(H, Pow(A, 2))), Multiply(A, Multiply(C, F)));\n\n      // solves x. Unneeded check IMPOSSIBLE.\n      const root = calculateQuadraticEquation(u, v, w);\n      if (Array.isArray(root) && root.length === 1) {\n        results.push({\n          x: Divide(Sub(0, Add(C, Multiply(B, root[0]))), A),\n          y: root[0]\n        });\n      } else if (Array.isArray(root) && root.length === 0) {\n        return [];\n      } else {\n        const r1 = root[0];\n        const r2 = root[1];\n        results.push(\n          {\n            x: Divide(Sub(0, Add(C, Multiply(B, r1))), A),\n            y: r1\n          },\n          {\n            x: Divide(Sub(0, Add(C, Multiply(B, r2))), A),\n            y: r2\n          }\n        );\n      }\n    } else {\n      //q.a * l.d * l.d\n      u = Multiply(q.a, Pow(l.d, 2));\n      //q.c * l.d * l.d\n      v = Multiply(q.c, Pow(l.d, 2));\n      //q.b * l.e * l.e - q.d * l.d * l.e + q.e * l.d * l.d\n      w = Add(Sub(Multiply(q.b, Pow(l.e, 2)), Multiply(Multiply(q.d, l.d), l.e)), Multiply(q.e, Pow(l.d, 2)));\n      // solves x. Unneeded check IMPOSSIBLE.\n      const root = calculateQuadraticEquation(u, v, w);\n\n      if (Array.isArray(root) && root.length === 1) {\n        results.push({\n          x: root[0],\n          y: Divide(Sub(0, l.e), l.d)\n        });\n      } else if (Array.isArray(root) && root.length === 0) {\n        return [];\n      } else {\n        results.push(\n          {\n            x: root[0],\n            y: Divide(Sub(0, l.e), l.d)\n          },\n          {\n            x: root[1],\n            y: Divide(Sub(0, l.e), l.d)\n          }\n        );\n      }\n    }\n    return results;\n  }\n}\n\nexport function calculateIntersectionTwoCircleEquations(firstEquation: EquationType, secondEquation: EquationType) {\n  if (isValid(firstEquation) && isValid(secondEquation)) {\n    let results: Array<Object> = [];\n    if (!firstEquation || !secondEquation) {\n      return [];\n    }\n    let q1, q2;\n    firstEquation.a === undefined ? (q1 = convertLinearToEquation(firstEquation)) : (q1 = firstEquation);\n    secondEquation.a === undefined ? (q2 = convertLinearToEquation(secondEquation)) : (q2 = secondEquation);\n\n    if (!isEqual(q1.a, q2.a) && !isEqual(q1.b, q2.b)) {\n      if (isZero(q1.a) && isZero(q1.b)) {\n        // q2 is a quadratic equation\n        return calculateIntersectionEquationTypeWithCircleEquation(q1, q2);\n      } else {\n        // q1 is a quadratic equation\n        return calculateIntersectionEquationTypeWithCircleEquation(q2, q1);\n      }\n    } else if (isZero(q1.a) && isZero(q1.b) && isZero(q2.a) && isZero(q2.b)) {\n      return [calculateSetOfEquationTypes(q1, q2)];\n    } else {\n      // a x2 + b y2 + Ax + By + C = 0\n      // a'x2 + b'y2 + Dx + Ey + G = 0\n      const D = q2.c;\n      const E = q2.d;\n      const G = q2.e;\n\n      // Z = a - a'\n      const Z = Compare(q1.a, q2.a) > 0 ? q1.a : q2.a;\n      const _D = isEqual(Z, q1.a) ? q1.c : D;\n      const _E = isEqual(Z, q1.a) ? q1.d : E;\n      const _G = isEqual(Z, q1.a) ? q1.e : G;\n\n      const a = isEqual(Z, q1.a) ? Sub(q1.c, D) : Sub(D, q1.c);\n      const b = isEqual(Z, q1.a) ? Sub(q1.d, E) : Sub(E, q1.d);\n      const c = isEqual(Z, q1.a) ? Sub(q1.e, G) : Sub(G, q1.e);\n\n      if (isZero(a) || isZero(b)) {\n        if (isZero(a) && isZero(b)) {\n          GLog.logMsgWithLineBreaks(this, 'a = 0 || b = 0', firstEquation, secondEquation, IMPOSSIBLE);\n          return [];\n        }\n        if (isZero(a)) {\n          const y = Divide(Sub(0, c), b);\n          const x = calculateQuadraticEquation(1, D, Add(Add(G, Multiply(E, y)), Pow(y, 2)));\n          return x.map((value) => ({\n            x: value,\n            y\n          }));\n        }\n\n        if (isZero(b)) {\n          const x = Divide(Sub(0, c), a);\n          const y = calculateQuadraticEquation(1, E, Add(Add(G, Multiply(D, x)), Pow(x, 2)));\n          return y.map((value) => ({\n            x,\n            y: value\n          }));\n        }\n      } else {\n        const u = Multiply(Z, Add(Pow(b, 2), Pow(a, 2)));\n        // 2 * b * c * Z - _D * a * b + _E * a * a\n        const v = Sub(\n          Add(Multiply(Multiply(2, b), Multiply(c, Z)), Multiply(_E, Pow(a, 2))),\n          Multiply(_D, Multiply(a, b))\n        );\n        //Z * c * c - _D * a * c + _G * a * a\n        const w = Sub(Add(Multiply(Z, Pow(c, 2)), Multiply(_G, Pow(a, 2))), Multiply(_D, Multiply(a, c)));\n\n        const roots = calculateQuadraticEquation(u, v, w);\n        if (roots === []) {\n          GLog.logMsgWithLineBreaks(this, firstEquation, secondEquation, IMPOSSIBLE);\n          return roots;\n        } else if (Array.isArray(roots) && roots.length === 1) {\n          results.push({\n            x: Divide(Sub(0, Add(c, Multiply(b, roots))), a),\n            y: roots[0]\n          });\n        } else {\n          if (isValid(roots) && isValid(roots[0]) && isValid(roots[1])) {\n            const r1 = roots[0];\n            const r2 = roots[1];\n            results.push(\n              {\n                x: Divide(Sub(0, Add(c, Multiply(b, r1))), a),\n                y: r1\n              },\n              {\n                x: Divide(Sub(0, Add(c, Multiply(b, r2))), a),\n                y: r2\n              }\n            );\n          }\n        }\n      }\n      return results;\n    }\n  }\n  return [];\n}\n\nexport function calculateLinesByAnotherLineAndAngle(\n  rootPoint: CoordinateType,\n  staticPoint: CoordinateType,\n  dynamicPoint: CoordinateType,\n  angle: number\n): EquationType {\n  let dynamicVectorArr = [],\n    newRootPointArr = [],\n    staticVectorArr = [];\n  if (isValid(rootPoint) && isValid(staticPoint) && isValid(dynamicPoint) && isValid(angle)) {\n    const equations = _calculateLinesByAnotherLineAndAngle(\n      getLineFromTwoPoints(rootPoint, staticPoint),\n      dynamicPoint,\n      angle\n    );\n    let count = 0;\n    const filterEquations = equations.filter((equation: CoordinateType, i): boolean => {\n      const newRootPoint = calculateIntersectionByLineAndLine(getLineFromTwoPoints(rootPoint, staticPoint), equation);\n      const staticVector = calculateVector(rootPoint, staticPoint, false);\n      const dynamicVector = calculateVector(newRootPoint, dynamicPoint, false);\n      newRootPointArr.push(newRootPoint);\n      staticVectorArr.push(staticVector);\n      dynamicVectorArr.push(dynamicVector);\n      console.log(calculateAngleTwoVector(staticVector, dynamicVector), angle);\n      const result = calculateAngleTwoVector(staticVector, dynamicVector) === parseInt(angle);\n      if (result) {\n        count++;\n      }\n      return result;\n    });\n    if (count > 0) {\n      return filterEquations[getRandomValue(0, count - 1)];\n    } else {\n      debugger;\n    }\n\n    return ErrorService.showError('500');\n  }\n}\n\nfunction calculateIntegratedDirection(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\n  if (\n    isValid(vectorOne) &&\n    isValid(vectorOne.x) &&\n    isValid(vectorOne.y) &&\n    isValid(vectorTwo) &&\n    isValid(vectorTwo.x) &&\n    isValid(vectorTwo.y)\n  ) {\n    return Add(Multiply(vectorOne.x, vectorTwo.x), Multiply(vectorOne.y, vectorTwo.y));\n  }\n}\n\nfunction calculateVectorLength(vector: CoordinateType): number {\n  if (isValid(vector) && isValid(vector.x) && isValid(vector.y)) {\n    return Sqrt(Add(Pow(vector.x, 2), Pow(vector.y, 2)));\n  }\n}\n\nexport function calculateAngleTwoVector(vectorOne: CoordinateType, vectorTwo: CoordinateType): number {\n  if (\n    isValid(vectorOne) &&\n    isValid(vectorOne.x) &&\n    isValid(vectorOne.y) &&\n    isValid(vectorTwo) &&\n    isValid(vectorTwo.x) &&\n    isValid(vectorTwo.y)\n  ) {\n    if ((isZero(vectorOne.x) && isZero(vectorOne.y)) || (isZero(vectorTwo.x) && isZero(vectorTwo.y))) {\n      return 0;\n    }\n    return Round(\n      `(acos(\n     ${Divide(\n       calculateIntegratedDirection(vectorOne, vectorTwo),\n       Multiply(calculateVectorLength(vectorOne), calculateVectorLength(vectorTwo))\n     )})*180)/PI`,\n      1\n    );\n  }\n}\n\nexport function _calculateLinesByAnotherLineAndAngle(d: EquationType, p: CoordinateType, angle: number) {\n  if (isValid(d) && isValid(d.c) && isValid(d.d) && isValid(p) && isValid(p.x) && isValid(p.y) && isValid(angle)) {\n    let results: Array<EquationType> = [];\n\n    const cosine = Round(`cos((${angle} * PI) / 180)`);\n\n    //d.c * d.c - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d\n    const A = Sub(Sub(Pow(d.c, 2), Multiply(Pow(cosine, 2), Pow(d.c, 2))), Multiply(Pow(cosine, 2), Pow(d.d, 2)));\n    const B = Multiply(2, Multiply(d.c, d.d));\n    //d.d * d.d - cosine * cosine * d.c * d.c - cosine * cosine * d.d * d.d;\n    const C = Sub(Sub(Pow(d.d, 2), Multiply(Pow(cosine, 2), Pow(d.c, 2))), Multiply(Pow(cosine, 2), Pow(d.d, 2)));\n    const root = calculateQuadraticEquation(A, B, C);\n\n    if (Array.isArray(root) && root.length === 1) {\n      results.push({\n        c: root[0],\n        d: 1,\n        e: Sub(0, Add(Multiply(root[0], p.x), p.y))\n      });\n    } else if (root === []) {\n      GLog.logMsgWithLineBreaks(this, d, p, angle, IMPOSSIBLE);\n      return root;\n    } else {\n      if (isValid(root) && isValid(root[0]) && isValid(root[1])) {\n        results.push(\n          {\n            c: root[0],\n            d: 1,\n            //-root.firstRoot * p.x - p.y\n            e: Sub(0, Add(Multiply(root[0], p.x), p.y))\n          },\n          {\n            c: root[1],\n            d: 1,\n            e: Sub(0, Add(Multiply(root[1], p.x), p.y))\n          }\n        );\n      }\n    }\n\n    return results;\n  }\n}\n\nexport function makeRoundCoordinate(point: CoordinateType, f: number = 3) {\n  if (isValid(point)) {\n    if (typeof point === 'string') {\n      return point;\n    }\n    if (isValid(point.x) && isValid(point.y)) {\n      return {\n        x: Round(point.x, f),\n        y: Round(point.y, f)\n      };\n    }\n  }\n}\n\nexport function getAngleFromTwoLines(d1: EquationType, d2: EquationType): number {\n  if (\n    isValid(d1) &&\n    isValid(d1.a) &&\n    isValid(d1.b) &&\n    isValid(d1.c) &&\n    isValid(d1.d) &&\n    isValid(d1.e) &&\n    isValid(d2) &&\n    isValid(d2.a) &&\n    isValid(d2.b) &&\n    isValid(d2.c) &&\n    isValid(d2.d) &&\n    isValid(d2.e)\n  ) {\n    if (\n      d1.a ||\n      d1.b ||\n      d2.a ||\n      d2.b ||\n      (isZero(d1.c) && isZero(d1.d) && isZero(d1.e)) ||\n      (isZero(d2.c) && isZero(d2.d) && isZero(d2.e))\n    ) {\n      return -9999;\n    }\n\n    const a1 = d1.c;\n    const a2 = d2.c;\n    const b1 = d1.d;\n    const b2 = d2.d;\n\n    const result = `(acos(${Divide(\n      Abs(Add(Multiply(a1, a2), Multiply(b1, b2))),\n      Sqrt(Multiply(Add(Pow(a1, 2), Pow(b1, 2)), Add(Pow(a2, 2), Pow(b2, 2))))\n    )}) * 180) / PI`;\n\n    // round result\n    return Round(result, 1);\n  }\n  return -9999;\n}\n\nexport function getMiddlePointFromThreePointsInALine(\n  p1: CoordinateType,\n  p2: CoordinateType,\n  p3: CoordinateType\n): CoordinateType {\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\n    const line = getLineFromTwoPoints(p1, p2);\n    if (\n      !isIn(p3, {\n        a: 0,\n        b: 0,\n        c: line.c,\n        d: line.d,\n        e: line.e\n      })\n    ) {\n      GLog.logMsgWithLineBreaks(this, p1, p2, p3, NOT_BE_IN_LINE);\n      return {};\n    }\n\n    // another way: check vector =)))~\n    const dis_p1_p2 = calculateDistanceTwoPoints(p1, p2);\n    const dis_p2_p3 = calculateDistanceTwoPoints(p2, p3);\n    const dis_p1_p3 = calculateDistanceTwoPoints(p1, p3);\n\n    const max = Max(dis_p1_p2, dis_p2_p3, dis_p1_p3);\n    if (isEqual(dis_p1_p2, max)) {\n      return p3;\n    } else if (isEqual(dis_p1_p3, max)) {\n      return p2;\n    } else {\n      return p1;\n    }\n  }\n}\n\nexport function calculateCircumCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\n    const midperpendicularsLineOne = calculatePerpendicularLineByPointAndLine(\n      calculateMiddlePoint(p3, p2),\n      getLineFromTwoPoints(p3, p2)\n    );\n\n    const midperpendicularsLineTwo = calculatePerpendicularLineByPointAndLine(\n      calculateMiddlePoint(p1, p3),\n      getLineFromTwoPoints(p1, p3)\n    );\n\n    if (isValid(midperpendicularsLineOne) && isValid(midperpendicularsLineTwo)) {\n      const center = calculateIntersectionByLineAndLine(midperpendicularsLineOne, midperpendicularsLineTwo);\n      const radius = calculateDistanceTwoPoints(center, p1);\n\n      if (isValid(center) && isValid(radius)) {\n        const equation = calculateCircleEquationByCenterPoint(center, radius);\n        return {\n          center,\n          radius,\n          equation\n        };\n      }\n    }\n  }\n}\n\nexport function calculateInCircleEquation(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): CircleType {\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\n    const bisectorLineOne = calculateInternalBisectLineEquation(\n      getLineFromTwoPoints(p1, p3),\n      getLineFromTwoPoints(p1, p2),\n      p2,\n      p3\n    );\n\n    const bisectorLineTwo = calculateInternalBisectLineEquation(\n      getLineFromTwoPoints(p2, p3),\n      getLineFromTwoPoints(p1, p2),\n      p1,\n      p3\n    );\n\n    if (isValid(bisectorLineOne) && isValid(bisectorLineTwo)) {\n      const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\n      const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(p1, p3));\n\n      if (isValid(center) && isValid(radius)) {\n        const equation = calculateCircleEquationByCenterPoint(center, radius);\n        return {\n          center,\n          radius,\n          equation\n        };\n      }\n    }\n  }\n}\n\nexport function calculateEscribedCirclesEquation(\n  p1: CoordinateType,\n  p2: CoordinateType,\n  p3: CoordinateType,\n  escribedPoint: CoordinateType\n): CircleType {\n  GLog.logInfo(this, p1, p2, p3, escribedPoint);\n  if (isValid(p1) && isValid(p2) && isValid(p3) && isValid(escribedPoint)) {\n    const otherPoints = [p1, p2, p3].filter(\n      (point: CoordinateType): boolean => JSON.stringify(point) !== JSON.stringify(escribedPoint)\n    );\n\n    if (isValid(otherPoints)) {\n      if (otherPoints.length !== 2) {\n        ErrorService.showError('300');\n        return {};\n      }\n\n      if (isValid(otherPoints[0] && isValid(otherPoints[1]))) {\n        const bisectorLineOne = calculateInternalBisectLineEquation(\n          getLineFromTwoPoints(escribedPoint, otherPoints[0]),\n          getLineFromTwoPoints(escribedPoint, otherPoints[1]),\n          otherPoints[0],\n          otherPoints[1]\n        );\n\n        const bisectorLineTwo = calculateExternalBisectLineEquation(\n          getLineFromTwoPoints(escribedPoint, otherPoints[0]),\n          getLineFromTwoPoints(otherPoints[1], otherPoints[0]),\n          escribedPoint,\n          otherPoints[1]\n        );\n        if (isValid(bisectorLineOne) && isValid(bisectorLineTwo)) {\n          const center = calculateIntersectionByLineAndLine(bisectorLineOne, bisectorLineTwo);\n          const radius = calculateDistanceFromPointToLine(center, getLineFromTwoPoints(otherPoints[1], otherPoints[0]));\n\n          if (isValid(center) && isValid(radius)) {\n            const equation = calculateCircleEquationByCenterPoint(center, radius);\n            return {\n              center,\n              radius,\n              equation\n            };\n          }\n        }\n      }\n    }\n  }\n}\n\nexport function calculateTangentEquation(circle: EquationType, point?: CoordinateType = null): EquationType {\n  if (circle) {\n    const tangentPoint: CoordinateType = point || getRandomPointInEquation(circle);\n\n    const tangentEquation: EquationType = {};\n\n    const center = {\n      x: Divide(circle.c, 2),\n      y: Divide(circle.d, 2)\n    };\n\n    tangentEquation.a = 0;\n    tangentEquation.b = 0;\n    tangentEquation.c = Add(tangentPoint.x, center.x);\n    tangentEquation.d = Add(tangentPoint.y, center.y);\n    //circle.e + (circle.c * tangentPoint.x) / 2 + (circle.d * tangentPoint.y) / 2\n    tangentEquation.e = Add(circle.e, Add(Multiply(tangentPoint.x, center.x), Multiply(tangentPoint.y, center.y)));\n\n    return tangentEquation;\n  }\n}\n\nexport function calculateTangentIntersectPointsByPointOutsideCircle(\n  circle: EquationType,\n  point?: CoordinateType = null,\n  exceptionPoint?: CoordinateType = null\n): EquationType {\n  if (isValid(circle) && isValid(circle.c) && isValid(circle.d)) {\n    const center: CoordinateType = {\n      x: Divide(Sub(0, circle.c), 2),\n      y: Divide(Sub(0, circle.d), 2)\n    };\n\n    const tempCircleCenter = calculateMiddlePoint(center, point);\n    const tempCircleRadius = Divide(calculateDistanceTwoPoints(center, point), 2);\n\n    if (isValid(tempCircleCenter) && isValid(tempCircleRadius)) {\n      const tempCircleEquation = calculateCircleEquationByCenterPoint(tempCircleCenter, tempCircleRadius);\n\n      if (isValid(tempCircleEquation)) {\n        let roots = calculateIntersectionTwoCircleEquations(circle, tempCircleEquation);\n\n        if (exceptionPoint && isValid(roots)) {\n          roots = roots.filter(\n            (root: CoordinateType): boolean => JSON.stringify(root) !== JSON.stringify(exceptionPoint)\n          );\n        }\n\n        return roots;\n      }\n    }\n  }\n}\n\nexport function isTwoEquationEqual(equationOne: EquationType, equationTwo: EquationType): boolean {\n  if (isValid(equationOne) && isValid(equationTwo)) {\n    return isZero(getAngleFromTwoLines(equationOne, equationTwo));\n  }\n}\n\nexport function isIsosceles(p1: CoordinateType, p2: CoordinateType, p3: CoordinateType): boolean {\n  if (isValid(p1) && isValid(p2) && isValid(p3)) {\n    let result = false;\n    if (calculateDistanceTwoPoints(p1, p2) === calculateDistanceTwoPoints(p1, p3)) {\n      result = true;\n    } else if (calculateDistanceTwoPoints(p2, p1) === calculateDistanceTwoPoints(p2, p3)) {\n      result = true;\n    } else if (calculateDistanceTwoPoints(p3, p2) === calculateDistanceTwoPoints(p3, p1)) {\n      result = true;\n    }\n    return result;\n  }\n}\n\nexport function gcd(x, y) {\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return false;\n  }\n  x = Math.abs(x);\n  y = Math.abs(y);\n  while (y) {\n    let t = y;\n    y = x % y;\n    x = t;\n  }\n  return x;\n}\n\nexport function fractionReducing(numerator = 1, denominator = 1) {\n  if (typeof numerator === 'number' && typeof denominator === 'number') {\n    const _gcd = gcd(numerator, denominator);\n    return {\n      numerator: Math.abs(numerator / _gcd),\n      denominator: Math.abs(denominator / _gcd)\n    };\n  }\n  return {};\n}\n\nwindow.math2D = {\n  calculateVector,\n  isVectorSameDirection,\n  isVectorInSameLine,\n  calculateMiddlePoint,\n  calculateSymmetricalPoint,\n  getLineFromTwoPoints,\n  calculateParallelEquation,\n  calculatePerpendicularEquation,\n  calculateDistanceTwoPoints,\n  calculateDistanceFromPointToLine,\n  calculateParallelLineByPointAndLine,\n  calculatePerpendicularLineByPointAndLine,\n  calculateIntersectionByLineAndLine,\n  calculateCircleEquationByCenterPoint,\n  calculateInternalBisectLineEquation,\n  calculateExternalBisectLineEquation,\n  _calculateBisectLineEquation,\n  _getInternalBisectLineEquation,\n  calculateSetOfEquationTypes,\n  calculateIntersectionEquationTypeWithCircleEquation,\n  calculateQuadraticEquation,\n  isIn,\n  calculateSetOfEquationTypeAndQuadraticEquation,\n  calculateIntersectionTwoCircleEquations,\n  calculateLinesByAnotherLineAndAngle,\n  calculateIntegratedDirection,\n  calculateVectorLength,\n  calculateAngleTwoVector,\n  _calculateLinesByAnotherLineAndAngle,\n  makeRoundCoordinate,\n  getAngleFromTwoLines,\n  getMiddlePointFromThreePointsInALine,\n  calculateCircumCircleEquation,\n  calculateInCircleEquation,\n  calculateEscribedCirclesEquation,\n  calculateTangentEquation,\n  calculateTangentIntersectPointsByPointOutsideCircle,\n  isTwoEquationEqual,\n  isIsosceles,\n  gcd,\n  fractionReducing\n};\n","export function isLowerCaseChar(char) {\n  if (char === char.toLowerCase()) return '0';\n  return '1';\n}\n\nexport function isNumber(value) {\n  return !isNaN(value) || typeof value === 'number' || (isObjectLike(value) && getTag(value) === '[object Number]');\n}\n\nexport function isObject(value) {\n  const type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport function isQuadraticEquation(equation): boolean {\n  if (!equation) return false;\n  return equation.a === 1 && equation.b === 1;\n}\n\nexport function isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  const tag = getTag(value);\n  return (\n    tag === '[object Function]' ||\n    tag === '[object AsyncFunction]' ||\n    tag === '[object GeneratorFunction]' ||\n    tag === '[object Proxy]'\n  );\n}\n\n/* ====================================================================\n                          INTERNAL METHODS\n   ==================================================================*/\nfunction isObjectLike(value) {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction getTag(value) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n  return toString.call(value);\n}\n","import { isLowerCaseChar, isNumber } from '../../utils/checker';\n\nexport function checkFormatString(str) {\n  let result = '';\n  str.split('').forEach((element) => {\n    result += isLowerCaseChar(element);\n  });\n  return result;\n}\n\nfunction validateObject(str) {\n  for (let i = 0; i < str.length; i++) {\n    if (isNumber(str[i])) return false;\n    if (i > 0) if (str.slice(0, i - 1).includes(str[i])) return false;\n  }\n  return true;\n}\n\nexport function defineObject(value) {\n  if (isNumber(value) && parseInt(value) == value && parseInt(value) > 0) {\n    return 'value';\n  }\n\n  if (!validateObject(value)) {\n    return undefined;\n  }\n\n  if (value.length === 3) {\n    if (value.includes('(') && value.includes(')')) {\n      return 'circle';\n    }\n    return 'angle';\n  }\n\n  const formatObj = checkFormatString(value);\n  switch (formatObj) {\n    case '0':\n      return 'line';\n    case '1':\n      return 'point';\n    case '10':\n      return 'ray';\n    case '11':\n      return 'segment';\n    default:\n      return undefined;\n  }\n}\n","import { RankingObjectContain, validate } from '../definition/define.js';\nimport { checkFormatString } from '../definition/defineObjType';\n\nexport function validateValue(data, type) {\n  if (data.key !== 'value') {\n    if (!_validateName(data.value)) return false;\n  }\n\n  const validateGeometryType = validate.object[type];\n  let validateType;\n\n  if (data.key === 'triangle') {\n    return validateShape({ triangle: data.value });\n  }\n  if (data.key === 'value' || data.key === 'relation' || data.key === 'undefined' || data.key === 'circle') return true;\n  if (data.key === 'angle') if (!validateAngle(data.value)) return false;\n\n  if (validateGeometryType.includes(data.key) || data.key !== 'object') {\n    const format = checkFormatString(data.value);\n    validateType = validate[data.key];\n    if (validateType && format)\n      if (validateType.format) {\n        if (format === validateType.format && data.value.length === validateType.length) return true;\n      } else if (data.value.length === validateType.length) {\n        return true;\n      }\n  }\n  return false;\n}\n\nfunction validateAngle(value) {\n  const format = checkFormatString(value);\n  return format[1] === '1';\n}\n\nfunction validateShape(shape) {\n  const keys = Object.keys(shape);\n  const validateShapeFormat = validate.shape[keys[0]];\n  const validateShapeType = validate.shapeType[keys[0]] || [''];\n  //check format of shape value\n  const data = shape[keys[0]];\n  const format = checkFormatString(shape[keys[0]]);\n  const shapeFormatCheck = format === validateShapeFormat.format && data.length === validateShapeFormat.length;\n\n  //check type of shape\n  const type = shape.type || '';\n  const shapeTypeCheck = validateShapeType.includes(type);\n\n  return shapeFormatCheck && shapeTypeCheck && _validateName(shape[keys[0]]);\n}\n\nfunction validateDataRelationship(data) {\n  const keys = Object.keys(data);\n\n  for (let indexOfRankingLevel = 0; indexOfRankingLevel < RankingObjectContain.length - 1; indexOfRankingLevel++) {\n    for (\n      let indexOfObjectCurrentLevel = 0;\n      indexOfObjectCurrentLevel < RankingObjectContain[indexOfRankingLevel].length;\n      indexOfObjectCurrentLevel++\n    ) {\n      for (\n        let indexOfObjectNextLevel = 0;\n        indexOfObjectNextLevel < RankingObjectContain[indexOfRankingLevel + 1].length;\n        indexOfObjectNextLevel++\n      )\n        if (keys.includes(RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel])) {\n          if (data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]])\n            return checkObjectRelationship(\n              data[RankingObjectContain[indexOfRankingLevel][indexOfObjectCurrentLevel]][0],\n              data[RankingObjectContain[indexOfRankingLevel + 1][indexOfObjectNextLevel]][0]\n            );\n        }\n    }\n  }\n\n  return true;\n}\n\nfunction checkObjectRelationship(obj1, obj2) {\n  let check = obj2.split('').map((char) => {\n    return obj1.includes(char);\n  });\n  const result = [...new Set(check)];\n\n  if (result.length === 1) {\n    return !result[0];\n  }\n  if (obj2.length === 2) return check.indexOf(true) === -1;\n  if (obj2.length === 3) {\n    return !(check.indexOf(true) === 0 || check.indexOf(true) === 2);\n  }\n}\n\n// check validate name not duplicate Ex: ABB\nfunction _validateName(string) {\n  return (\n    string.split('').length === string.split('').filter((item, index, array) => array.indexOf(item) === index).length\n  );\n}\n\nexport function validateInformation(info) {\n  const type = info.outputType;\n\n  if (type === 'shape') {\n    return validateShape(info);\n  } else {\n    delete info.outputType;\n    let keys = Object.keys(info);\n    if (keys.includes('undefined')) {\n      return false;\n    }\n    for (let i = 0; i < keys.length; i++) {\n      let array = info[keys[i]];\n      let key = keys[i];\n      for (let j = 0; j < array.length; j++) {\n        let value = array[j];\n        const check = validateValue({ key, value }, type);\n        if (!check) {\n          return check;\n        }\n      }\n    }\n  }\n  const keys = Object.keys(info);\n  info.outputType = type;\n\n  if (type === 'define') {\n    if (keys.includes('value')) {\n      return keys.length === 2;\n    } else {\n      return keys.length === 1;\n    }\n  }\n\n  if (type === 'relation') {\n    if (info.triangle) {\n      return info.segment[0].split('').filter((point) => info.triangle[0].includes(point)).length > 0;\n    }\n    return validateDataRelationship(info);\n  }\n\n  return true;\n}\n","import { defineObject } from './defineObjType';\nimport { validateInformation } from '../validation/validation';\nimport { definePointType } from './definePointType';\nimport { defineShapeType } from './defineShapeType';\nimport { reversedDependentObjRelation } from './define';\n\nfunction defineInformation(data) {\n  let result;\n  switch (data.outputType) {\n    case 'shape': {\n      result = defineShapeType(data);\n      break;\n    }\n\n    case 'relation': {\n      result = definePointType(data);\n      break;\n    }\n\n    default: {\n      result = data;\n    }\n  }\n\n  if (reversedDependentObjRelation.includes(result.relation)) {\n    result.object = result.object.reverse();\n  }\n\n  Object.keys(result).forEach((key) => {\n    if (key === 'object') {\n      result[key].forEach((value) => {\n        const type = defineObject(value);\n        if (!result[type]) result[type] = [];\n        if (type === 'segment') {\n          value = sortString(value);\n        }\n        if (type === 'circle') {\n          value = value[1].toUpperCase();\n        }\n\n        if (type === 'angle') {\n          value = [value[0], value[2]].sort().join(value[1]);\n        }\n        result[type].push(value);\n      });\n    }\n    if (key === 'circle') {\n      result[key].forEach((value: string, index: number) => {\n        result[key][index] = result[key][index][1];\n      });\n    }\n  });\n\n  if (data.outputType === 'shape') {\n    const shapeName = Object.keys(result).filter((key) => key !== 'type')[0];\n    if (shapeName !== 'triangle') {\n      result[shapeName] = sortString(result[shapeName]);\n    }\n  }\n\n  delete result.object;\n  const validate = validateInformation(result);\n\n  if (validate) {\n    return result;\n  } else {\n    return { Error: result };\n  }\n}\n\nfunction sortString(str) {\n  const arr = str.split('');\n  const sorted = arr.sort();\n  return sorted.join('');\n}\n\nexport { defineInformation };\n","export function defineShapeType(data) {\n  let result = {};\n\n  Object.keys(data).forEach((key) => {\n    if (key.includes('type')) {\n      const splitter = data[key].toString().split(' ');\n      const shape = splitter[splitter.length - 1];\n      const splitKey = key.split(' ');\n      const shapeName = splitKey.pop();\n      const otherData = data[key]\n        .toString()\n        .replace(shape, '')\n        .trim()\n        .split(' ');\n      result[shapeName] = shape;\n      let point = '';\n      if (otherData[0].length === 3 && otherData[0].includes('(') && otherData[0].includes(')')) {\n        result['point'] = otherData[0][1];\n        point = otherData[0];\n      }\n      result['type'] = otherData\n        .join(' ')\n        .replace(point, '')\n        .trim();\n    } else {\n      result[key] = data[key].toString();\n    }\n  });\n\n  return result;\n}\n","export function definePointType(data) {\n  let result = {};\n\n  Object.keys(data).forEach((key) => {\n    if (key === 'arrayPoints') {\n      result['point'] = data[key].toString().split(',');\n    } else {\n      result[key] = data[key];\n    }\n  });\n\n  return result;\n}\n","import dataViewModel from '../../ViewModel/DataViewModel';\nimport type {\n  CoordinateType,\n  NodeType,\n} from '../../utils/types';\nimport {\n  calculateDistanceTwoPoints,\n  calculateIntersectionByLineAndLine,\n  getLineFromTwoPoints,\n  isIn,\n  isIsosceles,\n} from './Math2D';\nimport { getRandomValue } from './Generation.js';\nimport GConst from '../config/values';\nimport {\n  isFunc,\n  isValid,\n} from '../utils';\n\nconst MIN = GConst.Number.MIN_RANDOM_GENERATION;\nconst MAX = GConst.Number.MAX_RANDOM_GENERATION;\n\nconst geometricObj = {\n  triangle: generateTriangle,\n  quadrilateral: generateQuadrilateral,\n  trapezoid: generateTrapezoid,\n  parallelogram: generateParallelogram,\n  rectangle: generateRectangle,\n  rhombus: generateRhombus,\n  square: generateSquare,\n  circle: generateCircle,\n};\n\nexport function generateGeometry(name: string, shape: string, type?: string) {\n  const generateFunc = geometricObj[shape];\n  if (generateFunc) {\n    generateFunc(name, type);\n  }\n}\n\nfunction updateCoordinate(node: NodeType, point: CoordinateType) {\n  if (\n    isValid(node) &&\n    isValid(point) &&\n    dataViewModel &&\n    isFunc(dataViewModel.updateCoordinate)\n  ) {\n    dataViewModel.updateCoordinate(node, point);\n  }\n}\n\nfunction generateTriangle(name: string, type: string) {\n  if (isValid(name) && name.length === 3) {\n    let p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    let p2: CoordinateType = {};\n    let p3: CoordinateType = {};\n\n    updateCoordinate(name[0], p1);\n    switch (type) {\n      case '': {\n        p3.x = getRandomValue(p1.x - MIN, p1.x + MAX);\n        p3.y = getRandomValue(p1.y - MIN, p1.y + MAX);\n        updateCoordinate(name[1], p3);\n        p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\n        p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\n        while (isIn(p2, getLineFromTwoPoints(p1, p3)) || isIsosceles(p1, p2, p3)) {\n          p2.x = getRandomValue(p1.x - MIN, p1.x + MAX);\n          p2.y = getRandomValue(p1.y - MIN, p1.y + MAX);\n        }\n        updateCoordinate(name[2], p2);\n        break;\n      }\n\n      case 'vuông': {\n        p2.y = getRandomValue(p1.y + MIN, p1.y + MAX);\n        p2.x = p1.x;\n        updateCoordinate(name[2], p2);\n        p3.x = getRandomValue(p1.x + 1, p1.x + 50);\n        p3.y = p1.y;\n        updateCoordinate(name[1], p3);\n        break;\n      }\n\n      case 'cân': {\n        /*\n         *            [A]\n         *          *    *\n         *        *        *\n         *      *            *\n         *    *                *\n         *  B  * * * * * * * *  C\n         */\n        const distance_From_A_To_B = getRandomValue(3, 6);\n\n        p3.y = getRandomValue(p1.y + 5, p1.y + 10);\n        p3.x = p1.x - distance_From_A_To_B;\n        updateCoordinate(name[1], p3);\n        p2.y = p3.y;\n        p2.x = p1.x + distance_From_A_To_B;\n        updateCoordinate(name[2], p2);\n        break;\n      }\n\n      case 'vuông cân': {\n        const distance_From_A_To_B = getRandomValue(5, 10);\n        p3.y = p1.y + distance_From_A_To_B;\n        p3.x = p1.x - distance_From_A_To_B;\n        updateCoordinate(name[1], p3);\n        p2.y = p3.y;\n        p2.x = p1.x + distance_From_A_To_B;\n        updateCoordinate(name[2], p2);\n        break;\n      }\n\n      case 'đều': {\n        /*\n         *       [A]\n         *      *   *\n         *    *       *\n         * [B] * * * * [C]\n         */\n        p2.x = getRandomValue(p1.x + MIN, p1.x + MAX);\n        p2.y = Math.sqrt(3) * p2.x;\n        updateCoordinate(name[2], p2);\n        const distance_From_A_To_B = calculateDistanceTwoPoints(p1, p2);\n        p3.y = p2.y;\n        p3.x = -distance_From_A_To_B + p2.x;\n        updateCoordinate(name[1], p3);\n        break;\n      }\n\n      default: {\n        break;\n      }\n    }\n  }\n}\n\n// Tu giac\nfunction generateQuadrilateral(name: string) {\n  if (isValid(name) && name.length === 4) {\n    // p1 represents point A\n    const p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    updateCoordinate(name[0], p1);\n\n    // p2 represents point B\n    const p2: CoordinateType = {\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\n      y: getRandomValue(p1.y - MAX, p1.y + MAX),\n    };\n    updateCoordinate(name[1], p2);\n\n    // p3 represents point C\n    let p3: CoordinateType = {};\n    // prevent point C is on AB line\n    const linearEquation = getLineFromTwoPoints(p1, p2);\n    if (\n      isValid(linearEquation) &&\n      isValid(linearEquation.c) &&\n      isValid(linearEquation.e)\n    ) {\n      do {\n        p3.x = getRandomValue(p1.x + MIN, p1.x + MAX);\n        p3.y = getRandomValue(p2.y + MIN, p2.y + MAX); // yC is always greater than yB\n      }\n      while (isIn(p3, linearEquation) || Math.abs(p3.y - p2.y) < 5);\n      updateCoordinate(name[2], p3);\n    }\n\n    // p4 represents point D\n    const p4: CoordinateType = {\n      x: undefined,\n      y: undefined,\n    };\n\n    // prevents p1, p2, p4 are straight\n    const lineAB = getLineFromTwoPoints(p1, p2);\n    const lineAC = getLineFromTwoPoints(p1, p3);\n    const lineBC = getLineFromTwoPoints(p2, p3);\n    let lineAD = undefined;\n    let lineCD = undefined;\n    let intersection_AB_CD = [];\n    let intersection_AD_BC = [];\n\n    if (\n      isValid(lineAB) &&\n      isValid(lineAC) &&\n      isValid(lineBC)\n    ) {\n      do {\n        p4.x = getRandomValue(p1.x - MAX, Math.min(p2.x, p3.x));\n        p4.y = getRandomValue(p1.x + MIN, p1.x + MAX);\n        lineAD = getLineFromTwoPoints(p1, p4);\n        lineCD = getLineFromTwoPoints(p3, p4);\n        if (isValid(lineAD) && isValid(lineCD)) {\n          intersection_AB_CD = calculateIntersectionByLineAndLine(lineAB, lineCD);\n          intersection_AD_BC = calculateIntersectionByLineAndLine(lineAD, lineBC);\n        }\n        if(!Array.isArray(intersection_AB_CD)) {\n          intersection_AB_CD = [];\n        }\n        if (!Array.isArray(intersection_AD_BC)) {\n          intersection_AD_BC = [];\n        }\n      }\n      while (\n        isIn(p4, lineAB) ||\n        isIn(p4, lineAC) ||\n        isIn(p4, lineBC) ||\n        intersection_AB_CD.length === 0 ||\n        intersection_AD_BC.length === 0\n        );\n      updateCoordinate(name[3], p4);\n    }\n  }\n}\n\n// Hinh thang\nfunction generateTrapezoid(name: string, type: string) {\n  if (isValid(name) && name.length === 4) {\n    // p1 represents point A\n    const p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    updateCoordinate(name[0], p1);\n\n    switch (type) {\n      case '': {\n        // p2 represents point B\n        const p2: CoordinateType = {\n          x: getRandomValue(p1.x + Math.floor(MAX / 2), p1.x + MAX),\n          y: p1.y,\n        };\n        updateCoordinate(name[1], p2);\n\n        // p3 represents point C\n        const p3: CoordinateType = {\n          x: (getRandomValue(p2.x + Math.floor(MAX / 2), p2.x + MAX)),\n          y: getRandomValue(p2.y + Math.floor(MAX / 2), p1.y + MAX),\n        };\n        updateCoordinate(name[2], p3);\n\n        // p4 represents point D\n        const p4: CoordinateType = {\n          x: getRandomValue(p1.x - Math.floor(MAX / 2), p1.x - MAX),\n          y: p3.y,\n        };\n        updateCoordinate(name[3], p4);\n        break;\n      }\n\n      case 'cân': {\n        // p2 represents point B\n        const p2: CoordinateType = {\n          x: getRandomValue(p1.x + MIN, p1.x + MAX),\n          y: p1.y,\n        };\n        updateCoordinate(name[1], p2);\n\n        // p3 represents point C\n        const p3: CoordinateType = {\n          x: getRandomValue(p2.x + MIN, p2.x + MAX),\n          y: getRandomValue(p1.y + MIN, p1.y + MAX),\n        };\n        updateCoordinate(name[2], p3);\n\n        const distanceX = Math.abs(p3.x - p2.x);\n        const p4X = getRandomValue(0, 2) === 1 ?\n          p1.x + distanceX :\n          p1.x - distanceX;\n        // p4 represents point D\n        const p4: CoordinateType = {\n          x: p1.x - distanceX,\n          y: p3.y,\n        };\n        updateCoordinate(name[3], p4);\n        break;\n      }\n\n      case 'vuông': {\n        // TODO: vuong tai dau?\n        break;\n      }\n\n      default: {\n        break;\n      }\n    }\n  }\n}\n\n// hinh binh hanh\nfunction generateParallelogram(name: string) {\n  if (isValid(name) && name.length === 4) {\n    // p1 represents point A\n    const p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    updateCoordinate(name[0], p1);\n\n    // p2 represents point B\n    let p2: CoordinateType = {\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\n      y: p1.y,\n    };\n    updateCoordinate(name[1], p2);\n\n    // p3 represents point C\n    let p3: CoordinateType = {\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\n      y: getRandomValue(p1.x + MIN, p1.x + MAX),\n    };\n    updateCoordinate(name[2], p3);\n\n    // p4 represents point D\n    let p4: CoordinateType = {\n      x: p3.x - p2.x - p1.x,\n      y: p3.y,\n    };\n    updateCoordinate(name[3], p4);\n  }\n}\n\nfunction generateRectangle(name: string) {\n  if (name.length === 4) {\n    // p1 represents point A\n    const p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    updateCoordinate(name[0], p1);\n\n    // p2 represents point B\n    const p2: CoordinateType = {\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\n      y: p1.y,\n    };\n    updateCoordinate(name[1], p2);\n\n    // p3 represents point C\n    const p3: CoordinateType = {\n      x: p2.x,\n      y: getRandomValue(p2.y + MIN, p2.y + MAX),\n    };\n    updateCoordinate(name[2], p3);\n\n    // p4 represents point D\n    const p4: CoordinateType = {\n      x: p1.x,\n      y: p3.y,\n    };\n    updateCoordinate(name[3], p4);\n  }\n}\n\n// Hinh thoi\nfunction generateRhombus(name: string) {\n  if (isValid(name) && name.length === 4) {\n    // p1 represents point A\n    const p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    updateCoordinate(name[0], p1);\n\n    // p2 represents point B\n    const p2: CoordinateType = {\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\n      y: -getRandomValue(p1.y + MIN, p1.y + MAX),\n    };\n    updateCoordinate(name[1], p2);\n\n    // p3 represents point C\n    const p3: CoordinateType = {\n      x: 2 * Math.abs(p2.x - p1.x),\n      y: p1.y,\n    };\n    updateCoordinate(name[2], p3);\n\n    // p4 represents point D\n    const p4: CoordinateType = {\n      x: p2.x,\n      y: Math.abs(-p2.y - p1.y),\n    };\n    updateCoordinate(name[3], p4);\n  }\n}\n\nfunction generateSquare(name: string) {\n  if (isValid(name) && name.length === 4) {\n    // p1 represents point A\n    const p1: CoordinateType = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    updateCoordinate(name[0], p1);\n\n    // p2 represents point B\n    const p2: CoordinateType = {\n      x: getRandomValue(p1.x + MIN, p1.x + MAX),\n      y: p1.y,\n    };\n    updateCoordinate(name[1], p2);\n\n    // p3 represents point C\n    const p3: CoordinateType = {\n      x: p2.x,\n      y: p2.y + calculateDistanceTwoPoints(p1, p2),\n    };\n    updateCoordinate(name[2], p3);\n\n    // p4 represents point D\n    const p4: CoordinateType = {\n      x: p1.x,\n      y: p3.y,\n    };\n    updateCoordinate(name[3], p4);\n  }\n}\n\nfunction generateCircle(name: string) {\n}\n","import type { CoordinateType, EquationType, NodeRelationType, NodeType } from '../../utils/types';\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\nimport {\n  calculateCircleEquationByCenterPoint,\n  calculateCircumCircleEquation,\n  calculateDistanceTwoPoints,\n  calculateEscribedCirclesEquation,\n  calculateInCircleEquation,\n  calculateIntersectionByLineAndLine,\n  calculateIntersectionTwoCircleEquations,\n  calculateMiddlePoint,\n  calculateParallelLineByPointAndLine,\n  calculatePerpendicularLineByPointAndLine,\n  calculateSymmetricalPoint,\n  getLineFromTwoPoints\n} from '../math/Math2D';\nimport { getRandomPointInEquation, getRandomValue } from '../math/Generation';\nimport { circleType, mappingShapeType, shapeRules, TwoStaticPointRequireShape } from '../definition/define';\nimport { generateGeometry } from '../math/GenerateGeometry';\nimport { readRelation } from './ReadRelation';\nimport ErrorService from '../error/ErrorHandleService';\nimport { isQuadraticEquation } from '../../utils/checker.js';\nimport { Operation } from '../math/MathOperation.js';\n\nlet shape, shapeName, shapeType;\n\nexport function readPointsMap(): Array | {} {\n  dataViewModel.createPointDetails();\n  console.table(JSON.parse(JSON.stringify(dataViewModel.getData.getPointsMap)));\n  let isChangeShape = false;\n  while (!dataViewModel.isPointsMapStatic()) {\n    //get node to calculate\n    const executingNode = dataViewModel.getNextExecuteNode();\n    if (!executingNode) break;\n    executeRelations(executingNode);\n\n    //Update calculated value to pointsMap\n    if (dataViewModel.getData.getPointDetails.has(executingNode.id)) {\n      const roots = dataViewModel.getData.getPointDetails.get(executingNode.id).roots;\n\n      if (typeof roots === 'string') {\n        ErrorService.showError('400');\n        return;\n      }\n      if (roots.length > 0) {\n        let coordinate;\n        if (dataViewModel.isNeedRandomCoordinate(executingNode.id)) {\n          coordinate = roots[getRandomValue(0, roots.length - 1)];\n        } else {\n          const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[executingNode.id];\n          if (nodeDirectionInfo) {\n            const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\n            if (roots.length > 1) {\n              const rootsDirection = roots.map((root) => ({\n                coordinate: root,\n                isRight: Operation.Compare(staticPointCoordinate.x, root.x),\n                isUp: Operation.Compare(staticPointCoordinate.y, root.y)\n              }));\n\n              let coordinatesMatch = rootsDirection\n                .map((directionInfo) => {\n                  let matchCount = 0;\n                  if (directionInfo.isRight === nodeDirectionInfo.isRight) {\n                    matchCount++;\n                  }\n                  if (directionInfo.isUp === nodeDirectionInfo.isUp) {\n                    matchCount++;\n                  }\n                  return {\n                    coordinate: directionInfo.coordinate,\n                    matchCount\n                  };\n                })\n                .sort((a, b) => b.matchCount - a.matchCount);\n              coordinatesMatch = coordinatesMatch.filter(\n                (coordinate) => coordinate.matchCount === coordinatesMatch[0].matchCount\n              );\n              if (coordinatesMatch.length > 1) {\n                const result = coordinatesMatch.filter((coordinate) =>\n                  dataViewModel.checkInsideRule(executingNode.id, coordinate)\n                );\n                coordinate = result[0].coordinate;\n              } else {\n                coordinate = coordinatesMatch[0].coordinate;\n              }\n            } else {\n              coordinate = roots[0];\n            }\n          } else {\n            coordinate = roots[0];\n          }\n        }\n        if (coordinate) {\n          dataViewModel.updateCoordinate(executingNode.id, coordinate);\n        }\n      }\n    }\n\n    //update static Node\n    dataViewModel.updateStaticNode();\n\n    if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\n      makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], executingNode.id);\n      isChangeShape = true;\n    }\n  }\n  // if (isChangeShape) {\n  dataViewModel.getData.getPointsMap.forEach((node: NodeType) => {\n    //Update calculated value to pointsMap\n    if (dataViewModel.getData.getPointDetails.has(node.id)) {\n      const setOfEquation = dataViewModel.getData.getPointDetails.get(node.id).setOfEquation;\n      //random in case have 1 cicrleEquation\n      if (setOfEquation.length === 1 && isQuadraticEquation(setOfEquation[0])) {\n        dataViewModel.updateCoordinate(node.id, getRandomPointInEquation(setOfEquation[0]));\n        return;\n      }\n    }\n  });\n  //       const roots = dataViewModel.getData.getPointDetails.get(node.id).roots;\n  //       if (typeof roots === 'string') {\n  //         ErrorService.showError('400');\n  //         return;\n  //       }\n\n  //       if (roots.length >= 0) {\n  //         let coordinate;\n  //         if (roots.length === 0) {\n  //           if (setOfEquation.length >= 2) {\n  //             const _roots = calculateIntersectionTwoCircleEquations(setOfEquation[0], setOfEquation[1]);\n  //             coordinate = _roots[getRandomValue(0, _roots.length)];\n  //           }\n  //         } else if (dataViewModel.isNeedRandomCoordinate(node.id)) {\n  //           coordinate = roots[getRandomValue(0, roots.length - 1)];\n  //         } else {\n  //           const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[node.id];\n  //           if (nodeDirectionInfo) {\n  //             const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\n  //             if (roots.length > 1) {\n  //               const rootsDirection = roots.map((root) => {\n  //                 return {\n  //                   coordinate: root,\n  //                   isRight: Operation.Compare(staticPointCoordinate.x, root.x),\n  //                   isUp: Operation.Compare(staticPointCoordinate.y, root.y)\n  //                 };\n  //               });\n  //               const coordinateMatch = rootsDirection\n  //                 .map((directionInfo) => {\n  //                   let matchCount = 0;\n  //                   if (directionInfo.isRight === nodeDirectionInfo.isRight) {\n  //                     matchCount++;\n  //                   }\n  //                   if (directionInfo.isUp === nodeDirectionInfo.isUp) {\n  //                     matchCount++;\n  //                   }\n  //                   return {\n  //                     coordinate: directionInfo.coordinate,\n  //                     matchCount\n  //                   };\n  //                 })\n  //                 .sort((a, b) => b.matchCount - a.matchCount);\n  //               coordinate = coordinateMatch[0].coordinate;\n  //             } else {\n  //               coordinate = roots[0];\n  //             }\n  //           } else {\n  //             const filterRoots = roots.filter(\n  //               (root) =>\n  //                 (Operation.isEqual(dataViewModel.getNodeInPointsMapById(node.id).coordinate.x, root.x) &&\n  //                   Operation.isEqual(dataViewModel.getNodeInPointsMapById(node.id).coordinate.y, root.y) &&\n  //                   !dataViewModel.isCoordinateExist(node.id, root)) ||\n  //                 !dataViewModel.isCoordinateExist(node.id, root)\n  //             );\n  //             coordinate = filterRoots[getRandomValue(0, filterRoots.length - 1)];\n  //           }\n  //         }\n  //         if (coordinate) {\n  //           dataViewModel.updateCoordinate(node.id, coordinate);\n  //         }\n  //       }\n  //     }\n  //   });\n  // }\n\n  return dataViewModel.getData.getPointsMap.map((node) => ({\n    id: node.id,\n    coordinate: node.coordinate\n  }));\n}\n\nfunction executeRelations(node: NodeType) {\n  const executingNodeRelations = _makeUniqueNodeRelation(node.dependentNodes);\n\n  executingNodeRelations.forEach((relation) => {\n    let relationEquation;\n    if (relation.outputType === 'shape') {\n      shapeName = Object.keys(relation).filter((key) => key !== 'type')[0];\n      shapeType = mappingShapeType[relation.type] || 'normal';\n      shape = relation[shapeName];\n      if (circleType.includes(shapeType)) {\n        let data = null;\n        switch (shapeType) {\n          case 'nội tiếp':\n            data = calculateInCircleEquation(\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\n            );\n            break;\n          case 'ngoại tiếp':\n            data = calculateCircumCircleEquation(\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\n            );\n            break;\n          case 'bàng tiếp':\n            data = calculateEscribedCirclesEquation(\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\n              dataViewModel.getNodeInPointsMapById(relation.escribedPoint[0]).coordinate\n            );\n            break;\n          default:\n            break;\n        }\n        if (data) {\n          dataViewModel.circlesData[relation.point[0]] = data;\n          dataViewModel.updateCoordinate(relation.point[0], data.center);\n        } else {\n          ErrorService.showError('400');\n        }\n      } else if (!dataViewModel.isExecutedRelation(relation)) {\n        generateGeometry(relation[shapeName], shapeName, relation.type);\n        setPointsDirection(relation[shapeName]);\n      }\n      if (shapeRules[shapeName] && shapeRules[shapeName][shapeType]) {\n        makeCorrectShape(shape, shapeName, shapeRules[shapeName][shapeType], node.id);\n      }\n    }\n\n    if (!dataViewModel.isExecutedRelation(relation)) {\n      relationEquation = readRelation(relation, node.id);\n      if (relationEquation) {\n        if (Array.isArray(relationEquation)) {\n          relationEquation = relationEquation[getRandomValue(0, relationEquation.length)];\n        }\n\n        dataViewModel.executePointDetails(node.id, relationEquation);\n      }\n      dataViewModel.getData.getExecutedRelations.push(relation);\n    }\n  });\n  if (dataViewModel.isReCalculated) {\n    dataViewModel.isReCalculated = false;\n    return;\n  }\n  dataViewModel.getData.getExecutedNode.push(node.id);\n}\n\nfunction setPointsDirection(shape: string) {\n  if (shape.length < 4) {\n    return;\n  }\n  let i = 0;\n  shape.split('').forEach((point, index) => {\n    if (index > 0) {\n      // Case point D => set anchor point is A\n      i = index === shape.length - 1 ? 1 : index;\n      const pointCoordinate = dataViewModel.getNodeInPointsMapById(point).coordinate;\n      const rootCoordinate = dataViewModel.getNodeInPointsMapById(shape[i - 1]).coordinate;\n\n      dataViewModel.getData.getPointDirectionMap[point] = {\n        root: shape[i - 1],\n        isRight: Operation.Compare(rootCoordinate.x, pointCoordinate.x),\n        isUp: Operation.Compare(rootCoordinate.y, pointCoordinate.y)\n      };\n    }\n  });\n}\n\nexport function _makeUniqueNodeRelation(dependentNodes: Array<NodeRelationType>): Array<any> {\n  let result: Array<NodeRelationType> = [];\n\n  for (let index = 0; index < dependentNodes.length; index++) {\n    let temp = true;\n\n    for (let i = 0; i < result.length; i++) {\n      if (dependentNodes[index].relation === result[i]) {\n        temp = false;\n        break;\n      }\n    }\n\n    if (temp) result.push(dependentNodes[index].relation);\n  }\n  return result;\n}\n\nfunction makeCorrectShape(shape: string, shapeName: string, rules: string, executePoint: string) {\n  const staticPointCountRequire = TwoStaticPointRequireShape.includes(shapeName) ? 2 : 1;\n  let staticPoints = shape.replace(executePoint, '').split('');\n  // check other points are static\n  let count = 0;\n  for (let i = 0; i < staticPoints.length; i++) {\n    if (dataViewModel.isStaticNodeById(staticPoints[i])) {\n      count++;\n    }\n  }\n\n  if (count < staticPointCountRequire) {\n    return;\n  }\n\n  // get node information\n  let arrayRules = rules.split(new RegExp('&', 'g'));\n\n  const executePointIndex = shape.indexOf(executePoint);\n  let nodeSetEquations = [];\n  if (arrayRules.length > 0) {\n    arrayRules.forEach((rule) => {\n      const relationType = rule[2];\n      if (rule.includes(executePointIndex)) {\n        let equation;\n        // eslint-disable-next-line default-case\n        switch (relationType) {\n          case '|':\n            equation = getLinearEquationByParallelRule(rule, shape, executePointIndex);\n            break;\n          case '^':\n            if (rule[1] === rule[3]) {\n              equation = getLinearEquationByPerpendicularRule(rule, shape, executePointIndex);\n            } else {\n              equation = updateCoordinateBySpecialPerpendicularRule(rule, shape, executePointIndex);\n            }\n            break;\n          case '=':\n            equation = getLinearEquationsByEqualRule(rule, shape, executePointIndex);\n            break;\n        }\n        if (equation) {\n          nodeSetEquations = nodeSetEquations.concat(equation);\n        }\n      }\n    });\n    nodeSetEquations.forEach((equation) => {\n      dataViewModel.executePointDetails(executePoint, equation);\n    });\n  }\n}\n\nfunction updateCoordinateBySpecialPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\n  let includeLine, nonIncludeLine;\n\n  const staticLines = rule\n    .split('^')\n    .filter(\n      (line: string): boolean =>\n        dataViewModel.isStaticNodeById(shape[line[0]]) && dataViewModel.isStaticNodeById(shape[line[1]])\n    );\n\n  rule.split('^').forEach((line: string) => {\n    if (line.includes(executePointIndex)) {\n      includeLine = line;\n    } else {\n      nonIncludeLine = line;\n    }\n  });\n\n  const shapePoints = shape\n    .split('')\n    .map((point: string): CoordinateType => dataViewModel.getNodeInPointsMapById(point).coordinate);\n\n  if (staticLines.length === 1) {\n    const intersectPoint = calculateMiddlePoint(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]]);\n    const nonStaticLine = staticLines[0] === nonIncludeLine ? includeLine : nonIncludeLine;\n\n    const staticPointIndex = nonStaticLine.split('').filter((pointIndex: string): boolean => {\n      return dataViewModel.isStaticNodeById(shape[pointIndex]);\n    })[0];\n\n    if (staticPointIndex === undefined) {\n      const equation = calculatePerpendicularLineByPointAndLine(\n        intersectPoint,\n        getLineFromTwoPoints(shapePoints[staticLines[0][0]], shapePoints[staticLines[0][1]])\n      );\n      const coordinate = calculateIntersectionByLineAndLine(\n        equation,\n        getLineFromTwoPoints(shapePoints[staticLines[0][0]], shapePoints[nonStaticLine[0]])\n      );\n\n      dataViewModel.updateCoordinate(shape[nonStaticLine[0]], coordinate);\n      return equation;\n    } else if (shape[nonStaticLine.replace(staticPointIndex, '')]) {\n      const calculatedCoordinate = calculateSymmetricalPoint(shapePoints[staticPointIndex], intersectPoint);\n      dataViewModel.updateCoordinate(shape[nonStaticLine.replace(staticPointIndex, '')], calculatedCoordinate);\n      const equation = calculatePerpendicularLineByPointAndLine(\n        shapePoints[staticPointIndex],\n        getLineFromTwoPoints(intersectPoint, shapePoints[staticPointIndex])\n      );\n      return equation;\n    }\n  } else if (staticLines.length === 0 && nonIncludeLine) {\n    //line perpendicular with line include 1 static point\n    const intersectPoint = calculateIntersectionByLineAndLine(\n      calculatePerpendicularLineByPointAndLine(\n        shapePoints[executePointIndex],\n        getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\n      ),\n      getLineFromTwoPoints(shapePoints[nonIncludeLine[0]], shapePoints[nonIncludeLine[1]])\n    );\n    let calculatedCoordinate;\n    //update coordinate\n    const otherPointInIncludeLine = includeLine.replace(executePointIndex, '');\n    if (!dataViewModel.isStaticNodeById(shape[otherPointInIncludeLine])) {\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[executePointIndex], intersectPoint);\n      dataViewModel.updateCoordinate(shape[otherPointInIncludeLine], calculatedCoordinate);\n    } else {\n      calculatedCoordinate = calculateSymmetricalPoint(shapePoints[otherPointInIncludeLine], intersectPoint);\n      dataViewModel.updateCoordinate(shape[executePointIndex], calculatedCoordinate);\n    }\n    const nonStaticPointIndex = nonIncludeLine.split('').filter((pointIndex: string): boolean => {\n      return !dataViewModel.isStaticNodeById(shape[pointIndex]);\n    })[0];\n\n    calculatedCoordinate = calculateSymmetricalPoint(\n      shapePoints[nonIncludeLine.replace(nonStaticPointIndex, '')],\n      intersectPoint\n    );\n\n    dataViewModel.updateCoordinate(shape[nonStaticPointIndex], calculatedCoordinate);\n  }\n}\n\nfunction getLinearEquationsByEqualRule(rule: string, shape: string, executePointIndex: number): Array<EquationType> {\n  const lines = rule.split('=');\n  let staticLine;\n  let nonStaticLine;\n  // points with non-static point;\n  lines.forEach((line) => {\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\n      .length;\n    if (count === 2 && !staticLine) {\n      staticLine = line;\n    } else {\n      nonStaticLine = line;\n    }\n  });\n  if (staticLine) {\n    const count = staticLine.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\n      .length;\n\n    if (count < 2) {\n      return [];\n    }\n\n    const otherPoint = shape[nonStaticLine.replace(executePointIndex, '')];\n    const radius = calculateDistanceTwoPoints(\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\n    );\n    //point is outside static line\n    if (!staticLine.includes(executePointIndex)) {\n      return [\n        calculateCircleEquationByCenterPoint(dataViewModel.getNodeInPointsMapById(otherPoint).coordinate, radius)\n      ];\n    }\n  }\n}\n\nfunction getLinearEquationByParallelRule(rule: string, shape: string, executePointIndex: number): EquationType {\n  const lines = rule.split('|');\n  let staticLine;\n  let nonStaticLine;\n  // points with non-static point;\n  lines.forEach((line) => {\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\n      .length;\n    if (count === 2 && !staticLine) {\n      staticLine = line;\n    } else {\n      nonStaticLine = line;\n    }\n  });\n  if (\n    staticLine &&\n    nonStaticLine.includes(executePointIndex) &&\n    dataViewModel.isStaticNodeById(shape[nonStaticLine.replace(executePointIndex, '')])\n  ) {\n    const point = dataViewModel.getNodeInPointsMapById(shape[nonStaticLine.replace(executePointIndex, '')]).coordinate;\n    const line = getLineFromTwoPoints(\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\n      dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\n    );\n    const pLine = calculateParallelLineByPointAndLine(point, line);\n    return [pLine];\n  }\n}\n\nfunction getLinearEquationByPerpendicularRule(rule: string, shape: string, executePointIndex: number) {\n  const lines = rule.split('^');\n  let staticLine;\n  let nonStaticLine;\n  // points with non-static point;\n  lines.forEach((line) => {\n    const count = line.split('').filter((point: string): boolean => dataViewModel.isStaticNodeById(shape[point]))\n      .length;\n    if (count === 2 && !staticLine) {\n      staticLine = line;\n    } else {\n      nonStaticLine = line;\n    }\n  });\n\n  if (staticLine && nonStaticLine.includes(executePointIndex) && !staticLine.includes(executePointIndex)) {\n    return [\n      calculatePerpendicularLineByPointAndLine(\n        //Common point\n        dataViewModel.getNodeInPointsMapById(shape[rule[1]]).coordinate,\n        //line\n        getLineFromTwoPoints(\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[0]]).coordinate,\n          dataViewModel.getNodeInPointsMapById(shape[staticLine[1]]).coordinate\n        )\n      )\n    ];\n  }\n}\n","import type { CoordinateType } from '../../utils/types';\nimport dataViewModel from '../../ViewModel/DataViewModel.js';\nimport {\n  calculateCircleEquationByCenterPoint,\n  calculateDistanceTwoPoints,\n  calculateInternalBisectLineEquation,\n  calculateIntersectionByLineAndLine,\n  calculateIntersectionEquationTypeWithCircleEquation,\n  calculateLinesByAnotherLineAndAngle,\n  calculateMiddlePoint,\n  calculateParallelLineByPointAndLine,\n  calculatePerpendicularLineByPointAndLine,\n  calculateSymmetricalPoint,\n  calculateAngleTwoVector,\n  getLineFromTwoPoints,\n  getMiddlePointFromThreePointsInALine,\n  isIn,\n  calculateIntersectionTwoCircleEquations,\n  isVectorInSameLine,\n  isVectorSameDirection,\n  calculateExternalBisectLineEquation,\n  calculateVector,\n  calculateTangentEquation,\n  calculateTangentIntersectPointsByPointOutsideCircle,\n  makeRoundCoordinate\n} from '../math/Math2D';\nimport {\n  generatePointAlignmentInside,\n  generatePointAlignmentOutside,\n  generatePointMiddleTwoPoints,\n  getRandomPointInEquation,\n  getRandomValue\n} from '../math/Generation.js';\nimport ErrorService from '../error/ErrorHandleService';\nimport { ShapeAffectBySegmentChange, TwoStaticPointRequireShape } from '../definition/define';\nimport { Operation } from '../math/MathOperation.js';\nimport { getPointOrderInShape } from './Analysis';\nexport function readRelation(relation: mixed, point: string) {\n  let equationResults;\n\n  dataViewModel.executingRelation = relation;\n  if (relation.operation) {\n    equationResults = analyzeOperationType(relation, point);\n  } else if (relation.relation) {\n    const relationType = relation.relation;\n    switch (relationType) {\n      case 'trung điểm':\n      case 'thuộc':\n      case 'không thuộc':\n      case 'song song':\n      case 'vuông góc':\n      case 'phân giác':\n      case 'phân giác ngoài':\n      case 'phân giác trong':\n      case 'thẳng hàng':\n      case 'đường cao':\n      case 'trung tuyến':\n        equationResults = analyzeRelationType(relation, point);\n        break;\n      case 'cắt':\n        equationResults = analyzeIntersectRelation(relation, point);\n        break;\n      case 'tiếp tuyến':\n        equationResults = analyzeTangentRelation(relation, point);\n        break;\n      case 'đường kính':\n        equationResults = getCircleEquationByRelation(relation, point);\n        break;\n      default:\n        equationResults = null;\n    }\n  } else if (relation.outputType === 'shape') {\n    const shapeType = Object.keys(relation).filter((key) => key !== 'type')[0];\n    switch (shapeType) {\n      case 'triangle':\n        const staticPoint = getPointOrderInShape(relation[shapeType])[0];\n\n        equationResults = getLineFromTwoPoints(\n          dataViewModel.getNodeInPointsMapById(staticPoint).coordinate,\n          dataViewModel.getNodeInPointsMapById(point).coordinate\n        );\n        break;\n      case 'quadrilateral':\n      case 'rectangle':\n      case 'square':\n      case 'rhombus':\n      case 'trapezoid':\n      case 'parallelogram':\n        if (shapeType !== 'quadrilateral') {\n          let count = 0;\n          relation[shapeType].split('').forEach((point) => {\n            if (dataViewModel.isStaticNodeById(point)) {\n              count++;\n            }\n          });\n          const limit = TwoStaticPointRequireShape.includes(shapeType) ? 1 : 2;\n          if (count > limit) {\n            return;\n          }\n        }\n        let index = relation[shapeType].indexOf(point);\n        if (index === relation[shapeType].length - 1) {\n          equationResults = getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][0]).coordinate\n          );\n        } else {\n          index = index === 0 ? relation[shapeType].length - 1 : index - 1;\n          equationResults = getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(relation[shapeType][index]).coordinate,\n            dataViewModel.getNodeInPointsMapById(point).coordinate\n          );\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  //TODO\n  if (equationResults) {\n    if (equationResults.coefficientX !== undefined) {\n      // equationResults is linear\n      return {\n        a: 0,\n        b: 0,\n        c: equationResults.coefficientX,\n        d: equationResults.coefficientY,\n        e: equationResults.constantTerm\n      };\n    } else {\n      // equationResults is circle\n      return equationResults;\n    }\n  }\n  return null;\n}\n\nfunction getCircleEquationByRelation(relation: mixed, point: string): LinearEquation {\n  const segment = relation.segment[0];\n  let newPointCount = 0;\n  segment.split('').forEach((point: string) => {\n    if (!dataViewModel.isValidCoordinate(point)) {\n      newPointCount += 1;\n    }\n  });\n  if (newPointCount === 1) {\n    ErrorService.showError('200', relation);\n  } else if (newPointCount === 2) {\n    segment.split('').forEach((point: string, index: number) => {\n      if (!dataViewModel.isValidCoordinate(point)) {\n        let coordinate;\n        do {\n          coordinate = { x: getRandomValue(-10, 10), y: 0 };\n        } while (\n          JSON.stringify(coordinate) !== JSON.stringify(dataViewModel.getNodeInPointsMapById(segment[0]).coordinate)\n        );\n        dataViewModel.updateCoordinate(point, coordinate);\n      }\n    });\n  }\n\n  const p1 = dataViewModel.getNodeInPointsMapById(segment[0]).coordinate;\n  const p2 = dataViewModel.getNodeInPointsMapById(segment[1]).coordinate;\n\n  const center = calculateMiddlePoint(p1, p2);\n  dataViewModel.updateCoordinate(relation.circle[0], center);\n\n  dataViewModel.circlesData[relation.circle[0]] = {\n    equation: calculateCircleEquationByCenterPoint(center, calculateDistanceTwoPoints(center, p1)),\n    center,\n    radius: calculateDistanceTwoPoints(center, p1)\n  };\n}\n\nfunction analyzeRelationType(relation: mixed, point: string): LinearEquation {\n  let segmentIncludePoint, segmentNotIncludePoint;\n  if (relation.segment) {\n    relation.segment.forEach((segment: string) => {\n      if (segment.includes(point)) {\n        segmentIncludePoint = segment;\n      } else {\n        segmentNotIncludePoint = segment;\n      }\n    });\n  }\n\n  //points = [...new Set(points)].filter((point: string): boolean => !nonStaticPoints.includes(point));\n  const relationType = relation.relation;\n\n  if (\n    relationType === 'trung điểm' ||\n    relationType === 'thuộc' ||\n    relationType === 'không thuộc' ||\n    relationType === 'thẳng hàng'\n  ) {\n    let calculatedPoint;\n    if (relation.circle) {\n      calculatedPoint = getRandomPointInEquation(dataViewModel.getCircleEquation(relation.circle[0]));\n      dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\n      return dataViewModel.getCircleEquation(relation.circle[0]);\n    }\n    if (segmentIncludePoint) {\n      const otherStaticPoint = relation.point[0];\n      const otherStaticNodeInSegment = dataViewModel.getNodeInPointsMapById(segmentIncludePoint.replace(point, ''));\n\n      if (!otherStaticNodeInSegment.coordinate.x && !otherStaticNodeInSegment.coordinate.y) {\n        return null;\n      }\n\n      if (relationType === 'trung điểm') {\n        calculatedPoint = calculateSymmetricalPoint(\n          otherStaticNodeInSegment.coordinate,\n          dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\n          segmentIncludePoint.indexOf(point) === 1\n        );\n\n        dataViewModel.updateCoordinate(point, calculatedPoint);\n      }\n    } else if (segmentNotIncludePoint) {\n      switch (relationType) {\n        case 'trung điểm':\n          calculatedPoint = calculateMiddlePoint(\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\n          );\n          dataViewModel.updateCoordinate(point, calculatedPoint);\n          return getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\n          );\n        case 'thuộc':\n          calculatedPoint = generatePointAlignmentInside(\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\n          );\n          dataViewModel.getData.getPointDirectionMap[point] = {\n            root: segmentNotIncludePoint[0],\n            isRight: Operation.Compare(\n              dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate.x,\n              calculatedPoint.x\n            ),\n            isUp: Operation.Compare(\n              dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate.x,\n              calculatedPoint.y\n            )\n          };\n          dataViewModel.pushInsideRule(point, segmentNotIncludePoint);\n          dataViewModel.updateCoordinate(point, calculatedPoint);\n          return getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\n          );\n        case 'không thuộc':\n          calculatedPoint = generatePointAlignmentOutside(\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate,\n            getRandomValue(0, 2) === 1\n          );\n\n          dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\n          dataViewModel.updateCoordinate(point, calculatedPoint);\n          dataViewModel.getData.getPointDirectionMap[point] = {\n            root: segmentNotIncludePoint[0],\n            isRight: Operation.Compare(\n              dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate.x,\n              calculatedPoint.x\n            ),\n            isUp: Operation.Compare(\n              dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate.x,\n              calculatedPoint.y\n            )\n          };\n          dataViewModel.pushInsideRule(point, segmentNotIncludePoint);\n          break;\n        default:\n          break;\n      }\n    } else {\n      const points = relation.point;\n      const index = points.indexOf(point);\n      if (index === 1) {\n        calculatedPoint = generatePointAlignmentInside(\n          dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\n          dataViewModel.getNodeInPointsMapById(points[2]).coordinate\n        );\n        dataViewModel.updateCoordinate(point, calculatedPoint);\n      } else {\n        calculatedPoint = generatePointAlignmentOutside(\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 0 : 1]).coordinate,\n          dataViewModel.getNodeInPointsMapById(points[index === 2 ? 1 : 2]).coordinate,\n          index === 2\n        );\n        dataViewModel.updateCoordinate(point, calculatedPoint);\n      }\n\n      return getLineFromTwoPoints(\n        dataViewModel.getNodeInPointsMapById(points[0]).coordinate,\n        dataViewModel.getNodeInPointsMapById(points[1]).coordinate\n      );\n    }\n\n    return getLineFromTwoPoints(\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\n    );\n  } else if (relationType === 'song song' || relationType === 'vuông góc') {\n    if (!segmentNotIncludePoint) {\n      return;\n    }\n    const otherStaticPoint = segmentIncludePoint.replace(point, '');\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint) && !dataViewModel.isValidCoordinate(point)) {\n      const point = generatePointMiddleTwoPoints(\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n        dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\n      );\n      if (point) {\n        dataViewModel.updateCoordinate(otherStaticPoint, point);\n      }\n    }\n    //undefined point\n    for (let i = 0; i < 2; i++) {\n      if (!dataViewModel.isValidCoordinate(segmentNotIncludePoint[i])) {\n        return;\n      }\n    }\n\n    const staticLineEquation = getLineFromTwoPoints(\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[0]).coordinate,\n      dataViewModel.getNodeInPointsMapById(segmentNotIncludePoint[1]).coordinate\n    );\n\n    if (!dataViewModel.isValidCoordinate(otherStaticPoint)) {\n      return;\n    }\n\n    let calculatedLineEquation;\n    if (relationType === 'vuông góc') {\n      calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\n        staticLineEquation\n      );\n\n      const isInStaticLine = isIn(\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\n        staticLineEquation\n      );\n      const calculatedPoint = isInStaticLine\n        ? getRandomPointInEquation(calculatedLineEquation)\n        : calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\n\n      if (!isInStaticLine) {\n        dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[1]}`);\n        dataViewModel.getData.getAdditionSegment.push(`${point}${segmentNotIncludePoint[0]}`);\n      }\n\n      dataViewModel.updateCoordinate(point, calculatedPoint);\n    }\n    if (relationType === 'song song') {\n      calculatedLineEquation = calculateParallelLineByPointAndLine(\n        dataViewModel.getNodeInPointsMapById(otherStaticPoint).coordinate,\n        staticLineEquation\n      );\n\n      const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\n      dataViewModel.updateCoordinate(point, calculatedPoint);\n    }\n    return calculatedLineEquation;\n  } else if (relationType.includes('phân giác')) {\n    const isExternal = relationType === 'phân giác ngoài';\n\n    if (relation.angle) {\n      const angle = relation.angle[0];\n      if (angle.includes(point)) {\n        return;\n      }\n\n      const staticLineEquation = getLineFromTwoPoints(\n        dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\n        dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\n      );\n      let calculatedLineEquation;\n      if (isExternal) {\n        calculatedLineEquation = calculateExternalBisectLineEquation(\n          getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\n          ),\n          getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\n          ),\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\n        );\n\n        const calculatedPoint = getRandomPointInEquation(calculatedLineEquation);\n        dataViewModel.updateCoordinate(point, calculatedPoint);\n      } else {\n        calculatedLineEquation = calculateInternalBisectLineEquation(\n          getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate\n          ),\n          getLineFromTwoPoints(\n            dataViewModel.getNodeInPointsMapById(angle[1]).coordinate,\n            dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\n          ),\n          dataViewModel.getNodeInPointsMapById(angle[0]).coordinate,\n          dataViewModel.getNodeInPointsMapById(angle[2]).coordinate\n        );\n\n        const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquation, staticLineEquation);\n        dataViewModel.updateCoordinate(point, calculatedPoint);\n      }\n\n      return calculatedLineEquation;\n    }\n  } else if (relationType === 'đường cao' || relationType === 'trung tuyến') {\n    const segment = relation.segment[0];\n    const line = relation.triangle[0].replace(segment.replace(point, ''), '');\n    let calculatedPoint;\n    if (relationType === 'trung tuyến') {\n      calculatedPoint = calculateMiddlePoint(\n        dataViewModel.getNodeInPointsMapById(line[1]).coordinate,\n        dataViewModel.getNodeInPointsMapById(line[0]).coordinate\n      );\n    }\n\n    if (relationType === 'đường cao') {\n      const calculatedLineEquation = calculatePerpendicularLineByPointAndLine(\n        dataViewModel.getNodeInPointsMapById(segment.replace(point, '')).coordinate,\n        getLineFromTwoPoints(\n          dataViewModel.getNodeInPointsMapById(line[1]).coordinate,\n          dataViewModel.getNodeInPointsMapById(line[0]).coordinate\n        )\n      );\n\n      calculatedPoint = calculateIntersectionByLineAndLine(\n        calculatedLineEquation,\n        getLineFromTwoPoints(\n          dataViewModel.getNodeInPointsMapById(line[1]).coordinate,\n          dataViewModel.getNodeInPointsMapById(line[0]).coordinate\n        )\n      );\n    }\n\n    dataViewModel.updateCoordinate(point, calculatedPoint);\n  }\n}\n\nfunction analyzeIntersectRelation(relation: mixed, point: string): CoordinateType {\n  for (let index in relation.segment) {\n    for (let i = 0; i < 2; i++) {\n      if (!dataViewModel.isValidCoordinate(relation.segment[index][i])) {\n        return;\n      }\n    }\n  }\n  if (relation.segment && relation.segment.length === 2) {\n    const calculatedLineEquationOne = getLineFromTwoPoints(\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate,\n      dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate\n    );\n    const calculatedLineEquationTwo = getLineFromTwoPoints(\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][0]).coordinate,\n      dataViewModel.getNodeInPointsMapById(relation.segment[1][1]).coordinate\n    );\n\n    relation.segment.forEach((segment: string) => {\n      dataViewModel.getData.getAdditionSegment.push(`${relation.point[0]}${segment[0]}`);\n      dataViewModel.getData.getAdditionSegment.push(`${relation.point[0]}${segment[1]}`);\n    });\n\n    const calculatedPoint = calculateIntersectionByLineAndLine(calculatedLineEquationOne, calculatedLineEquationTwo);\n\n    dataViewModel.updateCoordinate(relation.point[0], calculatedPoint);\n  } else if (relation.circle && relation.circle.length === 2) {\n    const roots = calculateIntersectionTwoCircleEquations(\n      dataViewModel.getCircleEquation(relation.circle[0]),\n      dataViewModel.getCircleEquation(relation.circle[1])\n    );\n\n    roots.forEach((root: CoordinateType, index: number) => {\n      if (relation.point[index]) {\n        dataViewModel.updateCoordinate(relation.point[index], root);\n      }\n    });\n  } else {\n    const pointOne = dataViewModel.getNodeInPointsMapById(relation.segment[0][0]).coordinate;\n    const pointTwo = dataViewModel.getNodeInPointsMapById(relation.segment[0][1]).coordinate;\n    let roots = calculateIntersectionTwoCircleEquations(\n      getLineFromTwoPoints(pointOne, pointTwo),\n      dataViewModel.getCircleEquation(relation.circle[0])\n    );\n    if (typeof roots === 'string') {\n      ErrorService.showError('200');\n    }\n\n    roots = roots.filter((root: CoordinateType): boolean => {\n      return (\n        !(Operation.isEqual(root.x, pointOne.x) && Operation.isEqual(root.y, pointOne.y)) &&\n        !(Operation.isEqual(root.x, pointTwo.x) && Operation.isEqual(root.y, pointTwo.y))\n      );\n    });\n    if (relation.point.length === 2) {\n      roots.forEach((root: CoordinateType, index: number) => {\n        if (!relation.point[index]) {\n          ErrorService.showError('200');\n        } else {\n          dataViewModel.updateCoordinate(relation.point[index], root);\n        }\n      });\n    } else {\n      if (roots.length > 0) {\n        dataViewModel.updateCoordinate(relation.point[0], roots[getRandomValue(0, roots.length - 1)]);\n      }\n    }\n\n    relation.point.forEach((point: string) => {\n      dataViewModel.getData.getAdditionSegment.push(`${relation.segment[0][0]}${point}`);\n    });\n  }\n}\n\n//chỉ xử lý : = , *\nfunction analyzeOperationType(relation: mixed, point: string): any {\n  const objectType = relation.segment ? 'segment' : 'angle';\n  const valueData = {};\n\n  const objectsIncludePoint = [];\n  if (relation.value && relation[objectType].length === 1) {\n    valueData[relation[objectType][0]] = relation.value[0];\n    objectsIncludePoint.push(relation[objectType][0]);\n  } else {\n    for (let index in relation[objectType]) {\n      const object = relation[objectType][index];\n      if (object.includes(point)) {\n        objectsIncludePoint.push(object);\n      }\n\n      valueData[object] =\n        objectType === 'segment'\n          ? calculateDistanceTwoPoints(\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\n            )\n          : (getLineFromTwoPoints(\n              dataViewModel.getNodeInPointsMapById(object[0]).coordinate,\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate\n            ),\n            getLineFromTwoPoints(\n              dataViewModel.getNodeInPointsMapById(object[1]).coordinate,\n              dataViewModel.getNodeInPointsMapById(object[2]).coordinate\n            ));\n    }\n  }\n\n  //điểm cần tính phụ thuộc 1 điểm duy nhất\n  if (objectsIncludePoint.length === 1) {\n    const index = relation[objectType].indexOf(objectsIncludePoint[0]);\n    const staticObject = relation[objectType][index === 0 ? 1 : 0];\n    let staticValue;\n    if (relation[objectType].length > 1) {\n      staticValue = index === 0 ? relation.value * valueData[staticObject] : valueData[staticObject] / relation.value;\n    } else {\n      staticValue = relation.value[0];\n    }\n\n    if (objectType === 'segment') {\n      return calculateCircleEquationByCenterPoint(\n        dataViewModel.getNodeInPointsMapById(objectsIncludePoint[0].replace(point, '')).coordinate,\n        staticValue\n      );\n    }\n    return calculateLineEquationByAngleRelation(objectsIncludePoint[0], staticValue, point);\n  }\n  if (objectsIncludePoint.length === 2) {\n    if (objectType === 'segment') {\n      const staticPointOne = objectsIncludePoint[0].replace(point, '');\n      const staticPointTwo = objectsIncludePoint[1].replace(point, '');\n      //cần check thêm loại shape\n      if (!dataViewModel.isStaticNodeById(staticPointOne) || !dataViewModel.isStaticNodeById(staticPointTwo)) {\n        return;\n      }\n\n      const staticLineEquation = getLineFromTwoPoints(\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\n      );\n\n      const staticDistance = calculateDistanceTwoPoints(\n        dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n        dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\n      );\n\n      const isAlign = isIn(dataViewModel.getNodeInPointsMapById(point).coordinate, {\n        a: 0,\n        b: 0,\n        c: staticLineEquation.coefficientX,\n        d: staticLineEquation.coefficientY,\n        e: staticLineEquation.constantTerm\n      });\n\n      const ratio = +relation.value[0];\n      if (isAlign) {\n        let calculatedPoint;\n        const betweenPoint = getMiddlePointFromThreePointsInALine(\n          dataViewModel.getNodeInPointsMapById(point).coordinate,\n          dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n          dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\n        );\n\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(point).coordinate) {\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\n            staticLineEquation,\n            calculateCircleEquationByCenterPoint(\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n              (ratio * staticDistance) / (ratio + 1)\n            )\n          );\n\n          [...calculatedPoint].forEach((p) => {\n            const result = getMiddlePointFromThreePointsInALine(\n              p,\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\n            );\n            if (result === p) {\n              calculatedPoint = p;\n            }\n          });\n        }\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate && ratio < 1) {\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\n            staticLineEquation,\n            calculateCircleEquationByCenterPoint(\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n              (ratio * staticDistance) / (1 - ratio)\n            )\n          );\n\n          [...calculatedPoint].forEach((p) => {\n            const result = getMiddlePointFromThreePointsInALine(\n              p,\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\n            );\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate) {\n              calculatedPoint = p;\n            }\n          });\n        }\n        if (betweenPoint === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate && ratio > 1) {\n          calculatedPoint = calculateIntersectionEquationTypeWithCircleEquation(\n            staticLineEquation,\n            calculateCircleEquationByCenterPoint(\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n              (ratio * staticDistance) / (ratio - 1)\n            )\n          );\n\n          [...calculatedPoint].forEach((p) => {\n            const result = getMiddlePointFromThreePointsInALine(\n              p,\n              dataViewModel.getNodeInPointsMapById(staticPointOne).coordinate,\n              dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate\n            );\n            if (result === dataViewModel.getNodeInPointsMapById(staticPointTwo).coordinate) {\n              calculatedPoint = p;\n            }\n          });\n        }\n\n        dataViewModel.updateCoordinate(point, calculatedPoint);\n\n        return staticLineEquation;\n      } else {\n      }\n      return null;\n    }\n  }\n}\n\nfunction calculateLineEquationByAngleRelation(\n  angleName: string,\n  angleValue: number,\n  executePoint: string\n): EquationType {\n  const checkResult = checkAndModifiedAngle(angleName);\n  const modifiedAngleName = checkResult.angle;\n  console.log(modifiedAngleName);\n  const staticPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[0]).coordinate;\n  const rootPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[1]).coordinate;\n  const changedPoint = dataViewModel.getNodeInPointsMapById(modifiedAngleName[2]).coordinate;\n  const calculatedEquation = calculateLinesByAnotherLineAndAngle(rootPoint, staticPoint, changedPoint, angleValue);\n\n  const intersectPoint = calculateIntersectionByLineAndLine(\n    calculatedEquation,\n    getLineFromTwoPoints(staticPoint, rootPoint)\n  );\n  const newRootPoint = calculateIntersectionTwoCircleEquations(\n    calculatedEquation,\n    calculateCircleEquationByCenterPoint(changedPoint, calculateDistanceTwoPoints(changedPoint, rootPoint))\n  ).sort((rootOne: CoordinateType, rootTwo: CoordinateType): number => {\n    return Operation.Compare(\n      calculateDistanceTwoPoints(intersectPoint, rootOne),\n      calculateDistanceTwoPoints(intersectPoint, rootTwo)\n    );\n  });\n  //move newRoot to oldRoot\n  const transitionVector = calculateVector(newRootPoint[0], rootPoint, false);\n\n  if (checkResult.isChanged === false) {\n    const calculatedCoordinate = {\n      x: Operation.Add(changedPoint.x, transitionVector.x),\n      y: Operation.Add(changedPoint.y, transitionVector.y)\n    };\n\n    const staticVector = calculateVector(rootPoint, staticPoint, false);\n    const dynamicVector = calculateVector(rootPoint, calculatedCoordinate, false);\n    dataViewModel.updateCoordinate(modifiedAngleName[2], calculatedCoordinate);\n\n    dataViewModel.getData.getPointDirectionMap[modifiedAngleName[2]] = {\n      root: modifiedAngleName[1],\n      isRight: Operation.Compare(rootPoint.x, calculatedCoordinate.x),\n      isUp: Operation.Compare(rootPoint.y, calculatedCoordinate.y)\n    };\n\n    dataViewModel.getData.getPointDirectionMap[modifiedAngleName[0]] = {\n      root: modifiedAngleName[1],\n      isRight: Operation.Compare(rootPoint.x, staticPoint.x),\n      isUp: Operation.Compare(rootPoint.y, staticPoint.y)\n    };\n\n    dataViewModel.replaceSetOfEquation(\n      modifiedAngleName[2],\n      getLineFromTwoPoints(rootPoint, changedPoint),\n      calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\n    );\n\n    // if (angleName === modifiedAngleName) {\n    //   return getLineFromTwoPoints(rootPoint, {\n    //     x: Operation.Add(changedPoint.x, transitionVector.x),\n    //     y: Operation.Add(changedPoint.y, transitionVector.y)\n    //   });\n    // }\n    return;\n  }\n\n  const calculatedCoordinate = {\n    x: Operation.Sub(staticPoint.x, transitionVector.x),\n    y: Operation.Sub(staticPoint.y, transitionVector.y)\n  };\n\n  dataViewModel.updateCoordinate(modifiedAngleName[0], calculatedCoordinate);\n\n  dataViewModel.getData.getPointDirectionMap[modifiedAngleName[0]] = {\n    root: modifiedAngleName[1],\n    isRight: Operation.Compare(rootPoint.x, calculatedCoordinate.x) < 0,\n    isUp: Operation.Compare(rootPoint.y, calculatedCoordinate.y) < 0\n  };\n\n  dataViewModel.getData.getPointDirectionMap[modifiedAngleName[2]] = {\n    root: modifiedAngleName[1],\n    isRight: Operation.Compare(rootPoint.x, changedPoint.x),\n    isUp: Operation.Compare(rootPoint.y, changedPoint.y)\n  };\n\n  dataViewModel.replaceSetOfEquation(\n    modifiedAngleName[1],\n    getLineFromTwoPoints(rootPoint, changedPoint),\n    calculateParallelLineByPointAndLine(rootPoint, calculatedEquation)\n  );\n\n  return getLineFromTwoPoints(rootPoint, executePoint === modifiedAngleName[2] ? changedPoint : staticPoint);\n}\n\nfunction reExecuteNode(array: Array<string>) {\n  dataViewModel.reExecuteNode(array);\n}\n\nfunction getShapeAffectList(): Array<string> {\n  const shapeList = [];\n\n  //get list of shape name\n  dataViewModel.getData.relationsResult.shapes.forEach((shapeData: Object): boolean => {\n    const shapeType = Object.keys(shapeData).filter((key: string): boolean => key !== 'outputType')[0];\n    if (ShapeAffectBySegmentChange.includes(shapeType)) {\n      shapeList.push(shapeData[shapeType]);\n    }\n  });\n\n  return shapeList;\n}\n\nfunction checkAndModifiedAngle(angle: string): { angle: string, isChanged: boolean } {\n  for (let i = 0; i < angle.length; i++) {\n    if (!dataViewModel.isValidCoordinate(angle[i])) {\n      const coordinate = dataViewModel.getNodeInPointsMapById(angle[i]).coordinate;\n      dataViewModel.updateCoordinate(angle[i], {\n        x: coordinate.x || getRandomValue(-10, 10),\n        y: coordinate.y || getRandomValue(-10, 10)\n      });\n      return { angle, isChanged: false };\n    }\n  }\n  const shapeList = getShapeAffectList();\n  const secondLine = `${angle[1]}${angle[2]}`;\n\n  if (shapeList.length === 0) {\n    if (dataViewModel.isStaticNodeById(angle[2])) {\n      if (!dataViewModel.isStaticNodeById(angle[0])) {\n        return {\n          angle: angle\n            .split('')\n            .reverse()\n            .join(''),\n          isChanged: false\n        };\n      }\n    }\n  }\n\n  for (let i = 0; i < shapeList.length; i++) {\n    const shape = shapeList[i];\n    const secondLineVector = calculateVector(\n      dataViewModel.getNodeInPointsMapById(secondLine[0]).coordinate,\n      dataViewModel.getNodeInPointsMapById(secondLine[1]).coordinate\n    );\n\n    let modifiedAngleName = angle;\n\n    if (\n      isVectorInSameLine(\n        calculateVector(\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\n        ),\n        secondLineVector\n      ) ||\n      isVectorInSameLine(\n        calculateVector(\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\n        ),\n        secondLineVector\n      )\n    ) {\n      modifiedAngleName = angle\n        .split('')\n        .reverse()\n        .join('');\n    }\n\n    let isChanged = modifiedAngleName !== angle;\n    let updatePoint = modifiedAngleName[2];\n\n    if (\n      isVectorInSameLine(\n        calculateVector(\n          dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\n          dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\n        ),\n        secondLineVector\n      )\n    ) {\n      if (modifiedAngleName[1] === shape[0]) {\n        if (\n          isVectorSameDirection(\n            calculateVector(\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate\n            ),\n            secondLineVector\n          )\n        ) {\n          updatePoint = shape[2];\n          isChanged = false;\n        }\n      } else if (modifiedAngleName[1] === shape[2]) {\n        if (\n          isVectorSameDirection(\n            calculateVector(\n              dataViewModel.getNodeInPointsMapById(shape[2]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[0]).coordinate\n            ),\n            secondLineVector\n          )\n        ) {\n          updatePoint = shape[0];\n          isChanged = false;\n        }\n      }\n    } else if (\n      isVectorInSameLine(\n        calculateVector(\n          dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\n          dataViewModel.getNodeInPointsMapById(shape[3]).coordinate\n        ),\n        secondLineVector\n      )\n    ) {\n      if (modifiedAngleName[1] === shape[1]) {\n        if (\n          isVectorSameDirection(\n            calculateVector(\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[3]).coordinate\n            ),\n            secondLineVector\n          )\n        ) {\n          updatePoint = shape[3];\n          isChanged = false;\n        }\n      } else if (modifiedAngleName[1] === shape[3]) {\n        if (\n          isVectorSameDirection(\n            calculateVector(\n              dataViewModel.getNodeInPointsMapById(shape[3]).coordinate,\n              dataViewModel.getNodeInPointsMapById(shape[1]).coordinate\n            ),\n            secondLineVector\n          )\n        ) {\n          updatePoint = shape[1];\n          isChanged = false;\n        }\n      }\n    }\n\n    reExecuteNode([modifiedAngleName[1], updatePoint]);\n    const result = modifiedAngleName.replace(modifiedAngleName[2], updatePoint);\n\n    return { angle: result, isChanged };\n  }\n  return { angle, isChanged: false };\n}\n\nfunction analyzeTangentRelation(relation: mixed, point: string): any {\n  const otherPointInSegment = relation.segment[0].replace(point, '');\n  if (!dataViewModel.isStaticNodeById(otherPointInSegment)) {\n    return;\n  }\n\n  const tangentPointCoordinate = dataViewModel.getNodeInPointsMapById(otherPointInSegment).coordinate;\n  const circleEquation = dataViewModel.getCircleEquation(relation.circle[0]);\n  let tangentEquation;\n  if (isIn(tangentPointCoordinate, circleEquation)) {\n    tangentEquation = calculateTangentEquation(circleEquation, tangentPointCoordinate);\n    dataViewModel.updateCoordinate(point, getRandomPointInEquation(tangentEquation));\n    dataViewModel.getData.getAdditionSegment.push(`${otherPointInSegment}${relation.circle[0]}`);\n  } else {\n    const roots = calculateTangentIntersectPointsByPointOutsideCircle(circleEquation, tangentPointCoordinate);\n    const result = filterTangentPoint(roots, circleEquation);\n    tangentEquation = result.tangentEquation;\n    dataViewModel.updateCoordinate(point, result.point);\n    dataViewModel.getData.getAdditionSegment.push(`${point}${relation.circle[0]}`);\n  }\n\n  return tangentEquation;\n}\n\nfunction filterTangentPoint(\n  roots: Array<CoordinateType>,\n  circleEquation: EquationType\n): { equation: EquationType, point: CoordinateType } {\n  const filterRoots = roots.filter((root: CoordinateType): boolean => !dataViewModel.isCoordinateDuplicated(root));\n\n  return filterRoots.map((root: CoordinateType): { equation: EquationType, point: CoordinateType } => {\n    return {\n      equation: calculateTangentEquation(circleEquation, root),\n      point: root\n    };\n  })[getRandomValue(0, filterRoots.length - 1)];\n}\n","// @flow\n\nimport { objectWithPoint } from '../definition/define.js';\nimport type { DrawingDataType, NodeRelationType, NodeType } from '../../utils/types.js';\nimport dataViewModel from '../../ViewModel/DataViewModel';\nimport { readPointsMap } from './ReadPointsMap';\nimport { makeRoundCoordinate } from '../math/Math2D.js';\nimport ErrorService from '../error/ErrorHandleService.js';\nimport { Operation } from '../math/MathOperation.js';\nimport { getRandomValue } from '../math/Generation.js';\n\nlet RelationPointsMap: Array<NodeType> = [];\nlet AdditionRelation: Array<Object> = [];\n\nconst random_angle_default = ['30', '45', '60', '75', '120', '150'];\n\nexport function analyzeResult(validatedResult): DrawingDataType {\n  console.log(JSON.stringify(validatedResult));\n  AdditionRelation = [];\n  validatedResult = deleteWrongRelation(validatedResult);\n  const shapes = validatedResult.shapes;\n  shapes.forEach((shape) => {\n    createPointsMapByShape(shape);\n  });\n\n  const relations = validatedResult.relations;\n  console.log([...AdditionRelation]);\n  console.log([...relations]);\n\n  AdditionRelation.concat(relations).forEach((relation) => {\n    console.log(relation);\n    createPointsMapByRelation(relation).forEach((node) => {\n      updateMap(node, dataViewModel.getData.getPointsMap);\n    });\n  });\n\n  trimPointsMap();\n\n  let result = {};\n\n  readPointsMap();\n  result.points = dataViewModel.getData.getPointsMap.map((node: NodeType) => {\n    return {\n      id: node.id,\n      coordinate: {\n        x: Operation.Round(node.coordinate.x, 3),\n        y: Operation.Round(node.coordinate.y, 3)\n      }\n    };\n  });\n\n  _RoundObject(dataViewModel.circlesData);\n  result.segments = [...getArraySegments(validatedResult), ...dataViewModel.getData.getAdditionSegment];\n  return result;\n}\n\nfunction _RoundObject(object: mixed): mixed {\n  if (typeof object === 'object') {\n    Object.keys(object).forEach((key: string) => {\n      object[key] = _RoundObject(object[key]);\n    });\n    return object;\n  }\n  return Operation.Round(object);\n}\n\nfunction deleteWrongRelation(validatedResult) {\n  const shapes = validatedResult.shapes;\n  let isHaveTriangle = false;\n  let triangle = '';\n  shapes.forEach((shape: mixed) => {\n    if (shape.triangle && !shape.point) {\n      isHaveTriangle = true;\n      triangle = shape.triangle;\n    }\n  });\n\n  if (!isHaveTriangle) {\n    return validatedResult;\n  }\n\n  let segments = [];\n  let angles = [];\n  let relationSegments = [];\n  let relationAngles = [];\n\n  validatedResult.relations.forEach((relation) => {\n    if (relation.outputType === 'define' && !!relation.value) {\n      if (relation.segment) {\n        relation.segment.forEach((segment: string) => {\n          if (!segments.includes(segment) && triangle.includes(segment[0]) && triangle.includes(segment[1])) {\n            segments.push(segment);\n            relationSegments.push(relation);\n          }\n        });\n      }\n\n      if (relation.angle) {\n        relation.angle.forEach((angle: string) => {\n          if (triangle.includes(angle[0]) && triangle.includes(angle[1]) && triangle.includes(angle[2])) {\n            angles.push(angle);\n            relationAngles.push(relation);\n          }\n        });\n      }\n    }\n  });\n\n  let deleteRelationList = [];\n\n  if (angles.length > 1) {\n    if (angles.length > 2) {\n      angles = angles.splice(0, 2);\n      deleteRelationList = deleteRelationList.concat(relationAngles.splice(2, relationAngles.length - 2));\n    }\n    if (segments.length > 0) {\n      const segment = [angles[0][1], angles[1][1]].sort().join('');\n      let position = -1;\n      segments.some((value: string, index: number) => {\n        if (\n          value\n            .split('')\n            .sort()\n            .join('') === segment\n        ) {\n          position = index;\n          return true;\n        }\n        return false;\n      });\n\n      if (position >= 0) {\n        relationSegments.splice(position, 1);\n      } else {\n        const firstRelation = relationSegments[0];\n\n        const _segment = firstRelation.segment[0];\n        const _value = firstRelation.value;\n        let sum = 0;\n        const oppositeAngle = relationAngles\n          .filter((relation) => {\n            sum += parseInt(relation.value);\n            return !_segment.includes(relation.angle[0][1]);\n          })\n          .map((relation) => parseInt(relation.value))[0];\n\n        const calculatedSegmentValue =\n          (_value * Math.sin(((180 - sum) * Math.PI) / 360)) / Math.sin((oppositeAngle * Math.PI) / 360);\n\n        validatedResult.relations.push({\n          operation: '=',\n          outputType: 'define',\n          segment: [segment],\n          value: [`${calculatedSegmentValue}`]\n        });\n      }\n      deleteRelationList = deleteRelationList.concat(relationSegments);\n    }\n  } else {\n    if (segments.length > 1) {\n      if (segments.length === 2) {\n        relationAngles.shift();\n      }\n      deleteRelationList = relationAngles;\n    }\n  }\n\n  const relations = validatedResult.relations.filter((relation: mixed): boolean => {\n    for (let i = 0; i < deleteRelationList.length; i++) {\n      if (JSON.stringify(relation) === JSON.stringify(deleteRelationList[i])) {\n        return false;\n      }\n    }\n    return true;\n  });\n\n  deleteRelationList.forEach((relation: mixed) => {\n    ErrorService.updateErrorInInput(relation);\n  });\n\n  return { shapes, relations };\n}\n\nfunction getArraySegments(validatedResult): Array<string> {\n  let result: Array<string> = [];\n\n  const shapes = validatedResult.shapes;\n\n  shapes.forEach((shape) => {\n    result = result.concat(getShapeSegments(shape));\n  });\n\n  const relations = validatedResult.relations;\n\n  relations.forEach((relation) => {\n    result = result.concat(getRelationSegments(relation));\n  });\n\n  return result.filter((item, index, array) => array.indexOf(item) === index);\n}\n\nfunction getRelationSegments(relation: mixed): Array<string> {\n  let result = [];\n  if (relation.segment) {\n    result = result.concat(relation.segment);\n  }\n  if (relation.angle) {\n    relation.angle.forEach((angle: string) => {\n      result = result.concat([`${angle[0]}${angle[1]}`, `${angle[1]}${angle[2]}`]);\n    });\n  }\n\n  return result;\n}\n\nfunction getShapeSegments(shape: any): Array<string> {\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\n  let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\n\n  const result = [];\n\n  for (let i = 0; i < points.length; i++) {\n    if (i === points.length - 1) {\n      result.push(points[0] + points[i]);\n    } else {\n      result.push(points[i] + points[i + 1]);\n    }\n  }\n\n  return result;\n}\n\nfunction trimPointsMap() {\n  dataViewModel.getData.setPointsMap = dataViewModel.getData.getPointsMap.map((node: NodeType): NodeType => ({\n    ...node,\n    dependentNodes: unique(node.dependentNodes)\n  }));\n}\n\nfunction unique(dependentNodes: Array<NodeRelationType>): Array<NodeRelationType> {\n  let result = [];\n\n  dependentNodes.forEach((node) => {\n    for (let i = 0; i < result.length; i++) {\n      if (JSON.stringify(node) === JSON.stringify(result[i])) return;\n    }\n    result.push(node);\n  });\n\n  return result;\n}\n\nfunction createPointsMapByShape(shape: any) {\n  const shapeName = Object.keys(shape).filter((key) => key !== 'type')[0];\n  //let points = shape[shapeName].split('').filter((point) => point === point.toUpperCase());\n\n  //points = sortPriority([...points]);\n  let points = getPointOrderInShape(shape[shapeName]);\n  let objectPointsMap;\n  // đường tròn ngoại tiếp, nội tiếp\n  if (shape.point) {\n    objectPointsMap = points.map((point: string) => {\n      return createNode(shape.point[0], [{ id: point, relation: shape }]);\n    });\n  } else {\n    objectPointsMap = points.map((point: string, index: number) => {\n      return createNode(point, [{ id: points[0], relation: shape }]);\n    });\n  }\n  objectPointsMap.forEach((node: NodeType) => {\n    updateMap(node, dataViewModel.getData.getPointsMap);\n  });\n}\n\nexport function getPointOrderInShape(shape: string): Array<string> {\n  const angles = [];\n  const segments = [];\n  if (dataViewModel.getData.getRelationsResult.relations) {\n    dataViewModel.getData.getRelationsResult.relations.forEach((relation) => {\n      if (!relation.angle || relation.outputType !== 'define') {\n      } else {\n        angles.push(relation.angle[0]);\n      }\n      if (!relation.segment || relation.outputType !== 'define') {\n      } else {\n        segments.push(relation.segment[0]);\n      }\n    });\n\n    const shapePointCount = {};\n    shape.split('').forEach((point) => {\n      shapePointCount[point] = 0;\n    });\n\n    let segmentCount = 0;\n    segments.forEach((segment: string) => {\n      if (!shape.includes(segment[1]) || !shape.includes(segment[0])) {\n        return;\n      }\n      segmentCount += 1;\n      segment.split('').forEach((point, index) => {\n        //don't check middle point\n        shapePointCount[point] += 1;\n      });\n    });\n\n    let angleCount = 0;\n    angles.forEach((angle: string): void => {\n      if (!shape.includes(angle[1])) {\n        return;\n      }\n      angleCount += 1;\n      angle.split('').forEach((point, index) => {\n        //don't check middle point\n        if (index !== 1) {\n          shapePointCount[point] += 1;\n        } else {\n          shapePointCount[point] += 3;\n        }\n      });\n    });\n    if (angleCount === 0 && segmentCount === 2 && shape.length === 3) {\n      const angle = createAngleByTwoSegments(segments[0], segments[1]);\n      if (AdditionRelation.length === 0) {\n        AdditionRelation.push({\n          angle: [angle],\n          value: [random_angle_default[getRandomValue(0, random_angle_default.length - 1)]],\n          outputType: 'define',\n          operation: '='\n        });\n      }\n    }\n\n    return Object.keys(shapePointCount).sort((a, b) => -shapePointCount[a] + shapePointCount[b]);\n  }\n  return shape.split('');\n}\n\nfunction createAngleByTwoSegments(segOne: string, segTwo: string) {\n  const pointCount = {};\n  segOne\n    .concat(segTwo)\n    .split('')\n    .forEach((point) => {\n      if (pointCount[point]) {\n        pointCount[point] = pointCount[point] + 1;\n      } else {\n        pointCount[point] = 1;\n      }\n    });\n\n  const intersectPoint = Object.keys(pointCount).sort((a, b) => {\n    return a.count - b.count;\n  })[0];\n\n  return `${segOne.replace(intersectPoint, '')}${intersectPoint}${segTwo.replace(intersectPoint, '')}`;\n}\n\nfunction createPointsMapByRelation(relation: any) {\n  RelationPointsMap = [];\n  objectWithPoint.forEach((objectType: string) => {\n    if (relation[objectType]) {\n      relation[objectType].forEach((object) => {\n        let points = object.split('').filter((point) => point === point.toUpperCase());\n\n        const objectPointsMap = points.map((point: string, index: number) => {\n          return createNode(point);\n        });\n\n        objectPointsMap.forEach((node: NodeType) => {\n          updateMap(node, RelationPointsMap);\n        });\n      });\n    }\n  });\n\n  RelationPointsMap = [...RelationPointsMap].sort((nodeOne: NodeType, nodeTwo: NodeType): number => {\n    const index1 = findIndexByNodeId(nodeOne.id, dataViewModel.getData.getPointsMap);\n    const index2 = findIndexByNodeId(nodeTwo.id, dataViewModel.getData.getPointsMap);\n    if (index1 === -1 && index2 === -1) return 1;\n    if (index1 >= 0 && index2 >= 0) return index1 - index2;\n    return index2 - index1;\n  });\n\n  let lastObjectPoints = [];\n\n  if (relation.angle && relation.outputType === 'define' && !!relation.value) {\n    const index1 = findIndexByNodeId(relation.angle[0][0], dataViewModel.getData.getPointsMap);\n    const index2 = findIndexByNodeId(relation.angle[0][2], dataViewModel.getData.getPointsMap);\n    if (index1 < 0) {\n      lastObjectPoints.push(relation.angle[0][0]);\n    }\n    if (index2 < 0) {\n      lastObjectPoints.push(relation.angle[0][2]);\n    }\n    if (index1 >= 0 && index2 >= 0) {\n      lastObjectPoints = [index1 > index2 ? relation.angle[0][0] : relation.angle[0][2]];\n    }\n  } else {\n    lastObjectPoints = getDependentObject();\n  }\n\n  if (lastObjectPoints.length === RelationPointsMap.length) {\n    lastObjectPoints = [lastObjectPoints[0]];\n  }\n\n  if (relation.relation === 'song song' || relation.relation === 'vuông góc' || relation.relation === 'phân giác') {\n    lastObjectPoints = lastObjectPoints.filter(\n      (point: string): boolean => !dataViewModel.getNodeInPointsMapById(point)\n    );\n  }\n  lastObjectPoints.forEach((point) => {\n    const index = findIndexByNodeId(point, RelationPointsMap);\n    const currentNode = RelationPointsMap[index];\n    RelationPointsMap.forEach((node) => {\n      if (node.id !== point) {\n        RelationPointsMap[index] = {\n          ...currentNode,\n          dependentNodes: [\n            ...currentNode.dependentNodes,\n            ...createDependentNodeOfRelation(node.id, relation, lastObjectPoints)\n          ]\n        };\n      }\n    });\n  });\n\n  return RelationPointsMap;\n}\n\nfunction getDependentObject(): Array<string> {\n  let result: Array = [];\n  const lastNode = RelationPointsMap[RelationPointsMap.length - 1];\n  if (lastNode) {\n    result.push(lastNode.id);\n\n    lastNode.dependentNodes.forEach((node) => {\n      const nodeIndex = findIndexByNodeId(node.id, dataViewModel.getData.getPointsMap);\n      if (!result.includes(node.id) && nodeIndex !== -1 && !dataViewModel.getData.getPointsMap[nodeIndex].isStatic)\n        result.push(node.id);\n    });\n  }\n  return result;\n}\n\nfunction findIndexByNodeId(id: string, map: Array<NodeType | NodeRelationType>): number {\n  for (let i = 0; i < map.length; i++) {\n    if (map[i].id === id) return i;\n  }\n  return -1;\n}\n\nfunction createDependentNodeOfRelation(\n  point: string,\n  relation: any,\n  exception: Array<string>\n): Array<NodeRelationType> {\n  const result: Array<NodeRelationType> = [];\n  RelationPointsMap.forEach((node: NodeType) => {\n    if (exception.includes(node.id)) return;\n    result.push({ id: node.id, relation });\n  });\n  return result;\n}\n\nfunction createNode(id: string, dependentNodes?: Array<NodeRelationType>): any {\n  const node = { id, coordinate: { x: undefined, y: undefined, z: 0 }, isStatic: false };\n  const _dependentNodes = dependentNodes ? { dependentNodes } : { dependentNodes: [] };\n\n  return { ...node, ..._dependentNodes };\n}\n\nfunction updateMap(node: NodeType, map: Array<NodeType>) {\n  const index = findIndexByNodeId(node.id, map);\n  if (index !== -1) {\n    //merge dependentNodes\n    const oldNode = map[index];\n    map[index] = {\n      ...oldNode,\n      dependentNodes: [...oldNode.dependentNodes, ...node.dependentNodes]\n    };\n  } else {\n    map.push(node);\n    if (dataViewModel.getData.getPointsMap.length === 1) map[0].isStatic = true;\n  }\n}\n","// @flow\nimport { observable } from 'mobx';\nimport GConst from '../core/config/values';\n\nexport default class RelationInputModel {\n  @observable\n  value: string = '';\n\n  @observable\n  status: string = GConst.InputStatus.NORMAL;\n\n  constructor(value: string) {\n    this.value = value || '';\n  }\n}\n","// @flow\nimport RelationInputModel from '../Model/RelationInputModel';\nimport GConst from '../core/config/values.js';\n\nconst specializeLanguageMap = {\n  'Góc({object})=Góc({object})': '{object} = {object}',\n  '{object}={object}': '{object} = {object}',\n  '{object} song song {object}': '{object} song song {object}',\n  '{object} vuông góc {object}': '{object} vuông góc {object}',\n  '{object} cắt {object} tại {arrayPoints}': '{object} cắt {object} tại {arrayPoints}',\n  '{arrayPoints} là giao điểm của {object} và {object}': '{object} cắt {object} tại {arrayPoints}',\n  '{object} là phân giác ngoài Góc({angle})': '{object} phân giác ngoài {angle}',\n  '{object} là phân giác trong Góc({angle})': '{object} phân giác trong {angle}',\n  '{object} là phân giác của Góc({angle})': '{object} phân giác {angle}',\n  '{arrayPoints} thẳng hàng': '{arrayPoints} thẳng hàng',\n  '{point} là trung điểm của {segment}': '{point} trung điểm {segment}',\n  '{point} không thuộc {object}': '{point} không thuộc {object}',\n  '{point} thuộc {object}': '{point} thuộc {object}',\n  '{segment} là trung tuyến {type triangle}': '{segment} trung tuyến {triangle}',\n  '{segment} là đường cao của tam giác {triangle}': '{segment} đường cao {triangle}',\n  '{circle} đường kính {segment}': '{circle} đường kính {segment}',\n  '{segment} là tiếp tuyến {circle}': '{segment} tiếp tuyến {circle}',\n  'Cho tam giác {type triangle}': 'tam giác {type triangle}',\n  'Cho tứ giác {quadrilateral}': 'tứ giác {quadrilateral}',\n  'Cho hình thang {type trapezoid}': 'hình thang {type trapezoid}',\n  'Cho hình bình hành {parallelogram}': 'hình bình hành {parallelogram}',\n  'Cho hình chữ nhật {rectangle}': 'hình chữ nhật {rectangle}',\n  'Cho hình thoi {rhombus}': 'hình thoi {rhombus}',\n  'Cho hình vuông {square}': 'hình vuông {square}',\n  '{object type triangle} tại {escribedPoint}': '{object type triangle} tại {escribedPoint}',\n  '{object type triangle}': '{object type triangle}'\n};\n\nfunction getLength(dictionary) {\n  let count = 0;\n  Object.keys(dictionary).forEach((key) => {\n    count += dictionary[key].length;\n  });\n  return count;\n}\n\nfunction getInformation(string: string): mixed {\n  const defineSentences = Object.keys(specializeLanguageMap);\n  const _string = '_ '.concat(string.concat(' _'));\n  let isMatching = false;\n  let result = '';\n  defineSentences.forEach((sentence) => {\n    const _sentence = '_ '.concat(sentence.concat(' _'));\n    if (isMatching) return;\n    const value = getBasicInformation(_string, _sentence);\n    if (Object.keys(value).length > 0) {\n      const mySentence = classifyData(specializeLanguageMap[sentence], value);\n      result = mySentence;\n      isMatching = true;\n    }\n  });\n\n  return result;\n}\n\nfunction getBasicInformation(string, _defineSentence, type = 'define') {\n  let others = _defineSentence.match(new RegExp(GConst.Regex.OTHER, 'g'));\n  let params = _defineSentence.match(new RegExp(GConst.Regex.KEY, 'g'));\n  let result = {};\n  params.forEach((key) => {\n    result[key] = [];\n  });\n  for (let i = 0; i < params.length; i++) {\n    let start =\n      others[i]\n        .replace('+', '\\\\+')\n        .replace('-', '\\\\-')\n        .replace('*', '\\\\*')\n        .replace('(', '\\\\(')\n        .replace(')', '\\\\)') || '';\n    let end =\n      others[i + 1]\n        .replace('+', '\\\\+')\n        .replace('-', '\\\\-')\n        .replace('*', '\\\\*')\n        .replace('(', '\\\\(')\n        .replace(')', '\\\\)') || '';\n\n    let param = string.match(new RegExp(start + '(.*)' + end));\n    if (param) {\n      result[params[i]].push(param[1]);\n    }\n    if (i === others.length - 1) {\n      let lastParam = string.match(new RegExp(end + '(.*)'));\n      if (lastParam) result[params[i + 1]].push(lastParam[1]);\n    }\n  }\n\n  if (getLength(result) === params.length) {\n    if (type === 'relation') result[type] = others[1].replace('_', '').trim();\n    console.log(result);\n    return result;\n  }\n\n  return [];\n}\n\nfunction classifyData(sentence: string, data) {\n  let result = sentence;\n  Object.keys(data).forEach((key: string) => {\n    data[key].forEach((value: string) => {\n      result = result.replace(`{${key}}`, value);\n    });\n  });\n  return result;\n}\n\nexport function InputConverter(input: string): Array<RelationInputModel> {\n  const inputArray = input.split(new RegExp(';', 'g')).map((item: string): string => item.trim());\n  inputArray.splice(0, 1);\n  inputArray.splice(inputArray.length - 1, 1);\n  console.log(inputArray);\n  const convertedInput = inputArray.map((input) => {\n    return getInformation(input);\n  });\n\n  return convertedInput.map((input: string): RelationInputModel => new RelationInputModel(input));\n}\n","// @flow\n\nimport appData from '../Model/AppData';\nimport type { EquationType, PointDetailsType } from '../utils/types';\nimport { NodeType } from '../utils/types';\nimport GConst from '../core/config/values.js';\nimport {\n  calculateIntersectionTwoCircleEquations,\n  isIn,\n  makeRoundCoordinate,\n  calculateVector,\n  getLineFromTwoPoints,\n  isVectorSameDirection\n} from '../core/math/Math2D.js';\nimport { isQuadraticEquation } from '../utils/checker.js';\nimport { defineSentences } from '../core/definition/define';\nimport { defineInformation } from '../core/definition';\nimport { analyzeResult } from '../core/analysis/Analysis';\nimport RelationInputModel from '../Model/RelationInputModel';\nimport { action, computed, observable } from 'mobx';\nimport ErrorService from '../core/error/ErrorHandleService';\nimport { isTwoEquationEqual } from '../core/math/Math2D';\nimport { getRandomValue } from '../core/math/Generation';\nimport { Operation } from '../core/math/MathOperation';\nimport { InputConverter } from './InputConverter';\nimport autobind from 'autobind-decorator';\n\nconst NOT_FOUND = GConst.Number.NOT_FOUND;\nconst NOT_ENOUGH_SET = GConst.String.NOT_ENOUGH_SET;\n\nclass DataViewModel {\n  @observable\n  isReCalculated = false;\n\n  @observable\n  circlesData = {};\n\n  @observable\n  relationsInput: Array<RelationInputModel>;\n\n  inputData: Array<mixed> = [];\n\n  executedInputIndex: number;\n\n  @observable\n  executingRelation: mixed;\n\n  constructor(appData) {\n    this.data = appData;\n    //this.relationsInput = InputConverter(`Cho các điểm A, B, C; Cho tam giác vuông ABC; AB=16; ABC=38;`);\n    // this.relationsInput = [\n    //   new RelationInputModel('tam giác ABC'),\n    //   new RelationInputModel('AB = 4'),\n    //   new RelationInputModel('AC = 4'),\n    //   new RelationInputModel('ACB = 60')\n    //   //new RelationInputModel('ABC = 60')\n    // ];\n  }\n\n  @computed\n  get RelationsInput() {\n    return this.relationsInput;\n  }\n\n  @computed\n  get isInputEmpty(): boolean {\n    if (this.relationsInput.length === 1 && !this.relationsInput[0].value) {\n      return true;\n    }\n    return false;\n  }\n\n  @action\n  resetInputsStatus() {\n    this.relationsInput.forEach((input: RelationInputModel) => {\n      input.status = GConst.InputStatus.NORMAL;\n    });\n  }\n\n  @action\n  onInputChange(value: string, index: number) {\n    const newRelationInput = { ...this.relationsInput[index] };\n    newRelationInput.value = value;\n    this.relationsInput[index] = newRelationInput;\n    this.resetInputsStatus();\n  }\n\n  @action\n  addNewInput() {\n    this.relationsInput.push(new RelationInputModel(''));\n  }\n\n  @action\n  removeInput(index: number) {\n    this.relationsInput.splice(index, 1);\n  }\n\n  clear() {\n    this.data.clear();\n    this.inputData = [];\n    this.circlesData = {};\n    this.executedInputIndex = undefined;\n    this.executingRelation = undefined;\n  }\n\n  get getData() {\n    return this.data;\n  }\n\n  createPointDetails() {\n    this.data.getPointsMap.forEach((node) => {\n      const roots = this.isValidCoordinate(node.coordinate) ? [node.coordinate] : [];\n      this._updatePointDetails(node.id, {\n        setOfEquation: [],\n        roots: roots,\n        exceptedCoordinates: [],\n        insideRule: [],\n        outsideRule: []\n      });\n    });\n  }\n\n  @autobind\n  pushInsideRule(pointId: string, segment: string) {\n    this.data.getPointDetails.get(pointId).insideRule.push(segment);\n  }\n\n  @autobind\n  checkInsideRule(point: string, coordinate: CoordinateType): boolean {\n    const insideRuleSegments = this.data.getPointDetails.get(point).insideRule;\n\n    for (let i = 0; i < insideRuleSegments.length; i++) {\n      if (\n        !this.checkPointRelationWithTwoPoint(\n          coordinate,\n          dataViewModel.getNodeInPointsMapById(insideRuleSegments[0][0]).coordinate,\n          dataViewModel.getNodeInPointsMapById(insideRuleSegments[0][1]).coordinate\n        )\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @autobind\n  checkPointRelationWithTwoPoint(\n    coordinate: CoordinateType,\n    coordinateOne: CoordinateType,\n    coordinateTwo: CoordinateType\n  ): number {\n    const vectorOne = calculateVector(coordinate, coordinateOne);\n    const vectorTwo = calculateVector(coordinate, coordinateTwo);\n\n    return (\n      isIn(coordinate, getLineFromTwoPoints(coordinateOne, coordinateTwo)) &&\n      !isVectorSameDirection(vectorOne, vectorTwo)\n    );\n  }\n\n  pushOutsideRule(pointId: string, segment: string) {\n    this.data.getPointDetails.get(pointId).outsideRule.push(segment);\n  }\n\n  isNeedRandomCoordinate = (pointId: string): boolean => {\n    const roots = this.data.getPointDetails.get(pointId).roots;\n    if (roots) {\n      for (let i = 0; i < roots.length; i++) {\n        if (\n          this.data.getPointDirectionMap[pointId] ||\n          JSON.stringify(makeRoundCoordinate(roots[i])) ===\n            JSON.stringify(makeRoundCoordinate(this.getNodeInPointsMapById(pointId).coordinate))\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  updateCoordinate = (nodeId: string, coordinate: CoordinateType, f: number = 3): void => {\n    const index = this.getIndexOfNodeInPointsMapById(nodeId);\n    if (!coordinate) {\n      ErrorService.showError('200');\n    }\n\n    const _coordinate = {};\n    Object.keys(coordinate)\n      .sort()\n      .forEach((key: string) => {\n        _coordinate[key] = coordinate[key];\n      });\n    if (nodeId === 'C') {\n      console.error(Operation.Round(_coordinate.x), Operation.Round(_coordinate.y));\n    }\n    if (index !== NOT_FOUND) {\n      this.data.getPointsMap[index].coordinate = _coordinate;\n    }\n  };\n\n  isStaticNode = (node: NodeType): boolean => {\n    if (node.isStatic) return true;\n    for (let i = 0; i < node.dependentNodes.length; i++) {\n      if (!this.isExecutedRelation(node.dependentNodes[i].relation)) {\n        return false;\n      }\n    }\n\n    return this.data.getExecutedNode.includes(node.id);\n  };\n\n  reExecuteNode = (arrayPoint: Array<string>) => {\n    this.isReCalculated = true;\n    this.getData.pointsMap.forEach((node: NodeType, index: number) => {\n      if (arrayPoint.includes(node.id)) {\n        return;\n      }\n      this.getData.pointsMap[index].dependentNodes.forEach((dependence: NodeRelationType, index: number) => {\n        if (dependence.relation.outputType === 'shape' && !dependence.relation.point && arrayPoint.length > 0) {\n          this.getData.pointsMap[index].dependentNodes[index] = { ...dependence, id: arrayPoint[0] };\n        }\n      });\n      this.getData.pointsMap[index].isStatic = false;\n    });\n    this.getData.__pointDetails__.clear();\n\n    this.getData.executedNode = arrayPoint;\n    const keepExecutedRelations = this.getData.executedRelations.filter(\n      (relation: mixed): boolean => relation.outputType === 'shape'\n    );\n    this.getData.executedRelations = keepExecutedRelations;\n  };\n\n  isExecutedRelation = (relation: any): boolean => {\n    for (let i = 0; i < this.data.getExecutedRelations.length; i++) {\n      if (JSON.stringify(relation) === JSON.stringify(this.data.getExecutedRelations[i])) return true;\n    }\n\n    return false;\n  };\n\n  updateStaticNode = () => {\n    const pointsMap = this.data.getPointsMap.map((node: NodeType): NodeType => {\n      node.isStatic = this.isStaticNode(node);\n      return node;\n    });\n    this.data.setPointsMap = pointsMap;\n  };\n\n  updatePointsMap = (node: NodeType) => {\n    let index = this.getIndexOfNodeInPointsMapById(node.id);\n    this.data.getPointsMap[index] = node;\n  };\n\n  isPointsMapStatic = (): boolean => {\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\n      if (!this.data.getPointsMap[i].isStatic) return false;\n    }\n    return true;\n  };\n\n  isCoordinateExist(id: string, coordinate: CoordinateType): boolean {\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\n      if (\n        this.data.getPointsMap[i].id !== id &&\n        Operation.isEqual(this.data.getPointsMap[i].coordinate.x, coordinate.x) &&\n        Operation.isEqual(this.data.getPointsMap[i].coordinate.y, coordinate.y)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isValidCoordinate = (nodeId: string) => {\n    if (nodeId) {\n      const node = this.getNodeInPointsMapById(nodeId);\n      if (node) {\n        return node.coordinate.x !== undefined && node.coordinate.y !== undefined;\n      }\n    }\n    return false;\n  };\n\n  getNextExecuteNode = (): NodeType => {\n    const clonePointsMap = this.data.pointsMap\n      .filter((node) => !this.data.executedNode.includes(node.id) && !this.isStaticNode(node))\n      .sort(this.sortNodeByPriority);\n\n    if (clonePointsMap.length > 0) return clonePointsMap[0];\n    return null;\n  };\n\n  sortNodeByPriority = (nodeOne: NodeType, nodeTwo: NodeType): number => {\n    const staticNodeOneCount = this.getDependentStaticNodeCount(nodeOne);\n    const nodeOneData = {\n      static: staticNodeOneCount,\n      nonStatic: nodeOne.dependentNodes.length - staticNodeOneCount,\n      dependence: nodeOne.dependentNodes.length,\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeOne),\n      index: this.getIndexOfNodeInPointsMap(nodeOne)\n    };\n\n    const staticNodeTwoCount = this.getDependentStaticNodeCount(nodeTwo);\n    const nodeTwoData = {\n      static: staticNodeTwoCount,\n      nonStatic: nodeTwo.dependentNodes.length - staticNodeTwoCount,\n      dependence: nodeTwo.dependentNodes.length,\n      minRelationIndex: this.getMinIndexOfDependentNodeInRelationsList(nodeTwo),\n      index: this.getIndexOfNodeInPointsMap(nodeTwo)\n    };\n\n    //get Max\n    const rankingOrderDesc = ['static', 'dependence'];\n\n    //get Min\n    const rankingOrderAsc = ['nonStatic', 'minRelationIndex', 'index'];\n\n    let rankOne = nodeOneData.static === nodeOneData.dependence ? '1' : '0';\n    let rankTwo = nodeTwoData.static === nodeTwoData.dependence ? '1' : '0';\n\n    rankingOrderDesc.forEach((key) => {\n      if (nodeOneData[key] > nodeTwoData[key]) {\n        rankOne += '1';\n        rankTwo += '0';\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\n        rankOne += '1';\n        rankTwo += '1';\n      } else {\n        rankOne += '0';\n        rankTwo += '1';\n      }\n    });\n\n    rankingOrderAsc.forEach((key) => {\n      if (nodeOneData[key] < nodeTwoData[key]) {\n        rankOne += '1';\n        rankTwo += '0';\n      } else if (nodeOneData[key] === nodeTwoData[key]) {\n        rankOne += '1';\n        rankTwo += '1';\n      } else {\n        rankOne += '0';\n        rankTwo += '1';\n      }\n    });\n\n    return parseInt(rankTwo) - parseInt(rankOne);\n  };\n\n  getMinIndexOfDependentNodeInRelationsList = (node: NodeType) => {\n    const indexArray = [];\n    for (let i = 0; i < node.dependentNodes.length; i++) {\n      indexArray.push(this.getIndexOfRelationInRelationsList(node.dependentNodes[i]));\n    }\n\n    return Math.min(...indexArray);\n  };\n\n  getIndexOfRelationInRelationsList = (relation: any): number => {\n    const list = this.data.getRelationsResult.shapes.concat(this.data.getRelationsResult.relations);\n    for (let i = 0; i < list.length; i++) {\n      if (relation === list[i]) return i;\n    }\n    return NOT_FOUND;\n  };\n\n  getDependentStaticNodeCount = (node: NodeType): number => {\n    let count = 0;\n    for (let i = 0; i < node.dependentNodes.length; i++) {\n      if (this.isStaticNodeById(node.dependentNodes[i].id)) count++;\n    }\n\n    return count;\n  };\n\n  getIndexOfNodeInPointsMap = (node): number => {\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\n      if (node === this.data.getPointsMap[i]) return i;\n    }\n    return NOT_FOUND;\n  };\n\n  getIndexOfNodeInPointsMapById = (id: string): number => {\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\n      if (id === this.data.getPointsMap[i].id) return i;\n    }\n    return NOT_FOUND;\n  };\n\n  getNodeInPointsMapById = (id: string): NodeType | null => {\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\n      if (id === this.data.getPointsMap[i].id) {\n        return this.data.getPointsMap[i];\n      }\n    }\n    return null;\n  };\n\n  isStaticNodeById = (id: string): boolean => {\n    for (let i = 0; i < this.data.getPointsMap.length; i++) {\n      if (id === this.data.getPointsMap[i].id) {\n        return this.isStaticNode(this.data.getPointsMap[i]);\n      }\n    }\n    return false;\n  };\n\n  _calculateSet = (equations: Array<EquationType>) => {\n    if (equations.length >= 2) {\n      return calculateIntersectionTwoCircleEquations(equations[0], equations[1]);\n    } else return NOT_ENOUGH_SET;\n  };\n\n  replaceSetOfEquation(pointId: string, searchEquation: EquationType, replaceEquation: EquationType) {\n    if (!this.data.getPointDetails.has(pointId)) {\n      this._updatePointDetails(pointId, {\n        setOfEquation: [],\n        roots: [],\n        exceptedCoordinates: [],\n        insideRule: [],\n        outsideRule: []\n      });\n    }\n    const pointDetail = this.data.getPointDetails.get(pointId);\n    const setOfEquation = pointDetail.setOfEquation;\n    let isReplaceComplete = false;\n\n    setOfEquation.forEach((equation: EquationType, index: number) => {\n      if (isTwoEquationEqual(equation, searchEquation)) {\n        setOfEquation[index] = replaceEquation;\n        isReplaceComplete = true;\n      }\n    });\n\n    if (!isReplaceComplete) {\n      setOfEquation.push(replaceEquation);\n    }\n    if (setOfEquation.length === 1) {\n      return;\n    }\n    const roots = this._calculateSet(setOfEquation);\n\n    this.data.getPointDetails.set(pointId, {\n      ...pointDetail,\n      setOfEquation,\n      roots\n    });\n\n    if (roots.length > 0) {\n      let coordinate;\n      if (dataViewModel.isNeedRandomCoordinate(pointId)) {\n        coordinate = roots[getRandomValue(0, roots.length - 1)];\n      } else {\n        const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\n\n        if (nodeDirectionInfo) {\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\n          if (roots.length > 1) {\n            const rootsDirection = roots.map((root) => ({\n              coordinate: root,\n              isRight: Operation.Compare(staticPointCoordinate.x, root.x) < 0,\n              isUp: Operation.Compare(staticPointCoordinate.y, root.y)\n            }));\n\n            const coordinateMatch = rootsDirection\n              .map((directionInfo) => {\n                let matchCount = 0;\n                if (directionInfo.isRight === nodeDirectionInfo.isRight) {\n                  matchCount++;\n                }\n                if (directionInfo.isUp === nodeDirectionInfo.isUp) {\n                  matchCount++;\n                }\n                return {\n                  coordinate: directionInfo.coordinate,\n                  matchCount\n                };\n              })\n              .sort((a, b) => b.matchCount - a.matchCount)[0];\n\n            coordinate = coordinateMatch.coordinate;\n          } else {\n            coordinate = roots[0];\n          }\n        } else {\n          coordinate = roots[0];\n        }\n      }\n      if (coordinate) {\n        dataViewModel.updateCoordinate(pointId, coordinate);\n      }\n    }\n  }\n\n  _updatePointDetails(pointId: string, pointDetails: PointDetailsType) {\n    this.data.getPointDetails.set(pointId, pointDetails);\n  }\n\n  uniqueSetOfEquation(equations: any[]): any[] {\n    let result = [];\n\n    equations.forEach((equation) => {\n      for (let i = 0; i < result.length; i++) {\n        if (JSON.stringify(equation) === JSON.stringify(result[i])) return;\n      }\n      result.push(equation);\n    });\n\n    return result;\n  }\n\n  executePointDetails(pointId: string, equation: EquationType) {\n    let isFirst = false;\n    if (!this.data.getPointDetails.has(pointId)) {\n      this._updatePointDetails(pointId, {\n        setOfEquation: [],\n        roots: [],\n        exceptedCoordinates: [],\n        insideRule: [],\n        outsideRule: []\n      });\n    }\n\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length <= 1) {\n      let newSetOfEquation = [...this.data.getPointDetails.get(pointId).setOfEquation, equation];\n      if (newSetOfEquation.length === 2) {\n        if (isTwoEquationEqual(newSetOfEquation[0], newSetOfEquation[1])) {\n          newSetOfEquation = newSetOfEquation[0];\n        }\n      }\n      this._updatePointDetails(pointId, {\n        ...this.data.getPointDetails.get(pointId),\n        setOfEquation: newSetOfEquation,\n        roots: this.data.getPointDetails.get(pointId).roots,\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\n      });\n      isFirst = true;\n    }\n\n    if (this.data.getPointDetails.get(pointId).setOfEquation.length === 2) {\n      if (isQuadraticEquation(equation) && !isFirst) {\n        for (let i = 0; i < 2; i++) {\n          if (!isQuadraticEquation(this.data.getPointDetails.get(pointId).setOfEquation[i])) {\n            this.data.getPointDetails.get(pointId).setOfEquation[i] = equation;\n            break;\n          }\n        }\n      }\n\n      const roots = this._calculateSet(this.data.getPointDetails.get(pointId).setOfEquation);\n      const currentRoots = this.data.getPointDetails.get(pointId).roots;\n\n      const finalRoots = typeof roots === 'string' ? currentRoots : currentRoots.concat(roots);\n      this._updatePointDetails(pointId, {\n        ...this.data.getPointDetails.get(pointId),\n        setOfEquation: this.data.getPointDetails.get(pointId).setOfEquation,\n        roots: finalRoots,\n        exceptedCoordinates: this.data.getPointDetails.get(pointId).exceptedCoordinates\n      });\n    }\n\n    let temp = this.data.getPointDetails.get(pointId).roots;\n\n    if (typeof temp === 'string') {\n      ErrorService.showError('500');\n      return;\n    }\n\n    temp = temp.filter((root) => {\n      if (root.y === Infinity) {\n        console.error(temp);\n      }\n      return isIn(root, equation);\n    });\n\n    if (temp.length > 0) {\n      // TODO: Add exception\n      this._updatePointDetails(pointId, {\n        ...this.data.getPointDetails.get(pointId),\n        roots: temp\n      });\n\n      let coordinate;\n      if (dataViewModel.isNeedRandomCoordinate(pointId)) {\n        coordinate = temp[getRandomValue(0, temp.length)];\n      } else {\n        const nodeDirectionInfo = dataViewModel.getData.getPointDirectionMap[pointId];\n        if (nodeDirectionInfo) {\n          const staticPointCoordinate = dataViewModel.getNodeInPointsMapById(nodeDirectionInfo.root).coordinate;\n          if (temp.length > 1) {\n            const rootsDirection = temp.map((root) => ({\n              coordinate: root,\n              isRight: Operation.Compare(staticPointCoordinate.x, root.x),\n              isUp: Operation.Compare(staticPointCoordinate.y, root.y)\n            }));\n\n            let coordinateMatch = rootsDirection.map((directionInfo) => {\n              let matchCount = 0;\n              if (directionInfo.isRight === nodeDirectionInfo.isRight) {\n                matchCount++;\n              }\n              if (directionInfo.isUp === nodeDirectionInfo.isUp) {\n                matchCount++;\n              }\n              return {\n                coordinate: directionInfo.coordinate,\n                matchCount\n              };\n            });\n            console.log(nodeDirectionInfo.root, coordinateMatch);\n            let beSorted = coordinateMatch.sort((a, b) => b.matchCount - a.matchCount);\n            coordinateMatch = beSorted[0];\n\n            coordinate = coordinateMatch.coordinate;\n          } else {\n            coordinate = temp[0];\n          }\n        } else {\n          coordinate = temp[0];\n        }\n      }\n      if (coordinate) {\n        dataViewModel.updateCoordinate(pointId, coordinate);\n      }\n    }\n  }\n\n  getInformation(string: string): mixed {\n    const _string = '_ '.concat(string.concat(' _'));\n    let isMatching = false;\n    let preProgress = [];\n    Object.keys(defineSentences).forEach((key) => {\n      defineSentences[key].forEach((sentence) => {\n        sentence = '_ '.concat(sentence.concat(' _'));\n\n        if (isMatching) return;\n        const value = this.getBasicInformation(_string, sentence, key);\n        if (Object.keys(value).length > 0) {\n          isMatching = true;\n          preProgress = value;\n          preProgress['outputType'] = key;\n        }\n      });\n    });\n    const type = preProgress.outputType;\n\n    const result = defineInformation(preProgress);\n    if (result.Error || !result.outputType) {\n      ErrorService.showError('300');\n      return;\n    }\n    if (result.point && result.point.length > 3) {\n      ErrorService.showError('301');\n      return;\n    }\n\n    // add operation for define type\n    if (type === 'define') {\n      GConst.Others.OPERATIONS.forEach((operation) => {\n        if (result.operation) return;\n        if (string.includes(operation)) {\n          result.operation = operation;\n          if (operation === '=' && !result.value) {\n            result.value = '1';\n            result.operation = '*';\n          }\n        }\n      });\n    }\n    return result;\n  }\n\n  getBasicInformation(string, _defineSentence, type) {\n    let others = _defineSentence.match(new RegExp(GConst.Regex.OTHER, 'g'));\n    let params = _defineSentence.match(new RegExp(GConst.Regex.KEY, 'g'));\n\n    let result = {};\n\n    params.forEach((key) => {\n      result[key] = [];\n    });\n\n    for (let i = 0; i < params.length; i++) {\n      let start =\n        others[i]\n          .replace('+', '\\\\+')\n          .replace('-', '\\\\-')\n          .replace('*', '\\\\*') || '';\n      let end =\n        others[i + 1]\n          .replace('+', '\\\\+')\n          .replace('-', '\\\\-')\n          .replace('*', '\\\\*') || '';\n\n      let param = string.match(new RegExp(start + '(.*)' + end));\n\n      if (param) result[params[i]].push(param[1]);\n\n      if (i === others.length - 1) {\n        let lastParam = string.match(new RegExp(end + '(.*)'));\n        if (lastParam) result[params[i + 1]].push(lastParam[1]);\n      }\n    }\n\n    if (this.getLength(result) === params.length) {\n      if (type === 'relation') result[type] = others[1].replace('_', '').trim();\n      return result;\n    }\n\n    return [];\n  }\n\n  getLength(dictionary) {\n    let count = 0;\n    Object.keys(dictionary).forEach((key) => {\n      count += dictionary[key].length;\n    });\n    return count;\n  }\n\n  getCircleEquation(centerId: string): EquationType {\n    return this.circlesData[centerId].equation;\n  }\n\n  getCircleCenterCoordinate(centerId: string): CoordinateType {\n    return this.circlesData[centerId].coordinate;\n  }\n\n  isCoordinateDuplicated(coordinate: CoordinateType): boolean {\n    const stringifyCoordinate = JSON.stringify(coordinate);\n    let result = false;\n    this.getData.pointsMap.forEach((node: NodeType) => {\n      const key = node.id;\n      if (result) {\n        return;\n      }\n      if (JSON.stringify(stringifyCoordinate) === JSON.stringify(this.getNodeInPointsMapById(key).coordinate)) {\n        result = true;\n      }\n    });\n\n    return result;\n  }\n\n  analyzeInput() {\n    this.circlesData = {};\n    const data = this.RelationsInput.map((relationsInput: RelationInputModel): string => relationsInput.value)\n      // eslint-disable-next-line no-control-getBasicInformation\n      .filter((sentence) => !!sentence)\n      .map((sentence: string, index: number) => {\n        this.executedInputIndex = index;\n        const result = this.getInformation(sentence);\n        this.relationsInput[index].status = GConst.InputStatus.SUCCESS;\n        this.inputData.push(result);\n        return result;\n      });\n\n    let result = {\n      shapes: [],\n      relations: []\n    };\n    for (let i = 0; i < data.length; i++) {\n      let item = data[i];\n\n      if (item.outputType === 'shape') {\n        result.shapes.push(item);\n      } else {\n        result.relations.push(item);\n      }\n    }\n\n    this.data.setRelationsResult = result;\n\n    this.RelationsInput.forEach((input: RelationInputModel) => {\n      input.status = GConst.InputStatus.SUCCESS;\n    });\n    return analyzeResult(result);\n  }\n}\n\nconst dataViewModel = new DataViewModel(appData);\n\nexport default dataViewModel;\n","export const LineStyle = {\n    Dashed: 0,\n    Light: 1,\n    Medium: 2,\n    Bold: 3,\n};\n\nconst SEGMENTS = 'segments';\nconst LINES = 'lines';\nconst CIRCLES = 'circles';\nconst NOT_FOUND = 'NOT FOUND';\nconst Boundary = {\n    MIN_HORIZONTAL: 'min-horizontal',\n    MAX_HORIZONTAL: 'max-horizontal',\n    MIN_VERTICAL: 'min-vertical',\n    MAX_VERTICAL: 'max-vertical',\n};\n\n\nexport default function createDrawingData({data}) {\n\n    // Stores a pair of a point name-coordinate\n    const __pointsMap__ = new Map();\n\n    /*  Stores 3 of instances drawing type:\n     *     + Segments type:\n     *       ∙ name -> { startPoint, endPoint, lineStyle, isVisible }\n     *     + Lines type:\n     *       ∙ name -> { lineStyle, isVisible }\n     *     + Circles type:\n     *       ∙ name -> { centerPoint, radius, lineStyle, isVisible }\n     */\n    const __drawingMap__ = new Map();\n\n    // Stores boundary points of geometry\n    const __boundaryPoints__ = new Map();\n\n    let isInitDone = false;\n\n    initialize();\n    initData(data);\n\n    return Object.freeze({\n        addPoint,\n        addPoints,\n        addSegment,\n        addSegments,\n        addLine,\n        addCircle,\n        addCircles,\n\n        getPoint,\n        getPoints,\n        getSegment,\n        getSegments,\n        getLine,\n        getLines,\n        getCircle,\n        getCircles,\n        getMinHorizontalPoint,\n        getMaxHorizontalPoint,\n        getMinVerticalPoint,\n        getMaxVerticalPoint,\n    });\n\n    function initialize() {\n        __drawingMap__.set(SEGMENTS, new Map());\n        __drawingMap__.set(LINES, new Map());\n        __drawingMap__.set(CIRCLES, new Map());\n    }\n\n    function initData(data) {\n        if (data.points) {\n            addPoints(data.points);\n            _updateBoundaryPoints();\n        }\n        if (data.segments) {\n            addSegments(data.segments);\n        }\n        if (data.lines) {\n            // addLines(data.lines);\n        }\n        if (data.circles) {\n\n            if (Array.isArray(data.circles)) {\n                addCircles(data.circles);\n            }\n            else {\n                const dataCircles = convertCircleFromObjToArr(data.circles);\n                addCircles(dataCircles);\n            }\n        }\n        isInitDone = true;\n    }\n\n    function _updateBoundaryPoints() {\n        let minX = 0;\n        let minXPoint = '';\n        let maxX = 0;\n        let maxXPoint = '';\n        let minY = 0;\n        let minYPoint = '';\n        let maxY = 0;\n        let maxYPoint = '';\n\n        const points = getPoints();\n        points.forEach((point, index) => {\n            if (point.name && point.coordinate) {\n                if (index === 0) {\n                    minX = point.coordinate.x;\n                    minXPoint = point.name;\n\n                    maxX = point.coordinate.x;\n                    maxXPoint = point.name;\n\n                    minY = point.coordinate.y;\n                    minYPoint = point.name;\n\n                    maxY = point.coordinate.y;\n                    maxYPoint = point.name;\n                }\n                else {\n                    if (point.coordinate.x < minX) {\n                        minX = point.coordinate.x;\n                        minXPoint = point.name;\n                    }\n                    else if (point.coordinate.x > maxX) {\n                        maxX = point.coordinate.x;\n                        maxXPoint = point.name;\n                    }\n\n                    if (point.coordinate.y < minY) {\n                        minY = point.coordinate.y;\n                        minYPoint = point.name;\n                    }\n                    else if (point.coordinate.y > maxY) {\n                        maxY = point.coordinate.y;\n                        maxYPoint = point.name;\n                    }\n                }\n                addPoint({\n                    name: point.name,\n                    x: point.coordinate.x,\n                    y: point.coordinate.y,\n                });\n            }\n        });\n        _setMinHorizontalPoint({\n            name: minXPoint,\n            x: getPoint(minXPoint).x,\n            y: getPoint(minXPoint).y,\n        });\n        _setMaxHorizontalPoint({\n            name: maxXPoint,\n            x: getPoint(maxXPoint).x,\n            y: getPoint(maxXPoint).y,\n        });\n        _setMinVerticalPoint({\n            name: minYPoint,\n            x: getPoint(minYPoint).x,\n            y: getPoint(minYPoint).y,\n        });\n        _setMaxVerticalPoint({\n            name: maxYPoint,\n            x: getPoint(maxYPoint).x,\n            y: getPoint(maxYPoint).y,\n        });\n    }\n\n    function addPoint({name, x, y}) {\n        if (name) {\n            __pointsMap__.set(name, {\n                x,\n                y,\n            });\n\n            if (isInitDone) {\n                if (x < getMinHorizontalPoint().coordinate.x) {\n                    _setMinHorizontalPoint({\n                        name,\n                        x,\n                        y,\n                    });\n                } else if (x > getMaxHorizontalPoint().coordinate.x) {\n                    _setMaxHorizontalPoint({\n                        name,\n                        x,\n                        y,\n                    });\n                }\n\n                if (y < getMinVerticalPoint().coordinate.y) {\n                    _setMinVerticalPoint({\n                        name,\n                        x,\n                        y,\n                    });\n                } else if (y > getMaxVerticalPoint().coordinate.y) {\n                    _setMaxVerticalPoint({\n                        name,\n                        x,\n                        y,\n                    });\n                }\n            }\n        }\n    }\n\n    function addPoints(points) {\n        if (Array.isArray(points)) {\n            points.forEach(point => {\n                addPoint({\n                    name: point.id,\n                    x: point.coordinate.x,\n                    y: point.coordinate.y,\n                });\n            });\n        }\n    }\n\n    function addSegment({name, lineStyle, isVisible}) {\n        if (name) {\n            const startPoint = name[0];\n            const endPoint = name[1];\n\n            __drawingMap__\n                .get(SEGMENTS)\n                .set(\n                    name,\n                    {\n                        startPoint: startPoint,\n                        endPoint: endPoint,\n                        lineStyle: lineStyle !== undefined && lineStyle !== null ?\n                            lineStyle :\n                            LineStyle.Light,\n                        isVisible: isVisible !== undefined && isVisible !== null ?\n                            isVisible :\n                            true,\n                    });\n        }\n    }\n\n    function addSegments(segments) {\n        if (Array.isArray(segments)) {\n            segments.forEach((segment) => {\n                addSegment({\n                    name: segment.name,\n                    lineStyle: segment.lineStyle,\n                    isVisible: segment.isVisible,\n                });\n            });\n        }\n    }\n\n    function addLine({name, lineStyle, isVisible}) {\n        if (name) {\n            const startPoint = name[0];\n            const endPoint = name[1];\n\n            __drawingMap__\n                .get(LINES)\n                .set(\n                    name,\n                    {\n                        startPoint: startPoint,\n                        endPoint: endPoint,\n                        lineStyle: lineStyle !== undefined && lineStyle !== null ?\n                            lineStyle :\n                            LineStyle.Light,\n                        isVisible: isVisible !== undefined && isVisible !== null ?\n                            isVisible :\n                            true,\n                    });\n        }\n    }\n\n    function addCircle({center, radius, equation, lineStyle, isVisible}) {\n        if (center && radius) {\n            const centerName = center.id;\n\n            __drawingMap__\n                .get(CIRCLES)\n                .set(\n                    centerName,\n                    {\n                        center: {\n                            id: center.id,\n                            coordinate: center.coordinate,\n                        },\n                        radius: radius ?\n                            radius :\n                            0,\n                        lineStyle: lineStyle !== undefined && lineStyle !== null ?\n                            lineStyle :\n                            LineStyle.Light,\n                        isVisible: isVisible !== undefined && isVisible !== null ?\n                            isVisible :\n                            true,\n                    });\n        }\n    }\n\n    function addCircles(circles) {\n        if (Array.isArray(circles)) {\n            circles.forEach(circle => {\n                addCircle({\n                    center: circle.center,\n                    radius: circle.radius,\n                    equation: circle.equation,\n                    lineStyle: circle.lineStyle,\n                    isVisible: circle.isVisible,\n                });\n            });\n        }\n    }\n\n    function convertCircleFromObjToArr(objCircles) {\n        const keys = Object.keys(objCircles);\n        const res = [];\n        let i = 0;\n        while (keys[i]) {\n            const obj = {\n                center: {\n                    id: keys[i],\n                    coordinate: objCircles[keys[i]].center,\n                },\n                radius: objCircles[keys[i]]['radius'],\n                equation: objCircles[keys[i]]['equation'],\n                lineStyle: objCircles[keys[i]]['lineType'],\n                isVisible: objCircles[keys[i]]['visible'],\n            };\n            res.push(obj);\n            i++;\n        }\n        return res;\n    }\n\n    function getPoint(pointName) {\n        const uppercasePointName = pointName.toUpperCase();\n        return __pointsMap__.has(uppercasePointName) ?\n            __pointsMap__.get(uppercasePointName) :\n            {\n                x: -Infinity,\n                y: -Infinity,\n            };\n    }\n\n    function getPoints() {\n        let res = [];\n        const keys = __pointsMap__.keys();\n        for (let i = 0; i < __pointsMap__.size; i++) {\n            const pointName = keys.next().value;\n            const pointValues = __pointsMap__.get(pointName);\n            const point = {\n                name: pointName,\n                coordinate: {\n                    x: pointValues.x,\n                    y: pointValues.y,\n                },\n            };\n            res.push(point);\n        }\n        return res;\n    }\n\n    function getSegment(segmentName) {\n        return __drawingMap__.get(SEGMENTS).has(segmentName) ?\n            __drawingMap__.get(SEGMENTS).get(segmentName) :\n            NOT_FOUND;\n    }\n\n    function getSegments() {\n        let res = [];\n        const segments = __drawingMap__.get(SEGMENTS);\n        const segmentKeys = segments.keys();\n        for (let i = 0; i < segments.size; i++) {\n            const segmentName = segmentKeys.next().value;\n            const segmentValue = getSegment(segmentName);\n            const segment = {\n                name: segmentName,\n                startPoint: segmentValue['startPoint'],\n                endPoint: segmentValue['endPoint'],\n                lineStyle: segmentValue['lineStyle'],\n                isVisible: segmentValue['isVisible'],\n            };\n            res.push(segment);\n        }\n        return res;\n    }\n\n    function getLine(lineName) {\n        return __drawingMap__.get(LINES).has(lineName) ?\n            __drawingMap__.get(LINES).get(lineName) :\n            NOT_FOUND;\n    }\n\n    function getLines() {\n        let res = [];\n        const lines = __drawingMap__.get(LINES);\n        const lineKeys = lines.keys();\n        for (let i = 0; i < lines.size; i++) {\n            const lineName = lineKeys.next().value;\n            const lineValue = getSegment(lineName);\n            const segment = {\n                name: lineName,\n                lineStyle: lineValue['lineStyle'],\n                isVisible: lineValue['isVisible'],\n            };\n            res.push(segment);\n        }\n        return res;\n    }\n\n    function getCircle(circleName) {\n        return __drawingMap__.get(CIRCLES).has(circleName) ?\n            __drawingMap__.get(CIRCLES).get(circleName) :\n            NOT_FOUND;\n    }\n\n    function getCircles() {\n        let res = [];\n        const circles = __drawingMap__.get(CIRCLES);\n        const circletKeys = circles.keys();\n        for (let i = 0; i < circles.size; i++) {\n            const circleName = circletKeys.next().value;\n            const circleValue = getCircle(circleName);\n            const circle = {\n                center: {\n                    id: circleName,\n                    coordinate: circleValue['center'].coordinate,\n                },\n                radius: circleValue['radius'],\n                lineStyle: circleValue['lineStyle'],\n                isVisible: circleValue['isVisible'],\n            };\n            res.push(circle);\n        }\n        return res;\n    }\n\n    function getMinHorizontalPoint() {\n        return __boundaryPoints__.get(Boundary.MIN_HORIZONTAL) || {};\n    }\n\n    function _setMinHorizontalPoint({name, x, y}) {\n        __boundaryPoints__.set(\n            Boundary.MIN_HORIZONTAL,\n            {\n                name: name,\n                coordinate: {\n                    x,\n                    y,\n                },\n            },\n        );\n    }\n\n    function getMaxHorizontalPoint() {\n        return __boundaryPoints__.get(Boundary.MAX_HORIZONTAL) || {};\n    }\n\n    function _setMaxHorizontalPoint({name, x, y}) {\n        __boundaryPoints__.set(\n            Boundary.MAX_HORIZONTAL,\n            {\n                name: name,\n                coordinate: {\n                    x,\n                    y,\n                },\n            },\n        );\n    }\n\n    function getMinVerticalPoint() {\n        return __boundaryPoints__.get(Boundary.MIN_VERTICAL) || {};\n    }\n\n    function _setMinVerticalPoint({name, x, y}) {\n        __boundaryPoints__.set(\n            Boundary.MIN_VERTICAL,\n            {\n                name: name,\n                coordinate: {\n                    x,\n                    y,\n                },\n            },\n        );\n    }\n\n    function getMaxVerticalPoint() {\n        return __boundaryPoints__.get(Boundary.MAX_VERTICAL) || {};\n    }\n\n    function _setMaxVerticalPoint({name, x, y}) {\n        __boundaryPoints__.set(\n            Boundary.MAX_VERTICAL,\n            {\n                name: name,\n                coordinate: {\n                    x,\n                    y,\n                },\n            },\n        );\n    }\n}","import * as React from 'react';\nimport type { DrawingDataType } from '../../../utils/types';\nimport './DrawingPanel.scss';\nimport createDrawingData from '../../../core/drawing/base/DrawingData';\nimport { getTransformData } from '../../../core/drawing/core/TranformCenter';\nimport {\n    clearGeometry,\n    renderSvg,\n} from '../../../core/drawing/core/Render';\n\ntype PropsType = {\n    drawingData: DrawingDataType\n};\n\nclass DrawingPanel extends React.Component<PropsType> {\n    componentDidMount() {\n        this.renderGeometry(this.props.drawingData);\n    }\n\n    componentDidUpdate() {\n        this.renderGeometry(this.props.drawingData);\n    }\n\n    renderGeometry(drawingData: DrawingDataType) {\n        const svg = document.getElementById('geometry');\n        const viewBox = svg.viewBox.baseVal;\n        const width = viewBox.width;\n        const height = viewBox.height;\n\n        clearGeometry(svg);\n\n        const transformData = getTransformData({\n            data: drawingData,\n            width,\n            height,\n        });\n\n        const data = createDrawingData({data: transformData});\n        // function DataLogger(props, transformed) {\n        //     this.dataProps = `${props.x} : ${props.y}`;\n        //     this.dataTransformed = `${transformed.x} : ${transformed.y}`;\n        // }\n        //\n        // let logger = {};\n        // for(let pointsKey in this.props.drawingData.points) {\n        //     const pointName = this.props.drawingData.points[pointsKey].id;\n        //     if(pointName) {\n        //         logger[pointName] = new DataLogger(this.props.drawingData.points[pointsKey].coordinate, transformData.points[pointsKey].coordinate)\n        //     }\n        // }\n        // console.table(logger)\n        // console.log(width, height)\n\n        renderSvg({\n            scene: svg,\n            data,\n        });\n    }\n\n    render(): React.Node {\n        return (\n            <div className=\"geometry-container\">\n                <svg id=\"geometry\" className=\"geometry-scene\"\n                     viewBox=\"0 0 800 800\"/>\n            </div>\n        );\n    }\n}\n\nexport default DrawingPanel;\n","import * as d3 from 'd3';\nimport { LineStyle } from '../base/DrawingData';\n\nexport function renderSvg({scene, data}) {\n    const sWidth = scene.clientWidth;\n    const sHeight = scene.clientHeight;\n\n    const svg = d3.select(`#${scene.id}`)\n        .attr('viewBox', [\n            0,\n            0,\n            sWidth,\n            sHeight,\n        ]);\n\n    // ========== Segments ==========\n    const l = svg.append('g')\n        .attr('cursor', 'grab');\n\n    function getCoordinate(name) {\n        if (name) {\n            return {\n                x: data.getPoint(name).x,\n                y: data.getPoint(name).y,\n            };\n        }\n    }\n\n    function slicePoints(segmentName) {\n        const arr = Array.prototype.slice.call(segmentName, 0);\n        if (arr && arr[0] && arr[1]) {\n            return {\n                startPoint: arr[0],\n                endPoint: arr[1],\n            };\n        }\n        else {\n            return [];\n        }\n    }\n\n    function getStyles(comp) {\n        let style = '';\n        switch (comp.lineStyle) {\n            case LineStyle.Light:\n                style = `stroke-width: ${LineStyle.Light}`;\n                break;\n            case LineStyle.Medium:\n                style = `stroke-width: ${LineStyle.Medium}`;\n                break;\n            case LineStyle.Bold:\n                style = `stroke-width: ${LineStyle.Bold}`;\n                break;\n            default:\n                style = `stroke-width: ${LineStyle.Light}`;\n        }\n\n        if (comp.isVisible) {\n            if (style !== '') {\n                style += '; ';\n            }\n            style += 'visibility: visible';\n        }\n        else {\n            if (style !== '') {\n                style += '; ';\n            }\n            style += 'visibility: hidden';\n        }\n\n        return style;\n    }\n\n    const dSegments = data.getSegments();\n\n    l.selectAll('line')\n        .data(dSegments)\n        .join('line')\n        .attr('x1', (segment) => getCoordinate(slicePoints(segment.name).startPoint).x)\n        .attr('y1', (segment) => getCoordinate(slicePoints(segment.name).startPoint).y)\n        .attr('x2', (segment) => getCoordinate(slicePoints(segment.name).endPoint).x)\n        .attr('y2', (segment) => getCoordinate(slicePoints(segment.name).endPoint).y)\n        .attr('stroke-dasharray', segment => segment.lineStyle === 0 ?\n            ('6,3') :\n            'none')\n        .attr('style', segment => getStyles(segment));\n\n\n    // ========== Circles ==========\n    const c = svg.append('g')\n        .attr('cursor', 'grab');\n\n    let dCircles = data.getCircles();\n    c.selectAll('circle')\n        .data(dCircles)\n        .join('circle')\n        .attr('cx', dCircles => dCircles.center.coordinate.x)\n        .attr('cy', dCircles => dCircles.center.coordinate.y)\n        .attr('r', dCircles => dCircles.radius)\n        .attr('stroke-dasharray', segment => segment.lineStyle === 0 ?\n            ('6,3') :\n            'none')\n        .attr('style', circle => getStyles(circle));\n\n\n    // ========== Points ==========\n    const p = svg.append('g')\n        .attr('cursor', 'grab');\n\n    let dPoints = data.getPoints();\n    const radius = 4;\n    const points = p.selectAll('circle').data(dPoints);\n\n    points.enter()\n        .append('circle')\n        .attr('cx', p => p.coordinate.x)\n        .attr('cy', p => p.coordinate.y)\n        .attr('r', radius)\n        .attr('fill', (circleObj, i) => d3.interpolateRainbow(i / dPoints.length));\n\n    const fontSize = 22;\n\n    function getPointNamePosition(pName) {\n        /*\n         * With biggest char:\n         *  width's element excludes text = 0.67 font-size;\n         *  height's element excludes text = 1.37 font-size;\n         */\n\n        const minH = data.getMinHorizontalPoint();\n        const maxH = data.getMaxHorizontalPoint();\n        const minV = data.getMinVerticalPoint();\n        const maxV = data.getMaxVerticalPoint();\n\n        if (pName === minH.name) {\n            return {\n                x: minH.coordinate.x - fontSize * 0.67 - 10,\n                y: minH.coordinate.y + (fontSize * 1.37) / 3.8,\n            };\n        }\n        else if (pName === maxH.name) {\n            return {\n                x: maxH.coordinate.x + 10,\n                y: maxH.coordinate.y + (fontSize * 1.37) / 3.8,\n            };\n        }\n\n        if (pName === minV.name) {\n            return {\n                x: minV.coordinate.x - (fontSize * 0.67) / 2,\n                y: minV.coordinate.y - 10,\n            };\n        }\n        else if (pName === maxV.name) {\n            return {\n                x: maxV.coordinate.x - (fontSize * 0.67) / 2,\n                y: maxV.coordinate.y + fontSize * 1.37,\n            };\n        }\n\n        return {\n            x: data.getPoint(pName).x + fontSize / 2,\n            y: data.getPoint(pName).y - fontSize / 2,\n        };\n    }\n\n    points.enter()\n        .append('text')\n        .attr('x', p => getPointNamePosition(p.name).x)\n        .attr('y', p => getPointNamePosition(p.name).y)\n        .attr('id', p => `point-${p.name}`);\n\n    if (points && points._enter && Array.isArray(points._enter[0])) {\n        points._enter[0].forEach((node) => {\n            let name = '';\n            if (node && node.__data__ && node.__data__.name) {\n                name = node.__data__.name;\n            }\n\n            const element = document.getElementById(`point-${name}`);\n            if (element) {\n                const textNode = document.createTextNode(name);\n                element.appendChild(textNode);\n                element.style.fontSize = `${fontSize}px`;\n                element.style.fontFamily = 'appDescriptionFont';\n                element.style.fill = 'black';\n            }\n        });\n    }\n\n    svg.call(d3.zoom()\n        .extent([\n            [\n                0,\n                0,\n            ],\n            [\n                sWidth,\n                sHeight,\n            ],\n        ])\n        .scaleExtent([\n            1,\n            20,\n        ])\n        .on('zoom', zoomed));\n\n\n    function zoomed() {\n        p.attr('transform', d3.event['transform']);\n        l.attr('transform', d3.event['transform']);\n        c.attr('transform', d3.event['transform']);\n    }\n\n    return svg.node();\n}\n\nexport function clearGeometry(scene) {\n    while (scene.firstChild) {\n        scene.firstChild.remove();\n    }\n}","export function getTransformData({data, width, height}) {\n    if (data) {\n        const arrX = [];\n        const arrY = [];\n\n        if (Array.isArray(data.points)) {\n            data.points.forEach((point) => {\n                arrX.push(point.coordinate.x);\n                arrY.push(point.coordinate.y);\n            });\n\n            const circles = data.circles;\n            if (circles) {\n                Object.keys(circles).forEach((point) => {\n                    const center = circles[point].center;\n                    const radius = circles[point].radius;\n                    arrX.push(center.x - radius, center.x + radius);\n                    arrY.push(center.y - radius, center.y + radius);\n                });\n            }\n            const minX = Math.min(...arrX);\n            const minY = Math.min(...arrY);\n            const maxX = Math.max(...arrX);\n            const maxY = Math.max(...arrY);\n            const disparityX = maxX - minX;\n            const disparityY = maxY - minY;\n\n            const ODD = 100;\n            const w = width - ODD,\n                h = height - ODD;\n            let ratio = 0;\n            const rW = Math.floor(w / disparityX),\n                rH = Math.floor(h / disparityY);\n            let transitionX = 0,\n                transitionY = 0;\n            let followH = false;\n            if (rW >= rH) {\n                ratio = rH;\n                followH = true;\n            }\n            else {\n                ratio = rW;\n            }\n\n            let realCenter = 0, curCenter = 0;\n            if (followH) {\n                realCenter = width / 2;\n                curCenter = ((maxX - minX) / 2) * ratio;\n                transitionX = -(minX * ratio) + realCenter - curCenter;\n                transitionY = -(minY * ratio) + Math.floor(ODD / 2);\n            }\n            else {\n                realCenter = height / 2;\n                curCenter = ((maxY - minY) / 2) * ratio;\n                transitionX = -(minX * ratio) + Math.floor(ODD / 2);\n                transitionY = -(minY * ratio) + realCenter - curCenter;\n            }\n\n            console.log({\n                minX,\n                minY,\n                maxX,\n                maxY,\n                disparityX,\n                disparityY,\n                w,\n                h,\n                rW,\n                rH,\n                ratio,\n                followH,\n                realCenter,\n                curCenter,\n                transitionX,\n                transitionY,\n            });\n            const points = [];\n            data.points.forEach((point) => {\n                points.push({\n                    id: point.id,\n                    coordinate: {\n                        x: point.coordinate.x * ratio + transitionX,\n                        y: point.coordinate.y * ratio + transitionY,\n                    },\n                });\n            });\n\n            if (circles) {\n                const keys = Object.keys(circles);\n                let i = 0;\n                while (keys[i]) {\n                    circles[keys[i]] = {\n                        center: {\n                            x: circles[keys[i]].center.x * ratio + transitionX,\n                            y: circles[keys[i]].center.y * ratio + transitionY,\n                        },\n                        radius: circles[keys[i]].radius * ratio,\n                        equation: circles[keys[i]].equation,\n                    };\n                    i++;\n                }\n            }\n\n            return {\n                ...data,\n                points,\n                circles,\n            };\n        }\n    }\n    else {\n        return data;\n    }\n}","import React from 'react';\nimport './css/MainView.scss';\nimport { observer } from 'mobx-react';\nimport autobind from 'autobind-decorator';\n\nimport DataViewModel from '../ViewModel/DataViewModel';\nimport { InputConverter } from '../ViewModel/InputConverter';\n\nimport { DrawingPanel } from './components/DrawingPanel';\nimport { calculateDistanceTwoPoints, calculateVector, isVectorSameDirection } from '../core/math/Math2D';\nimport type { DrawingSegmentType, SegmentDataType } from '../utils/types';\nimport GConst from '../core/config/values';\nimport { LineStyle } from '../core/drawing/base/DrawingData';\nimport { withRouter } from 'react-router-dom';\nimport queryString from 'query-string';\n@observer\n// @withRouter\nclass IFrameView extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      focusIndex: 0,\n      drawingData: [],\n      points: [],\n      segments: []\n    };\n    let param = queryString.parse(window.location.search);\n  }\n\n  componentDidMount() {\n    let param = queryString.parse(window.location.search);\n\n    DataViewModel.relationsInput = InputConverter(param.input);\n    this.onClickDrawing();\n  }\n\n  // componentWillMount() {\n  //   const { points, segments } = this.state;\n  //   this.setState({\n  //     drawingData: this.trimDrawingData({ points, segments }).map((segment: string): DrawingSegmentType => ({\n  //       name: segment,\n  //       visible: true,\n  //       lineType: LineStyle.Medium\n  //     }))\n  //   });\n  // }\n\n  @autobind\n  trimDrawingData(data) {\n    const { points, segments } = data;\n\n    //change to DataViewModel.getNodeInPointsMapById.coordinate when refactor done\n    const pointData = {};\n    points.forEach((point) => {\n      pointData[point.id] = point.coordinate;\n    });\n\n    const segmentsData = {};\n    let result = [];\n    points.forEach((point) => {\n      segmentsData[point.id] = segments\n        .map((segment: string): string =>\n          segment\n            .split('')\n            .sort()\n            .join('')\n        )\n        .filter((segment: string): boolean => segment.includes(point.id))\n        .map((segment: string): SegmentDataType => {\n          const firstPoint = pointData[segment[0]];\n          const secondPoint = pointData[segment[1]];\n          return {\n            name: segment,\n            vector: calculateVector(firstPoint, secondPoint),\n            length: calculateDistanceTwoPoints(firstPoint, secondPoint)\n          };\n        });\n    });\n\n    const removeSegments = [];\n\n    Object.keys(segmentsData).forEach((point) => {\n      if (segmentsData[point].length > 0) {\n        const segments = this.uniqueSegmentData(segmentsData[point], removeSegments);\n        result = result.concat(segments);\n      }\n    });\n\n    result = [...new Set(result)].filter((segment: string): boolean => segment[0] !== segment[1]);\n\n    return result;\n  }\n\n  uniqueSegmentData(data: Array<SegmentDataType>, removeSegments: Array<string>): Array<string> {\n    let result = [data[0]];\n    for (let i = 1; i < data.length; i++) {\n      const segmentData = data[i];\n\n      const length = result.length;\n      let replaceIndex = -1;\n      for (let j = 0; j < length; j++) {\n        if (isVectorSameDirection(segmentData.vector, result[j].vector)) {\n          if (segmentData.length >= result[j].length) {\n            replaceIndex = j;\n          } else {\n            removeSegments.push(segmentData.name);\n          }\n        }\n      }\n      if (replaceIndex >= 0) {\n        result[replaceIndex] = segmentData;\n      } else {\n        if (!removeSegments.includes(segmentData.name)) {\n          result.push(segmentData);\n        }\n      }\n    }\n\n    return result.map((segmentData: SegmentDataType): string => segmentData.name);\n  }\n\n  @autobind\n  onClickDrawing() {\n    DataViewModel.clear();\n\n    const data = DataViewModel.analyzeInput();\n    if (data.points.length === 0 && data.segments.length === 0) {\n      DataViewModel.resetInputsStatus();\n      return;\n    }\n\n    this.setState({\n      points: data.points,\n      segments: data.segments,\n      drawingData: this.trimDrawingData(data).map((segment: string): DrawingSegmentType => ({\n        name: segment,\n        visible: true,\n        lineType: LineStyle.Medium\n      }))\n    });\n  }\n\n  render() {\n    const { points, drawingData } = this.state;\n    return (\n      <div className={'container-fluid'}>\n        <div className={'app-header'}>\n          <div className={'app-name'}>\n            <p>Gemath</p>\n          </div>\n        </div>\n        <div className=\"app-body\">\n          <div className={'app-drawing-panel'}>\n            <DrawingPanel drawingData={{ points, segments: drawingData, circles: DataViewModel.circlesData }} />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default IFrameView;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport IFrameView from './View/IFrameView';\n\nReactDOM.render(<IFrameView />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}